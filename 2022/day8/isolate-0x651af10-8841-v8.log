v8-version,9,6,180,15,-node.16,0
v8-platform,linux,linux
shared-library,/usr/bin/node,0x400000,0x48a0000,0
shared-library,/usr/lib/x86_64-linux-gnu/libc-2.31.so,0x7f0810b01000,0x7f0810c9b000,0
shared-library,/usr/lib/x86_64-linux-gnu/libpthread-2.31.so,0x7f0810cf3000,0x7f0810d0a000,0
shared-library,/usr/lib/x86_64-linux-gnu/libgcc_s.so.1,0x7f0810d16000,0x7f0810d2b000,0
shared-library,/usr/lib/x86_64-linux-gnu/libm-2.31.so,0x7f0810d31000,0x7f0810de5000,0
shared-library,/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28,0x7f0810e80000,0x7f0811007000,0
shared-library,/usr/lib/x86_64-linux-gnu/libdl-2.31.so,0x7f0811062000,0x7f0811065000,0
shared-library,/usr/lib/x86_64-linux-gnu/ld-2.31.so,0x7f0811079000,0x7f081109d000,0
shared-library,[vdso],0x7ffe43ff1000,0x7ffe43ff3000,0
shared-library-end
profiler,begin,1000
tick,0x7f0810fa5284,734,0,0x0,6
tick,0x178ef98,1804,0,0x0,6
tick,0x187e1bf,2883,0,0x0,6
new,CodeRange,0x7f07fc000000,0
new,MemoryChunk,0x29ae5e440000,262144
tick,0x1268a67,3947,0,0x0,6
new,MemoryChunk,0x203833f00000,262144
new,MemoryChunk,0x288f16f80000,262144
new,MemoryChunk,0x190d87e40000,262144
new,MemoryChunk,0x2590d1ec0000,262144
heap-capacity,1031072
heap-available,2198583104
new,MemoryChunk,0x2842ea080000,262144
new,MemoryChunk,0xdbdde640000,262144
new,MemoryChunk,0x136fed700000,262144
new,MemoryChunk,0x273b97980000,262144
tick,0xe9285e,5051,0,0x0,1
new,MemoryChunk,0x39a167d80000,262144
new,MemoryChunk,0x2b4a88f80000,262144
tick,0x126c2f7,6151,0,0x0,6
new,MemoryChunk,0x2989f3580000,262144
new,MemoryChunk,0x7f07fc000000,262144
tick,0x126cd39,7250,0,0x0,6
new,MemoryChunk,0x961eb000000,262144
tick,0xf59608,8345,0,0x0,6
code-creation,Builtin,2,8992,0x15b95c0,800,DeoptimizationEntry_Eager
code-creation,Builtin,2,9003,0x15b9900,804,DeoptimizationEntry_Soft
code-creation,Builtin,2,9008,0x15b9c40,804,DeoptimizationEntry_Bailout
code-creation,Builtin,2,9013,0x15b9f80,804,DeoptimizationEntry_Lazy
code-creation,Builtin,2,9018,0x15ba2c0,88,DynamicCheckMapsTrampoline
code-creation,Builtin,2,9023,0x15ba340,88,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,9029,0x15ba3c0,1368,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,9035,0x15ba940,464,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,9040,0x15bab40,648,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,9046,0x15bae00,220,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,9051,0x15baf00,364,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,9056,0x15bb080,128,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,9062,0x15bb140,100,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,9067,0x15bb1c0,296,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,9072,0x15bb300,348,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,9078,0x15bb480,384,CallFunction_ReceiverIsAny
code-creation,Builtin,2,9083,0x15bb640,104,CallBoundFunction
code-creation,Builtin,2,9088,0x15bb6c0,160,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,9093,0x15bb780,160,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,9099,0x15bb840,160,Call_ReceiverIsAny
code-creation,Builtin,2,9103,0x15bb900,988,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,9109,0x15bbd00,984,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,9115,0x15bc100,1068,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,9121,0x15bc540,1064,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,9127,0x15bc980,1068,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,9132,0x15bcdc0,1064,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,9137,0x15bd200,936,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,9143,0x15bd5c0,936,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,9149,0x15bd980,936,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,9154,0x15bdd40,748,CallProxy
code-creation,Builtin,2,9159,0x15be040,124,CallVarargs
code-creation,Builtin,2,9163,0x15be0c0,952,CallWithSpread
code-creation,Builtin,2,9168,0x15be480,1952,CallWithSpread_Baseline
code-creation,Builtin,2,9181,0x15bec40,1924,CallWithSpread_WithFeedback
code-creation,Builtin,2,9187,0x15bf400,868,CallWithArrayLike
code-creation,Builtin,2,9191,0x15bf780,1812,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,9197,0x15bfec0,124,CallForwardVarargs
code-creation,Builtin,2,9202,0x15bff40,124,CallFunctionForwardVarargs
code-creation,Builtin,2,9207,0x15bffc0,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,9212,0x15c0080,232,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,9218,0x15c0180,320,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,9224,0x15c0300,32,ConstructFunction
code-creation,Builtin,2,9229,0x15c0340,104,ConstructBoundFunction
code-creation,Builtin,2,9234,0x15c03c0,28,ConstructedNonConstructable
code-creation,Builtin,2,9239,0x15c0400,100,Construct
code-creation,Builtin,2,9244,0x15c0480,124,ConstructVarargs
code-creation,Builtin,2,9248,0x15c0500,976,ConstructWithSpread
code-creation,Builtin,2,9253,0x15c0900,1752,ConstructWithSpread_Baseline
code-creation,Builtin,2,9258,0x15c1000,1768,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,9264,0x15c1700,928,ConstructWithArrayLike
code-creation,Builtin,2,9269,0x15c1ac0,1652,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,9274,0x15c2140,164,ConstructForwardVarargs
code-creation,Builtin,2,9279,0x15c2200,164,ConstructFunctionForwardVarargs
code-creation,Builtin,2,9284,0x15c22c0,792,Construct_Baseline
code-creation,Builtin,2,9289,0x15c2600,812,Construct_WithFeedback
code-creation,Builtin,2,9294,0x15c2940,456,JSConstructStubGeneric
code-creation,Builtin,2,9299,0x15c2b40,352,JSBuiltinsConstructStub
code-creation,Builtin,2,9304,0x15c2cc0,688,FastNewObject
code-creation,Builtin,2,9309,0x15c2f80,300,FastNewClosure
code-creation,Builtin,2,9313,0x15c30c0,732,ConstructProxy
code-creation,Builtin,2,9318,0x15c33c0,192,JSEntry
code-creation,Builtin,2,9323,0x15c34c0,192,JSConstructEntry
code-creation,Builtin,2,9327,0x15c35c0,192,JSRunMicrotasksEntry
code-creation,Builtin,2,9332,0x15c36c0,96,JSEntryTrampoline
code-creation,Builtin,2,9337,0x15c3740,96,JSConstructEntryTrampoline
code-creation,Builtin,2,9342,0x15c37c0,284,ResumeGeneratorTrampoline
code-creation,Builtin,2,9347,0x15c3900,1124,StringCodePointAt
code-creation,Builtin,2,9352,0x15c3d80,1560,StringFromCodePointAt
code-creation,Builtin,2,9357,0x15c43c0,560,StringEqual
code-creation,Builtin,2,9362,0x15c4600,296,StringGreaterThan
code-creation,Builtin,2,9366,0x15c4740,296,StringGreaterThanOrEqual
code-creation,Builtin,2,9371,0x15c4880,296,StringLessThan
code-creation,Builtin,2,9376,0x15c49c0,296,StringLessThanOrEqual
code-creation,Builtin,2,9381,0x15c4b00,2528,StringSubstring
code-creation,Builtin,2,9386,0x15c5500,80,OrderedHashTableHealIndex
code-creation,Builtin,2,9391,0x15c5580,1172,InterpreterEntryTrampoline
code-creation,Builtin,2,9396,0x15c5a40,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,9401,0x15c5ac0,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,9407,0x15c5b40,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,9412,0x15c5bc0,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,9418,0x15c5c40,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,9424,0x15c5cc0,84,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,9429,0x15c5d40,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,9441,0x15c5dc0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,9447,0x15c5ec0,52,InterpreterOnStackReplacement
code-creation,Builtin,2,9454,0x15c5f00,596,BaselineOutOfLinePrologue
code-creation,Builtin,2,9459,0x15c6180,56,BaselineOnStackReplacement
code-creation,Builtin,2,9466,0x15c61c0,84,BaselineLeaveFrame
code-creation,Builtin,2,9472,0x15c6240,220,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,9479,0x15c6340,228,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,9485,0x15c6440,192,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,9492,0x15c6540,1004,CompileLazy
code-creation,Builtin,2,9499,0x15c6940,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,9509,0x15c69c0,272,InstantiateAsmJs
code-creation,Builtin,2,9515,0x15c6b00,32,NotifyDeoptimized
code-creation,Builtin,2,9522,0x15c6b40,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,9528,0x15c6b80,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,9535,0x15c6bc0,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,9542,0x15c6c00,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,9550,0x15c6c80,292,CallApiCallback
code-creation,Builtin,2,9556,0x15c6dc0,276,CallApiGetter
code-creation,Builtin,2,9562,0x15c6f00,12,HandleApiCall
code-creation,Builtin,2,9569,0x15c6f40,12,HandleApiCallAsFunction
code-creation,Builtin,2,9575,0x15c6f80,12,HandleApiCallAsConstructor
code-creation,Builtin,2,9582,0x15c6fc0,64,AllocateInYoungGeneration
code-creation,Builtin,2,9589,0x15c7040,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,9596,0x15c7080,64,AllocateInOldGeneration
code-creation,Builtin,2,9603,0x15c7100,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,9610,0x15c7140,436,CopyFastSmiOrObjectElements
code-creation,Builtin,2,9616,0x15c7300,496,GrowFastDoubleElements
code-creation,Builtin,2,9623,0x15c7500,404,GrowFastSmiOrObjectElements
code-creation,Builtin,2,9630,0x15c76c0,392,DebugBreakTrampoline
code-creation,Builtin,2,9637,0x15c7880,180,ToNumber
code-creation,Builtin,2,9643,0x15c7940,292,ToNumber_Baseline
code-creation,Builtin,2,9649,0x15c7a80,360,ToNumeric_Baseline
code-creation,Builtin,2,9656,0x15c7c00,104,PlainPrimitiveToNumber
code-creation,Builtin,2,9662,0x15c7c80,212,ToNumberConvertBigInt
code-creation,Builtin,2,9669,0x15c7d80,132,Typeof
code-creation,Builtin,2,9675,0x15c7e40,104,BigIntToI64
code-creation,Builtin,2,9681,0x15c7ec0,4,BigIntToI32Pair
code-creation,Builtin,2,9688,0x15c7f00,232,I64ToBigInt
code-creation,Builtin,2,9694,0x15c8000,4,I32PairToBigInt
code-creation,Builtin,2,9700,0x15c8040,112,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,9707,0x15c80c0,4304,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,9714,0x15c91c0,15820,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,9721,0x15ccfc0,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,9727,0x15cd100,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,9734,0x15cd180,12,LoadIC_StringLength
code-creation,Builtin,2,9741,0x15cd1c0,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,9747,0x15cd200,3128,LoadIC_NoFeedback
code-creation,Builtin,2,9754,0x15cde40,32,StoreGlobalIC_Slow
code-creation,Builtin,2,9760,0x15cde80,7336,StoreIC_NoFeedback
code-creation,Builtin,2,9767,0x15cfb40,184,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,9774,0x15cfc00,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,9781,0x15cfc80,244,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,9788,0x15cfd80,244,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9796,0x15cfe80,244,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,9804,0x15cff80,244,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,9812,0x15d0080,14052,StoreFastElementIC_Standard
code-creation,Builtin,2,9819,0x15d3780,9768,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9826,0x15d5dc0,13232,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,9833,0x15d9180,6236,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,9841,0x15daa00,8528,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,9848,0x15dcb80,19500,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9856,0x15e17c0,8528,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,9864,0x15e3940,11136,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,9871,0x15e6500,828,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,9878,0x15e6840,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,9885,0x15e6900,72,HasIndexedInterceptorIC
code-creation,Builtin,2,9891,0x15e6980,264,DynamicCheckMaps
code-creation,Builtin,2,9898,0x15e6ac0,224,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,9908,0x15e6bc0,172,EnqueueMicrotask
code-creation,Builtin,2,9914,0x15e6c80,8,RunMicrotasksTrampoline
code-creation,Builtin,2,9921,0x15e6cc0,3628,RunMicrotasks
code-creation,Builtin,2,9927,0x15e7b00,2688,HasProperty
code-creation,Builtin,2,9933,0x15e85c0,1180,DeleteProperty
code-creation,Builtin,2,9940,0x15e8a80,2000,CopyDataProperties
code-creation,Builtin,2,9946,0x15e9280,9232,SetDataProperties
code-creation,Builtin,2,9953,0x15eb6c0,28,Abort
code-creation,Builtin,2,9959,0x15eb700,28,AbortCSADcheck
code-creation,Builtin,2,9965,0x15eb740,12,EmptyFunction
code-creation,Builtin,2,9971,0x15eb780,12,Illegal
code-creation,Builtin,2,9977,0x15eb7c0,12,StrictPoisonPillThrower
code-creation,Builtin,2,9984,0x15eb800,12,UnsupportedThrower
code-creation,Builtin,2,9991,0x15eb840,64,ReturnReceiver
code-creation,Builtin,2,9997,0x15eb8c0,36,ArrayConstructor
code-creation,Builtin,2,10009,0x15eb900,416,ArrayConstructorImpl
code-creation,Builtin,2,10015,0x15ebac0,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,10023,0x15ebbc0,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,10031,0x15ebcc0,180,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,10039,0x15ebd80,180,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,10047,0x15ebe40,180,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,10055,0x15ebf00,180,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,10063,0x15ebfc0,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,10071,0x15ec0c0,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,10079,0x15ec1c0,520,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,10087,0x15ec400,484,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,10095,0x15ec600,444,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,10103,0x15ec7c0,408,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,10111,0x15ec980,444,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,10119,0x15ecb40,408,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,10127,0x15ecd00,452,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,10136,0x15ecf00,416,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,10144,0x15ed0c0,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,10151,0x15ed140,12,ArrayConcat
code-creation,Builtin,2,10157,0x15ed180,12,ArrayPrototypeFill
code-creation,Builtin,2,10164,0x15ed1c0,952,ArrayIncludesSmiOrObject
code-creation,Builtin,2,10171,0x15ed580,148,ArrayIncludesPackedDoubles
code-creation,Builtin,2,10177,0x15ed640,220,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,10184,0x15ed740,560,ArrayIncludes
code-creation,Builtin,2,10190,0x15ed980,860,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,10197,0x15edd00,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,10204,0x15edd80,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,10210,0x15ede00,560,ArrayIndexOf
code-creation,Builtin,2,10217,0x15ee040,12,ArrayPop
code-creation,Builtin,2,10223,0x15ee080,628,ArrayPrototypePop
code-creation,Builtin,2,10229,0x15ee300,12,ArrayPush
code-creation,Builtin,2,10236,0x15ee340,2432,ArrayPrototypePush
code-creation,Builtin,2,10242,0x15eed00,12,ArrayShift
code-creation,Builtin,2,10248,0x15eed40,12,ArrayUnshift
code-creation,Builtin,2,10254,0x15eed80,964,CloneFastJSArray
code-creation,Builtin,2,10261,0x15ef180,2236,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,10268,0x15efa40,992,ExtractFastJSArray
code-creation,Builtin,2,10274,0x15efe40,260,ArrayPrototypeEntries
code-creation,Builtin,2,10281,0x15eff80,248,ArrayPrototypeKeys
code-creation,Builtin,2,10287,0x15f0080,260,ArrayPrototypeValues
code-creation,Builtin,2,10294,0x15f01c0,4488,ArrayIteratorPrototypeNext
code-creation,Builtin,2,10303,0x15f1380,4228,FlattenIntoArray
code-creation,Builtin,2,10310,0x15f2440,4232,FlatMapIntoArray
code-creation,Builtin,2,10316,0x15f3500,384,ArrayPrototypeFlat
code-creation,Builtin,2,10323,0x15f36c0,436,ArrayPrototypeFlatMap
code-creation,Builtin,2,10329,0x15f3880,12,ArrayBufferConstructor
code-creation,Builtin,2,10336,0x15f38c0,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,10343,0x15f3900,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,10350,0x15f3940,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,10357,0x15f3980,816,AsyncFunctionEnter
code-creation,Builtin,2,10363,0x15f3cc0,136,AsyncFunctionReject
code-creation,Builtin,2,10370,0x15f3d80,128,AsyncFunctionResolve
code-creation,Builtin,2,10376,0x15f3e40,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,10383,0x15f3e80,2836,AsyncFunctionAwaitCaught
code-creation,Builtin,2,10390,0x15f49c0,2836,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,10397,0x15f5500,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,10404,0x15f55c0,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,10411,0x15f5680,12,BigIntConstructor
code-creation,Builtin,2,10417,0x15f56c0,12,BigIntAsUintN
code-creation,Builtin,2,10424,0x15f5700,12,BigIntAsIntN
code-creation,Builtin,2,10430,0x15f5740,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,10437,0x15f5780,12,BigIntPrototypeToString
code-creation,Builtin,2,10444,0x15f57c0,12,BigIntPrototypeValueOf
code-creation,Builtin,2,10450,0x15f5800,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,10457,0x15f5840,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,10465,0x15f5880,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,10474,0x15f58c0,12,CallSitePrototypeGetEvalOrigin
tick,0x7f0810c0f0af,10492,0,0x0,6
tick,0x7f0810cff839,10504,0,0x0,6
code-creation,Builtin,2,10509,0x15f5900,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,10518,0x15f5940,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,10524,0x15f5980,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,10529,0x15f59c0,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,10534,0x15f5a00,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,10540,0x15f5a40,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,10545,0x15f5a80,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,10550,0x15f5ac0,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,10556,0x15f5b00,12,CallSitePrototypeGetThis
code-creation,Builtin,2,10561,0x15f5b40,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,10566,0x15f5b80,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,10571,0x15f5bc0,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,10577,0x15f5c00,12,CallSitePrototypeIsEval
code-creation,Builtin,2,10582,0x15f5c40,12,CallSitePrototypeIsNative
code-creation,Builtin,2,10587,0x15f5c80,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,10592,0x15f5cc0,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,10597,0x15f5d00,12,CallSitePrototypeToString
code-creation,Builtin,2,10602,0x15f5d40,12,ConsoleDebug
code-creation,Builtin,2,10607,0x15f5d80,12,ConsoleError
code-creation,Builtin,2,10611,0x15f5dc0,12,ConsoleInfo
code-creation,Builtin,2,10616,0x15f5e00,12,ConsoleLog
code-creation,Builtin,2,10620,0x15f5e40,12,ConsoleWarn
code-creation,Builtin,2,10625,0x15f5e80,12,ConsoleDir
code-creation,Builtin,2,10629,0x15f5ec0,12,ConsoleDirXml
code-creation,Builtin,2,10634,0x15f5f00,12,ConsoleTable
code-creation,Builtin,2,10639,0x15f5f40,12,ConsoleTrace
code-creation,Builtin,2,10643,0x15f5f80,12,ConsoleGroup
code-creation,Builtin,2,10648,0x15f5fc0,12,ConsoleGroupCollapsed
code-creation,Builtin,2,10653,0x15f6000,12,ConsoleGroupEnd
code-creation,Builtin,2,10657,0x15f6040,12,ConsoleClear
code-creation,Builtin,2,10662,0x15f6080,12,ConsoleCount
code-creation,Builtin,2,10666,0x15f60c0,12,ConsoleCountReset
code-creation,Builtin,2,10671,0x15f6100,12,ConsoleAssert
code-creation,Builtin,2,10676,0x15f6140,12,ConsoleProfile
code-creation,Builtin,2,10684,0x15f6180,12,ConsoleProfileEnd
code-creation,Builtin,2,10689,0x15f61c0,12,ConsoleTime
code-creation,Builtin,2,10694,0x15f6200,12,ConsoleTimeLog
code-creation,Builtin,2,10699,0x15f6240,12,ConsoleTimeEnd
code-creation,Builtin,2,10703,0x15f6280,12,ConsoleTimeStamp
code-creation,Builtin,2,10708,0x15f62c0,12,ConsoleContext
code-creation,Builtin,2,10713,0x15f6300,12,DataViewConstructor
code-creation,Builtin,2,10717,0x15f6340,12,DateConstructor
code-creation,Builtin,2,10722,0x15f6380,232,DatePrototypeGetDate
code-creation,Builtin,2,10727,0x15f6480,232,DatePrototypeGetDay
code-creation,Builtin,2,10732,0x15f6580,232,DatePrototypeGetFullYear
code-creation,Builtin,2,10737,0x15f6680,232,DatePrototypeGetHours
code-creation,Builtin,2,10742,0x15f6780,212,DatePrototypeGetMilliseconds
code-creation,Builtin,2,10747,0x15f6880,232,DatePrototypeGetMinutes
code-creation,Builtin,2,10752,0x15f6980,232,DatePrototypeGetMonth
code-creation,Builtin,2,10757,0x15f6a80,232,DatePrototypeGetSeconds
code-creation,Builtin,2,10762,0x15f6b80,124,DatePrototypeGetTime
code-creation,Builtin,2,10767,0x15f6c00,212,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,10772,0x15f6d00,212,DatePrototypeGetUTCDate
code-creation,Builtin,2,10777,0x15f6e00,212,DatePrototypeGetUTCDay
code-creation,Builtin,2,10782,0x15f6f00,212,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,10787,0x15f7000,212,DatePrototypeGetUTCHours
code-creation,Builtin,2,10792,0x15f7100,212,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,10798,0x15f7200,212,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,10803,0x15f7300,212,DatePrototypeGetUTCMonth
code-creation,Builtin,2,10808,0x15f7400,212,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,10813,0x15f7500,124,DatePrototypeValueOf
code-creation,Builtin,2,10818,0x15f7580,368,DatePrototypeToPrimitive
code-creation,Builtin,2,10823,0x15f7700,12,DatePrototypeGetYear
code-creation,Builtin,2,10828,0x15f7740,12,DatePrototypeSetYear
code-creation,Builtin,2,10833,0x15f7780,12,DateNow
code-creation,Builtin,2,10837,0x15f77c0,12,DateParse
code-creation,Builtin,2,10842,0x15f7800,12,DatePrototypeSetDate
code-creation,Builtin,2,10847,0x15f7840,12,DatePrototypeSetFullYear
code-creation,Builtin,2,10852,0x15f7880,12,DatePrototypeSetHours
code-creation,Builtin,2,10857,0x15f78c0,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,10862,0x15f7900,12,DatePrototypeSetMinutes
code-creation,Builtin,2,10867,0x15f7940,12,DatePrototypeSetMonth
code-creation,Builtin,2,10872,0x15f7980,12,DatePrototypeSetSeconds
code-creation,Builtin,2,10877,0x15f79c0,12,DatePrototypeSetTime
code-creation,Builtin,2,10882,0x15f7a00,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,10887,0x15f7a40,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,10892,0x15f7a80,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,10897,0x15f7ac0,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,10902,0x15f7b00,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,10907,0x15f7b40,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,10913,0x15f7b80,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,10918,0x15f7bc0,12,DatePrototypeToDateString
code-creation,Builtin,2,10923,0x15f7c00,12,DatePrototypeToISOString
code-creation,Builtin,2,10928,0x15f7c40,12,DatePrototypeToUTCString
code-creation,Builtin,2,10933,0x15f7c80,12,DatePrototypeToString
code-creation,Builtin,2,10938,0x15f7cc0,12,DatePrototypeToTimeString
code-creation,Builtin,2,10943,0x15f7d00,12,DatePrototypeToJson
code-creation,Builtin,2,10948,0x15f7d40,12,DateUTC
code-creation,Builtin,2,10952,0x15f7d80,12,ErrorConstructor
code-creation,Builtin,2,10957,0x15f7dc0,12,ErrorCaptureStackTrace
code-creation,Builtin,2,10962,0x15f7e00,12,ErrorPrototypeToString
code-creation,Builtin,2,10967,0x15f7e40,12,FunctionConstructor
code-creation,Builtin,2,10972,0x15f7e80,76,FunctionPrototypeApply
code-creation,Builtin,2,10977,0x15f7f00,12,FunctionPrototypeBind
code-creation,Builtin,2,10982,0x15f7f40,32,FunctionPrototypeCall
code-creation,Builtin,2,10987,0x15f7f80,12,FunctionPrototypeToString
code-creation,Builtin,2,10992,0x15f7fc0,196,CreateIterResultObject
code-creation,Builtin,2,10999,0x15f80c0,804,CreateGeneratorObject
code-creation,Builtin,2,11004,0x15f8400,12,GeneratorFunctionConstructor
code-creation,Builtin,2,11010,0x15f8440,424,GeneratorPrototypeNext
code-creation,Builtin,2,11015,0x15f8600,428,GeneratorPrototypeReturn
code-creation,Builtin,2,11020,0x15f87c0,432,GeneratorPrototypeThrow
code-creation,Builtin,2,11025,0x15f8980,12,AsyncFunctionConstructor
code-creation,Builtin,2,11030,0x15f89c0,372,SuspendGeneratorBaseline
code-creation,Builtin,2,11035,0x15f8b40,88,ResumeGeneratorBaseline
code-creation,Builtin,2,11040,0x15f8bc0,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,11046,0x15f8c00,12,GlobalDecodeURI
code-creation,Builtin,2,11051,0x15f8c40,12,GlobalDecodeURIComponent
code-creation,Builtin,2,11056,0x15f8c80,12,GlobalEncodeURI
code-creation,Builtin,2,11060,0x15f8cc0,12,GlobalEncodeURIComponent
code-creation,Builtin,2,11065,0x15f8d00,12,GlobalEscape
code-creation,Builtin,2,11070,0x15f8d40,12,GlobalUnescape
code-creation,Builtin,2,11075,0x15f8d80,12,GlobalEval
code-creation,Builtin,2,11079,0x15f8dc0,140,GlobalIsFinite
code-creation,Builtin,2,11084,0x15f8e80,132,GlobalIsNaN
code-creation,Builtin,2,11088,0x15f8f40,12,JsonParse
code-creation,Builtin,2,11093,0x15f8f80,12,JsonStringify
code-creation,Builtin,2,11097,0x15f8fc0,4680,LoadIC
code-creation,Builtin,2,11102,0x15fa240,4368,LoadIC_Megamorphic
code-creation,Builtin,2,11107,0x15fb380,4592,LoadIC_Noninlined
code-creation,Builtin,2,11111,0x15fc580,44,LoadICTrampoline
code-creation,Builtin,2,11116,0x15fc5c0,24,LoadICBaseline
code-creation,Builtin,2,11121,0x15fc600,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,11126,0x15fc640,7512,LoadSuperIC
code-creation,Builtin,2,11130,0x15fe3c0,24,LoadSuperICBaseline
code-creation,Builtin,2,11135,0x15fe400,8280,KeyedLoadIC
code-creation,Builtin,2,11140,0x1600480,13328,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,11145,0x16038c0,44,KeyedLoadICTrampoline
code-creation,Builtin,2,11150,0x1603900,24,KeyedLoadICBaseline
code-creation,Builtin,2,11155,0x1603940,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,11160,0x1603980,5084,StoreGlobalIC
code-creation,Builtin,2,11165,0x1604d80,44,StoreGlobalICTrampoline
code-creation,Builtin,2,11170,0x1604dc0,24,StoreGlobalICBaseline
code-creation,Builtin,2,11175,0x1604e00,5328,StoreIC
code-creation,Builtin,2,11179,0x1606300,44,StoreICTrampoline
code-creation,Builtin,2,11184,0x1606340,24,StoreICBaseline
code-creation,Builtin,2,11188,0x1606380,5768,KeyedStoreIC
code-creation,Builtin,2,11193,0x1607a40,44,KeyedStoreICTrampoline
code-creation,Builtin,2,11198,0x1607a80,24,KeyedStoreICBaseline
code-creation,Builtin,2,11203,0x1607ac0,408,StoreInArrayLiteralIC
code-creation,Builtin,2,11208,0x1607c80,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,11213,0x1607cc0,140,LookupContextBaseline
code-creation,Builtin,2,11218,0x1607d80,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,11224,0x1607e40,3296,LoadGlobalIC
code-creation,Builtin,2,11228,0x1608b40,3280,LoadGlobalICInsideTypeof
code-creation,Builtin,2,11233,0x1609840,44,LoadGlobalICTrampoline
code-creation,Builtin,2,11238,0x1609880,24,LoadGlobalICBaseline
code-creation,Builtin,2,11243,0x16098c0,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,11248,0x1609900,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,11254,0x1609940,144,LookupGlobalICBaseline
code-creation,Builtin,2,11259,0x1609a00,144,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,11264,0x1609ac0,2096,CloneObjectIC
code-creation,Builtin,2,11269,0x160a300,24,CloneObjectICBaseline
code-creation,Builtin,2,11274,0x160a340,2028,CloneObjectIC_Slow
code-creation,Builtin,2,11279,0x160ab40,2880,KeyedHasIC
code-creation,Builtin,2,11283,0x160b6c0,24,KeyedHasICBaseline
code-creation,Builtin,2,11288,0x160b700,2684,KeyedHasIC_Megamorphic
code-creation,Builtin,2,11293,0x160c180,1472,IterableToList
code-creation,Builtin,2,11298,0x160c780,1272,IterableToFixedArray
code-creation,Builtin,2,11302,0x160cc80,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,11310,0x160cf80,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,11316,0x160cfc0,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,11321,0x160d040,1004,IterableToFixedArrayForWasm
code-creation,Builtin,2,11327,0x160d440,1664,StringListFromIterable
code-creation,Builtin,2,11331,0x160db00,1260,FindOrderedHashMapEntry
code-creation,Builtin,2,11336,0x160e000,4288,MapConstructor
code-creation,Builtin,2,11341,0x160f100,2012,MapPrototypeSet
code-creation,Builtin,2,11346,0x160f900,1576,MapPrototypeDelete
code-creation,Builtin,2,11351,0x160ff40,216,MapPrototypeGet
code-creation,Builtin,2,11355,0x1610040,168,MapPrototypeHas
code-creation,Builtin,2,11360,0x1610100,12,MapPrototypeClear
code-creation,Builtin,2,11365,0x1610140,284,MapPrototypeEntries
code-creation,Builtin,2,11370,0x1610280,144,MapPrototypeGetSize
code-creation,Builtin,2,11375,0x1610340,504,MapPrototypeForEach
code-creation,Builtin,2,11379,0x1610540,284,MapPrototypeKeys
code-creation,Builtin,2,11384,0x1610680,284,MapPrototypeValues
code-creation,Builtin,2,11389,0x16107c0,1068,MapIteratorPrototypeNext
code-creation,Builtin,2,11394,0x1610c00,1196,MapIteratorToList
code-creation,Builtin,2,11399,0x16110c0,12,NumberPrototypeToExponential
code-creation,Builtin,2,11404,0x1611100,12,NumberPrototypeToFixed
code-creation,Builtin,2,11409,0x1611140,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,11414,0x1611180,12,NumberPrototypeToPrecision
code-creation,Builtin,2,11420,0x16111c0,340,SameValue
code-creation,Builtin,2,11430,0x1611340,212,SameValueNumbersOnly
code-creation,Builtin,2,11435,0x1611440,792,Add_Baseline
code-creation,Builtin,2,11440,0x1611780,828,Subtract_Baseline
code-creation,Builtin,2,11444,0x1611ac0,808,Multiply_Baseline
code-creation,Builtin,2,11449,0x1611e00,832,Divide_Baseline
code-creation,Builtin,2,11454,0x1612180,764,Modulus_Baseline
code-creation,Builtin,2,11459,0x1612480,820,Exponentiate_Baseline
code-creation,Builtin,2,11464,0x16127c0,708,BitwiseAnd_Baseline
code-creation,Builtin,2,11468,0x1612ac0,700,BitwiseOr_Baseline
code-creation,Builtin,2,11473,0x1612d80,708,BitwiseXor_Baseline
code-creation,Builtin,2,11478,0x1613080,720,ShiftLeft_Baseline
code-creation,Builtin,2,11483,0x1613380,720,ShiftRight_Baseline
code-creation,Builtin,2,11488,0x1613680,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,11493,0x1613a00,720,Add_WithFeedback
code-creation,Builtin,2,11498,0x1613d00,780,Subtract_WithFeedback
code-creation,Builtin,2,11503,0x1614040,776,Multiply_WithFeedback
code-creation,Builtin,2,11508,0x1614380,804,Divide_WithFeedback
code-creation,Builtin,2,11512,0x16146c0,724,Modulus_WithFeedback
code-creation,Builtin,2,11517,0x16149c0,780,Exponentiate_WithFeedback
code-creation,Builtin,2,11522,0x1614d00,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,11527,0x1614fc0,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,11532,0x1615280,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,11537,0x1615540,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,11547,0x1615800,692,ShiftRight_WithFeedback
code-creation,Builtin,2,11566,0x1615ac0,808,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,11573,0x1615e00,1700,Equal_Baseline
code-creation,Builtin,2,11580,0x16164c0,916,StrictEqual_Baseline
code-creation,Builtin,2,11586,0x1616880,1268,LessThan_Baseline
code-creation,Builtin,2,11593,0x1616d80,1268,GreaterThan_Baseline
code-creation,Builtin,2,11599,0x1617280,1268,LessThanOrEqual_Baseline
code-creation,Builtin,2,11606,0x1617780,1268,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,11613,0x1617c80,1628,Equal_WithFeedback
code-creation,Builtin,2,11620,0x1618300,944,StrictEqual_WithFeedback
code-creation,Builtin,2,11626,0x16186c0,1248,LessThan_WithFeedback
code-creation,Builtin,2,11633,0x1618bc0,1248,GreaterThan_WithFeedback
code-creation,Builtin,2,11640,0x16190c0,1248,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,11647,0x16195c0,1248,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,11654,0x1619ac0,332,BitwiseNot_Baseline
code-creation,Builtin,2,11660,0x1619c40,460,Decrement_Baseline
code-creation,Builtin,2,11670,0x1619e40,464,Increment_Baseline
code-creation,Builtin,2,11677,0x161a040,488,Negate_Baseline
code-creation,Builtin,2,11683,0x161a240,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,11690,0x161a380,440,Decrement_WithFeedback
code-creation,Builtin,2,11696,0x161a540,444,Increment_WithFeedback
code-creation,Builtin,2,11703,0x161a700,472,Negate_WithFeedback
code-creation,Builtin,2,11710,0x161a900,252,ObjectAssign
code-creation,Builtin,2,11716,0x161aa00,884,ObjectCreate
code-creation,Builtin,2,11722,0x161ad80,12,ObjectDefineGetter
code-creation,Builtin,2,11729,0x161adc0,12,ObjectDefineProperties
code-creation,Builtin,2,11735,0x161ae00,12,ObjectDefineProperty
code-creation,Builtin,2,11742,0x161ae40,12,ObjectDefineSetter
code-creation,Builtin,2,11748,0x161ae80,1528,ObjectEntries
code-creation,Builtin,2,11755,0x161b480,12,ObjectFreeze
code-creation,Builtin,2,11761,0x161b4c0,5812,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,11768,0x161cb80,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,11775,0x161cbc0,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,11782,0x161ce40,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,11789,0x161ce80,172,ObjectHasOwn
code-creation,Builtin,2,11795,0x161cf40,400,ObjectIs
code-creation,Builtin,2,11801,0x161d100,12,ObjectIsFrozen
code-creation,Builtin,2,11807,0x161d140,12,ObjectIsSealed
code-creation,Builtin,2,11814,0x161d180,536,ObjectKeys
code-creation,Builtin,2,11820,0x161d3c0,12,ObjectLookupGetter
code-creation,Builtin,2,11826,0x161d400,12,ObjectLookupSetter
code-creation,Builtin,2,11833,0x161d440,2320,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,11840,0x161dd80,236,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,11847,0x161de80,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,11854,0x161dec0,12,ObjectPrototypeGetProto
code-creation,Builtin,2,11861,0x161df00,12,ObjectPrototypeSetProto
code-creation,Builtin,2,11867,0x161df40,12,ObjectSeal
code-creation,Builtin,2,11874,0x161df80,1124,ObjectToString
code-creation,Builtin,2,11880,0x161e400,1288,ObjectValues
code-creation,Builtin,2,11886,0x161e940,300,OrdinaryHasInstance
code-creation,Builtin,2,11893,0x161ea80,364,InstanceOf
code-creation,Builtin,2,11899,0x161ec00,648,InstanceOf_WithFeedback
code-creation,Builtin,2,11906,0x161eec0,664,InstanceOf_Baseline
code-creation,Builtin,2,11912,0x161f180,272,ForInEnumerate
code-creation,Builtin,2,11919,0x161f2c0,148,ForInPrepare
code-creation,Builtin,2,11925,0x161f380,2640,ForInFilter
code-creation,Builtin,2,11931,0x161fe00,56,ReflectApply
code-creation,Builtin,2,11937,0x161fe40,64,ReflectConstruct
code-creation,Builtin,2,11944,0x161fec0,12,ReflectDefineProperty
code-creation,Builtin,2,11950,0x161ff00,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,11957,0x161ff40,12,ReflectOwnKeys
code-creation,Builtin,2,11964,0x161ff80,12,ReflectSet
code-creation,Builtin,2,11970,0x161ffc0,12,RegExpCapture1Getter
code-creation,Builtin,2,11976,0x1620000,12,RegExpCapture2Getter
code-creation,Builtin,2,11981,0x1620040,12,RegExpCapture3Getter
code-creation,Builtin,2,11986,0x1620080,12,RegExpCapture4Getter
code-creation,Builtin,2,11991,0x16200c0,12,RegExpCapture5Getter
code-creation,Builtin,2,11996,0x1620100,12,RegExpCapture6Getter
code-creation,Builtin,2,12001,0x1620140,12,RegExpCapture7Getter
code-creation,Builtin,2,12006,0x1620180,12,RegExpCapture8Getter
code-creation,Builtin,2,12011,0x16201c0,12,RegExpCapture9Getter
code-creation,Builtin,2,12016,0x1620200,2272,RegExpConstructor
code-creation,Builtin,2,12021,0x1620b00,12,RegExpInputGetter
code-creation,Builtin,2,12025,0x1620b40,12,RegExpInputSetter
code-creation,Builtin,2,12030,0x1620b80,12,RegExpLastMatchGetter
code-creation,Builtin,2,12035,0x1620bc0,12,RegExpLastParenGetter
code-creation,Builtin,2,12040,0x1620c00,12,RegExpLeftContextGetter
code-creation,Builtin,2,12045,0x1620c40,936,RegExpPrototypeCompile
code-creation,Builtin,2,12050,0x1621000,12,RegExpPrototypeToString
code-creation,Builtin,2,12055,0x1621040,12,RegExpRightContextGetter
code-creation,Builtin,2,12060,0x1621080,252,RegExpExecAtom
code-creation,Builtin,2,12069,0x1621180,1024,RegExpExecInternal
code-creation,Builtin,2,12076,0x16215c0,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,12083,0x1621600,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,12090,0x1621640,2744,SetConstructor
code-creation,Builtin,2,12096,0x1622100,1324,SetPrototypeHas
code-creation,Builtin,2,12102,0x1622640,1756,SetPrototypeAdd
code-creation,Builtin,2,12109,0x1622d40,1532,SetPrototypeDelete
code-creation,Builtin,2,12115,0x1623340,12,SetPrototypeClear
code-creation,Builtin,2,12122,0x1623380,284,SetPrototypeEntries
code-creation,Builtin,2,12128,0x16234c0,144,SetPrototypeGetSize
code-creation,Builtin,2,12135,0x1623580,460,SetPrototypeForEach
code-creation,Builtin,2,12142,0x1623780,284,SetPrototypeValues
code-creation,Builtin,2,12148,0x16238c0,1004,SetIteratorPrototypeNext
code-creation,Builtin,2,12155,0x1623cc0,1124,SetOrSetIteratorToList
code-creation,Builtin,2,12161,0x1624140,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,12169,0x1624180,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,12176,0x16241c0,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,12183,0x1624200,1280,AtomicsLoad
code-creation,Builtin,2,12189,0x1624740,1016,AtomicsStore
code-creation,Builtin,2,12195,0x1624b40,1704,AtomicsExchange
code-creation,Builtin,2,12202,0x1625200,2096,AtomicsCompareExchange
code-creation,Builtin,2,12208,0x1625a40,1808,AtomicsAdd
code-creation,Builtin,2,12214,0x1626180,1808,AtomicsSub
code-creation,Builtin,2,12221,0x16268c0,1808,AtomicsAnd
code-creation,Builtin,2,12227,0x1627000,1808,AtomicsOr
code-creation,Builtin,2,12233,0x1627740,1808,AtomicsXor
code-creation,Builtin,2,12239,0x1627e80,12,AtomicsNotify
code-creation,Builtin,2,12246,0x1627ec0,12,AtomicsIsLockFree
code-creation,Builtin,2,12252,0x1627f00,12,AtomicsWait
code-creation,Builtin,2,12258,0x1627f40,12,AtomicsWaitAsync
code-creation,Builtin,2,12265,0x1627f80,12,StringFromCodePoint
code-creation,Builtin,2,12271,0x1627fc0,1444,StringFromCharCode
code-creation,Builtin,2,12278,0x1628580,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,12285,0x16285c0,4464,StringPrototypeMatchAll
code-creation,Builtin,2,12291,0x1629740,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,12298,0x1629780,1252,StringPrototypeReplace
code-creation,Builtin,2,12305,0x1629c80,2944,StringPrototypeSplit
code-creation,Builtin,2,12311,0x162a840,12,StringRaw
code-creation,Builtin,2,12318,0x162a880,12,SymbolConstructor
code-creation,Builtin,2,12324,0x162a8c0,12,SymbolFor
code-creation,Builtin,2,12330,0x162a900,12,SymbolKeyFor
code-creation,Builtin,2,12337,0x162a940,88,TypedArrayBaseConstructor
code-creation,Builtin,2,12343,0x162a9c0,264,TypedArrayConstructor
code-creation,Builtin,2,12350,0x162ab00,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,12357,0x162ab40,892,TypedArrayPrototypeByteLength
code-creation,Builtin,2,12364,0x162aec0,368,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,12371,0x162b040,600,TypedArrayPrototypeLength
code-creation,Builtin,2,12377,0x162b2c0,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,12384,0x162b300,12,TypedArrayPrototypeFill
code-creation,Builtin,2,12391,0x162b340,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,12398,0x162b380,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,12405,0x162b3c0,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,12412,0x162b400,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,12418,0x162b440,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,12439,0x162b580,10680,TypedArrayPrototypeMap
code-creation,Builtin,2,12451,0x162df40,792,GenericJSToWasmWrapper
code-creation,Builtin,2,12463,0x162e280,148,WasmCompileLazy
code-creation,Builtin,2,12474,0x162e340,168,WasmDebugBreak
code-creation,Builtin,2,12485,0x162e400,16,WasmOnStackReplace
code-creation,Builtin,2,12496,0x162e440,140,WasmFloat32ToNumber
code-creation,Builtin,2,12507,0x162e500,152,WasmFloat64ToNumber
code-creation,Builtin,2,12519,0x162e5c0,4,WasmI32AtomicWait32
code-creation,Builtin,2,12530,0x162e600,4,WasmI64AtomicWait32
code-creation,Builtin,2,12545,0x162e640,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,12558,0x162e680,4456,WeakMapConstructor
code-creation,Builtin,2,12569,0x162f800,200,WeakMapLookupHashIndex
code-creation,Builtin,2,12581,0x162f900,224,WeakMapGet
code-creation,Builtin,2,12591,0x162fa00,180,WeakMapPrototypeHas
code-creation,Builtin,2,12603,0x162fac0,204,WeakMapPrototypeSet
tick,0x7f0810b9064f,12621,0,0x0,6
tick,0x7f0810cff839,12631,0,0x0,6
code-creation,Builtin,2,12640,0x162fbc0,144,WeakMapPrototypeDelete
code-creation,Builtin,2,12650,0x162fc80,2944,WeakSetConstructor
code-creation,Builtin,2,12655,0x1630840,180,WeakSetPrototypeHas
code-creation,Builtin,2,12660,0x1630900,204,WeakSetPrototypeAdd
code-creation,Builtin,2,12665,0x1630a00,144,WeakSetPrototypeDelete
code-creation,Builtin,2,12670,0x1630ac0,384,WeakCollectionDelete
code-creation,Builtin,2,12675,0x1630c80,784,WeakCollectionSet
code-creation,Builtin,2,12680,0x1630fc0,296,AsyncGeneratorResolve
code-creation,Builtin,2,12685,0x1631100,104,AsyncGeneratorReject
code-creation,Builtin,2,12690,0x1631180,2788,AsyncGeneratorYield
code-creation,Builtin,2,12695,0x1631c80,2896,AsyncGeneratorReturn
code-creation,Builtin,2,12699,0x1632800,308,AsyncGeneratorResumeNext
code-creation,Builtin,2,12705,0x1632940,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,12710,0x1632980,1040,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,12715,0x1632dc0,1044,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,12721,0x1633200,1044,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,12726,0x1633640,2772,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,12731,0x1634140,2772,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,12736,0x1634c40,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,12742,0x1634cc0,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,12747,0x1634d80,120,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,12753,0x1634e00,120,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,12758,0x1634e80,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,12764,0x1634f00,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,12770,0x1634fc0,1608,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,12775,0x1635640,1724,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,12781,0x1635d00,1744,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,12786,0x1636400,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,12792,0x1636480,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,12798,0x1636580,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,12804,0x1636680,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,12811,0x1636780,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,12817,0x1636940,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,12823,0x1636b00,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,12829,0x1636c00,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,12835,0x1636d00,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,12842,0x1636e00,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,12848,0x1636fc0,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,12854,0x1637180,4,DirectCEntry
code-creation,Builtin,2,12859,0x16371c0,1116,StringAdd_CheckNone
code-creation,Builtin,2,12863,0x1637640,2520,SubString
code-creation,Builtin,2,12868,0x1638040,16,StackCheck
code-creation,Builtin,2,12873,0x1638080,84,DoubleToI
code-creation,Builtin,2,12877,0x1638100,2280,GetProperty
code-creation,Builtin,2,12882,0x1638a00,2360,GetPropertyWithReceiver
code-creation,Builtin,2,12887,0x1639340,15960,SetProperty
code-creation,Builtin,2,12891,0x163d1c0,13480,SetPropertyInLiteral
code-creation,Builtin,2,12896,0x1640680,8,MemCopyUint8Uint8
code-creation,Builtin,2,12901,0x16406c0,8,MemMove
code-creation,Builtin,2,12909,0x1640700,12,IsTraceCategoryEnabled
code-creation,Builtin,2,12914,0x1640740,12,Trace
code-creation,Builtin,2,12919,0x1640780,12,FinalizationRegistryUnregister
code-creation,Builtin,2,12924,0x16407c0,428,AsyncModuleEvaluate
code-creation,Builtin,2,12929,0x1640980,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,12934,0x16409c0,12,CallAsyncModuleRejected
code-creation,Builtin,2,12939,0x1640a00,268,AggregateErrorConstructor
code-creation,Builtin,2,12944,0x1640b40,856,ArrayPrototypeAt
code-creation,Builtin,2,12949,0x1640ec0,664,ArrayPrototypeConcat
code-creation,Builtin,2,12954,0x1641180,5848,ArrayPrototypeCopyWithin
code-creation,Builtin,2,12959,0x1642880,220,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,12965,0x1642980,624,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,12970,0x1642c00,3336,ArrayEveryLoopContinuation
code-creation,Builtin,2,12976,0x1643940,1500,ArrayEvery
code-creation,Builtin,2,12980,0x1643f40,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,12986,0x1644080,992,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,12992,0x1644480,3632,ArrayFilterLoopContinuation
code-creation,Builtin,2,12997,0x16452c0,4300,ArrayFilter
code-creation,Builtin,2,13001,0x16463c0,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,13007,0x16464c0,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,13013,0x1646500,320,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,13019,0x1646680,536,ArrayFindLoopContinuation
code-creation,Builtin,2,13025,0x16468c0,1488,ArrayPrototypeFind
code-creation,Builtin,2,13030,0x1646ec0,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,13035,0x1646fc0,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,13041,0x1647000,320,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,13047,0x1647180,532,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,13053,0x16473c0,1488,ArrayPrototypeFindIndex
code-creation,Builtin,2,13058,0x16479c0,456,ArrayFindLastLoopContinuation
code-creation,Builtin,2,13063,0x1647bc0,1732,ArrayPrototypeFindLast
code-creation,Builtin,2,13068,0x16482c0,452,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,13073,0x16484c0,1728,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,13079,0x1648bc0,220,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,13084,0x1648cc0,220,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,13090,0x1648dc0,3212,ArrayForEachLoopContinuation
code-creation,Builtin,2,13095,0x1649a80,1356,ArrayForEach
code-creation,Builtin,2,13100,0x164a000,3632,ArrayFrom
code-creation,Builtin,2,13104,0x164ae40,160,ArrayIsArray
code-creation,Builtin,2,13109,0x164af00,424,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,13115,0x164b0c0,44,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,13120,0x164b100,144,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,13126,0x164b1c0,332,ConvertToLocaleString
code-creation,Builtin,2,13131,0x164b340,764,JoinStackPush
code-creation,Builtin,2,13136,0x164b640,280,JoinStackPop
code-creation,Builtin,2,13140,0x164b780,6740,ArrayPrototypeJoin
code-creation,Builtin,2,13145,0x164d200,5464,ArrayPrototypeToLocaleString
code-creation,Builtin,2,13150,0x164e780,236,ArrayPrototypeToString
code-creation,Builtin,2,13155,0x164e880,6040,TypedArrayPrototypeJoin
code-creation,Builtin,2,13161,0x1650040,4736,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,13166,0x1651300,3864,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,13171,0x1652240,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,13177,0x1652380,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,13182,0x1652480,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,13188,0x16526c0,3256,ArrayMapLoopContinuation
code-creation,Builtin,2,13193,0x1653380,3936,ArrayMap
code-creation,Builtin,2,13197,0x1654300,1012,ArrayOf
code-creation,Builtin,2,13202,0x1654700,444,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,13210,0x16548c0,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,13216,0x16549c0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,13222,0x1654ac0,3276,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,13227,0x16557c0,2032,ArrayReduceRight
code-creation,Builtin,2,13234,0x1655fc0,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,13247,0x1656080,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,13256,0x1656180,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,13264,0x1656280,3288,ArrayReduceLoopContinuation
code-creation,Builtin,2,13271,0x1656f80,1636,ArrayReduce
code-creation,Builtin,2,13277,0x1657600,3244,ArrayPrototypeReverse
code-creation,Builtin,2,13284,0x16582c0,3664,ArrayPrototypeShift
code-creation,Builtin,2,13293,0x1659140,5332,ArrayPrototypeSlice
code-creation,Builtin,2,13303,0x165a640,220,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,13309,0x165a740,592,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,13315,0x165a9c0,3324,ArraySomeLoopContinuation
code-creation,Builtin,2,13320,0x165b6c0,1484,ArraySome
code-creation,Builtin,2,13324,0x165bcc0,14316,ArrayPrototypeSplice
code-creation,Builtin,2,13329,0x165f4c0,3276,ArrayPrototypeUnshift
code-creation,Builtin,2,13334,0x16601c0,332,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,13339,0x1660340,348,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,13345,0x16604c0,216,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,13350,0x16605c0,332,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,13356,0x1660740,216,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,13362,0x1660840,104,ArrayBufferIsView
code-creation,Builtin,2,13367,0x16608c0,396,ToInteger
code-creation,Builtin,2,13371,0x1660a80,3104,FastCreateDataProperty
code-creation,Builtin,2,13376,0x16616c0,680,CheckNumberInRange
code-creation,Builtin,2,13381,0x1661980,640,CheckSameObject
code-creation,Builtin,2,13386,0x1661c40,944,BooleanConstructor
code-creation,Builtin,2,13391,0x1662000,164,BooleanPrototypeToString
code-creation,Builtin,2,13396,0x16620c0,156,BooleanPrototypeValueOf
code-creation,Builtin,2,13401,0x1662180,1216,BigIntAddNoThrow
code-creation,Builtin,2,13405,0x1662680,1312,BigIntAdd
code-creation,Builtin,2,13410,0x1662bc0,1216,BigIntSubtractNoThrow
code-creation,Builtin,2,13415,0x16630c0,1312,BigIntSubtract
code-creation,Builtin,2,13420,0x1663600,284,BigIntUnaryMinus
code-creation,Builtin,2,13424,0x1663740,1348,ToString
code-creation,Builtin,2,13429,0x1663cc0,156,StringPrototypeToString
code-creation,Builtin,2,13434,0x1663d80,156,StringPrototypeValueOf
code-creation,Builtin,2,13439,0x1663e40,2480,StringToList
code-creation,Builtin,2,13443,0x1664800,1028,StringPrototypeCharAt
code-creation,Builtin,2,13448,0x1664c40,708,StringPrototypeCharCodeAt
code-creation,Builtin,2,13453,0x1664f40,1304,StringPrototypeCodePointAt
code-creation,Builtin,2,13459,0x1665480,412,StringPrototypeConcat
code-creation,Builtin,2,13464,0x1665640,1036,StringConstructor
code-creation,Builtin,2,13468,0x1665a80,1404,StringAddConvertLeft
code-creation,Builtin,2,13473,0x1666000,1448,StringAddConvertRight
code-creation,Builtin,2,13478,0x16665c0,824,StringCharAt
code-creation,Builtin,2,13483,0x1666900,16,FastNewClosureBaseline
code-creation,Builtin,2,13488,0x1666940,200,FastNewFunctionContextEval
code-creation,Builtin,2,13493,0x1666a40,200,FastNewFunctionContextFunction
code-creation,Builtin,2,13498,0x1666b40,248,CreateRegExpLiteral
code-creation,Builtin,2,13503,0x1666c40,1100,CreateShallowArrayLiteral
code-creation,Builtin,2,13508,0x16670c0,496,CreateEmptyArrayLiteral
code-creation,Builtin,2,13513,0x16672c0,1840,CreateShallowObjectLiteral
code-creation,Builtin,2,13518,0x1667a00,400,ObjectConstructor
code-creation,Builtin,2,13523,0x1667bc0,180,CreateEmptyLiteralObject
code-creation,Builtin,2,13528,0x1667c80,540,NumberConstructor
code-creation,Builtin,2,13533,0x1667ec0,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,13538,0x1667f40,64,StringToNumber
code-creation,Builtin,2,13546,0x1667fc0,184,NonNumberToNumber
code-creation,Builtin,2,13551,0x1668080,240,NonNumberToNumeric
code-creation,Builtin,2,13556,0x1668180,36,ToNumeric
code-creation,Builtin,2,13560,0x16681c0,1188,NumberToString
code-creation,Builtin,2,13565,0x1668680,104,ToBoolean
code-creation,Builtin,2,13570,0x1668700,100,ToBooleanForBaselineJump
code-creation,Builtin,2,13575,0x1668780,728,ToLength
code-creation,Builtin,2,13579,0x1668a80,1316,ToName
code-creation,Builtin,2,13584,0x1668fc0,768,ToObject
code-creation,Builtin,2,13588,0x1669300,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,13593,0x1669400,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,13599,0x1669500,236,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,13604,0x1669600,328,OrdinaryToPrimitive_Number
code-creation,Builtin,2,13609,0x1669780,328,OrdinaryToPrimitive_String
code-creation,Builtin,2,13614,0x1669900,232,FastConsoleAssert
code-creation,Builtin,2,13619,0x1669a00,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,13624,0x1669ac0,368,DataViewPrototypeGetByteLength
code-creation,Builtin,2,13629,0x1669c40,368,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,13635,0x1669dc0,592,DataViewPrototypeGetUint8
code-creation,Builtin,2,13640,0x166a040,592,DataViewPrototypeGetInt8
code-creation,Builtin,2,13645,0x166a2c0,660,DataViewPrototypeGetUint16
code-creation,Builtin,2,13650,0x166a580,656,DataViewPrototypeGetInt16
code-creation,Builtin,2,13655,0x166a840,824,DataViewPrototypeGetUint32
code-creation,Builtin,2,13660,0x166ab80,700,DataViewPrototypeGetInt32
code-creation,Builtin,2,13665,0x166ae40,860,DataViewPrototypeGetFloat32
code-creation,Builtin,2,13674,0x166b1c0,924,DataViewPrototypeGetFloat64
code-creation,Builtin,2,13692,0x166b580,1000,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,13700,0x166b980,1016,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,13707,0x166bd80,952,DataViewPrototypeSetUint8
code-creation,Builtin,2,13714,0x166c140,952,DataViewPrototypeSetInt8
code-creation,Builtin,2,13721,0x166c500,1048,DataViewPrototypeSetUint16
code-creation,Builtin,2,13727,0x166c940,1048,DataViewPrototypeSetInt16
code-creation,Builtin,2,13734,0x166cd80,1088,DataViewPrototypeSetUint32
code-creation,Builtin,2,13741,0x166d200,1088,DataViewPrototypeSetInt32
code-creation,Builtin,2,13748,0x166d680,1052,DataViewPrototypeSetFloat32
code-creation,Builtin,2,13755,0x166dac0,1116,DataViewPrototypeSetFloat64
code-creation,Builtin,2,13761,0x166df40,968,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,13768,0x166e340,968,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,13775,0x166e740,852,FinalizationRegistryConstructor
code-creation,Builtin,2,13782,0x166eac0,1164,FinalizationRegistryRegister
code-creation,Builtin,2,13789,0x166ef80,680,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,13797,0x166f240,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,13803,0x166f3c0,936,FastFunctionPrototypeBind
code-creation,Builtin,2,13810,0x166f780,96,IncBlockCounter
code-creation,Builtin,2,13816,0x166f800,236,GetTemplateObject
code-creation,Builtin,2,13823,0x166f900,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,13830,0x166f940,92,ForInNext
code-creation,Builtin,2,13836,0x166f9c0,132,GetImportMetaObjectBaseline
code-creation,Builtin,2,13843,0x166fa80,116,GetIteratorWithFeedback
code-creation,Builtin,2,13849,0x166fb00,100,GetIteratorBaseline
code-creation,Builtin,2,13856,0x166fb80,272,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,13863,0x166fcc0,1072,CallIteratorWithFeedback
code-creation,Builtin,2,13870,0x1670100,288,MathAbs
code-creation,Builtin,2,13876,0x1670240,428,MathCeil
code-creation,Builtin,2,13882,0x1670400,432,MathFloor
code-creation,Builtin,2,13888,0x16705c0,488,MathRound
code-creation,Builtin,2,13894,0x16707c0,428,MathTrunc
code-creation,Builtin,2,13901,0x1670980,376,MathPow
code-creation,Builtin,2,13907,0x1670b00,404,MathMax
code-creation,Builtin,2,13913,0x1670cc0,408,MathMin
code-creation,Builtin,2,13919,0x1670e80,328,MathAcos
code-creation,Builtin,2,13928,0x1671000,328,MathAcosh
code-creation,Builtin,2,13935,0x1671180,328,MathAsin
code-creation,Builtin,2,13941,0x1671300,328,MathAsinh
code-creation,Builtin,2,13947,0x1671480,328,MathAtan
code-creation,Builtin,2,13953,0x1671600,424,MathAtan2
code-creation,Builtin,2,13959,0x16717c0,328,MathAtanh
code-creation,Builtin,2,13965,0x1671940,328,MathCbrt
code-creation,Builtin,2,13971,0x1671ac0,168,MathClz32
code-creation,Builtin,2,13977,0x1671b80,328,MathCos
code-creation,Builtin,2,13984,0x1671d00,328,MathCosh
code-creation,Builtin,2,13990,0x1671e80,328,MathExp
code-creation,Builtin,2,13996,0x1672000,328,MathExpm1
code-creation,Builtin,2,14002,0x1672180,272,MathFround
code-creation,Builtin,2,14008,0x16722c0,304,MathImul
code-creation,Builtin,2,14014,0x1672400,328,MathLog
code-creation,Builtin,2,14020,0x1672580,328,MathLog1p
code-creation,Builtin,2,14026,0x1672700,328,MathLog10
code-creation,Builtin,2,14032,0x1672880,328,MathLog2
code-creation,Builtin,2,14038,0x1672a00,328,MathSin
code-creation,Builtin,2,14045,0x1672b80,180,MathSign
code-creation,Builtin,2,14051,0x1672c40,328,MathSinh
code-creation,Builtin,2,14057,0x1672dc0,268,MathSqrt
code-creation,Builtin,2,14063,0x1672f00,328,MathTan
code-creation,Builtin,2,14069,0x1673080,328,MathTanh
code-creation,Builtin,2,14075,0x1673200,1068,MathHypot
code-creation,Builtin,2,14081,0x1673640,336,MathRandom
code-creation,Builtin,2,14088,0x16737c0,2976,NumberPrototypeToString
code-creation,Builtin,2,14094,0x1674380,156,NumberIsFinite
code-creation,Builtin,2,14101,0x1674440,344,NumberIsInteger
code-creation,Builtin,2,14107,0x16745c0,128,NumberIsNaN
code-creation,Builtin,2,14113,0x1674680,376,NumberIsSafeInteger
code-creation,Builtin,2,14120,0x1674800,156,NumberPrototypeValueOf
code-creation,Builtin,2,14126,0x16748c0,196,NumberParseFloat
code-creation,Builtin,2,14133,0x16749c0,248,ParseInt
code-creation,Builtin,2,14139,0x1674ac0,84,NumberParseInt
code-creation,Builtin,2,14145,0x1674b40,860,Add
code-creation,Builtin,2,14151,0x1674ec0,424,Subtract
code-creation,Builtin,2,14157,0x1675080,608,Multiply
code-creation,Builtin,2,14164,0x1675300,532,Divide
code-creation,Builtin,2,14170,0x1675540,592,Modulus
code-creation,Builtin,2,14176,0x16757c0,532,Exponentiate
code-creation,Builtin,2,14182,0x1675a00,344,Negate
code-creation,Builtin,2,14188,0x1675b80,112,BitwiseNot
code-creation,Builtin,2,14194,0x1675c00,112,Decrement
code-creation,Builtin,2,14200,0x1675c80,112,Increment
code-creation,Builtin,2,14206,0x1675d00,392,ShiftLeft
code-creation,Builtin,2,14212,0x1675ec0,392,ShiftRight
code-creation,Builtin,2,14219,0x1676080,508,ShiftRightLogical
code-creation,Builtin,2,14225,0x1676280,388,BitwiseAnd
code-creation,Builtin,2,14231,0x1676440,388,BitwiseOr
code-creation,Builtin,2,14237,0x1676600,388,BitwiseXor
code-creation,Builtin,2,14243,0x16767c0,804,LessThan
code-creation,Builtin,2,14255,0x1676b00,804,LessThanOrEqual
code-creation,Builtin,2,14262,0x1676e40,804,GreaterThan
code-creation,Builtin,2,14268,0x1677180,804,GreaterThanOrEqual
code-creation,Builtin,2,14274,0x16774c0,864,Equal
code-creation,Builtin,2,14280,0x1677840,356,StrictEqual
code-creation,Builtin,2,14286,0x16779c0,3248,ObjectFromEntries
code-creation,Builtin,2,14293,0x1678680,772,CreateObjectWithoutProperties
code-creation,Builtin,2,14300,0x16789c0,144,ObjectIsExtensible
code-creation,Builtin,2,14307,0x1678a80,152,ObjectPreventExtensions
code-creation,Builtin,2,14313,0x1678b40,144,ObjectGetPrototypeOf
code-creation,Builtin,2,14320,0x1678c00,312,ObjectSetPrototypeOf
code-creation,Builtin,2,14326,0x1678d40,80,ObjectPrototypeToString
code-creation,Builtin,2,14333,0x1678dc0,96,ObjectPrototypeValueOf
code-creation,Builtin,2,14340,0x1678e40,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,14346,0x1678f00,864,FulfillPromise
code-creation,Builtin,2,14353,0x1679280,984,RejectPromise
code-creation,Builtin,2,14359,0x1679680,2428,NewPromiseCapability
code-creation,Builtin,2,14366,0x167a000,172,PromiseCapabilityDefaultReject
code-creation,Builtin,2,14373,0x167a0c0,156,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,14380,0x167a180,1412,PerformPromiseThen
code-creation,Builtin,2,14390,0x167a740,660,PromiseReject
code-creation,Builtin,2,14397,0x167aa00,300,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,14404,0x167ab40,112,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,14411,0x167abc0,4612,PromiseAll
code-creation,Builtin,2,14418,0x167be00,4932,PromiseAllSettled
code-creation,Builtin,2,14424,0x167d180,1112,PromiseAllResolveElementClosure
code-creation,Builtin,2,14431,0x167d600,1404,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,14438,0x167db80,1412,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,14446,0x167e140,1188,PromiseAnyRejectElementClosure
code-creation,Builtin,2,14453,0x167e600,2404,PromiseAny
code-creation,Builtin,2,14459,0x167ef80,2964,PromiseConstructor
code-creation,Builtin,2,14466,0x167fb40,300,PromisePrototypeCatch
code-creation,Builtin,2,14472,0x167fc80,88,PromiseValueThunkFinally
code-creation,Builtin,2,14479,0x167fd00,84,PromiseThrowerFinally
code-creation,Builtin,2,14486,0x167fd80,908,PromiseCatchFinally
code-creation,Builtin,2,14492,0x1680140,908,PromiseThenFinally
code-creation,Builtin,2,14499,0x1680500,1740,PromisePrototypeFinally
code-creation,Builtin,2,14505,0x1680c00,1372,PromiseRace
code-creation,Builtin,2,14512,0x1681180,316,PromiseFulfillReactionJob
code-creation,Builtin,2,14518,0x16812c0,424,PromiseRejectReactionJob
code-creation,Builtin,2,14525,0x1681480,156,PromiseResolveTrampoline
code-creation,Builtin,2,14532,0x1681540,668,PromiseResolve
code-creation,Builtin,2,14538,0x1681800,712,ResolvePromise
code-creation,Builtin,2,14545,0x1681b00,2248,PromisePrototypeThen
code-creation,Builtin,2,14551,0x1682400,1152,PromiseResolveThenableJob
code-creation,Builtin,2,14558,0x16828c0,448,ProxyConstructor
code-creation,Builtin,2,14564,0x1682ac0,1796,ProxyDeleteProperty
code-creation,Builtin,2,14571,0x1683200,2152,ProxyGetProperty
code-creation,Builtin,2,14577,0x1683a80,1084,ProxyGetPrototypeOf
code-creation,Builtin,2,14584,0x1683ec0,1708,ProxyHasProperty
code-creation,Builtin,2,14590,0x1684580,796,ProxyIsExtensible
code-creation,Builtin,2,14597,0x16848c0,840,ProxyPreventExtensions
code-creation,Builtin,2,14603,0x1684c40,1152,ProxyRevocable
code-creation,Builtin,2,14610,0x1685100,132,ProxyRevoke
code-creation,Builtin,2,14616,0x16851c0,2264,ProxySetProperty
code-creation,Builtin,2,14622,0x1685ac0,1340,ProxySetPrototypeOf
code-creation,Builtin,2,14629,0x1686000,212,ReflectIsExtensible
code-creation,Builtin,2,14635,0x1686100,216,ReflectPreventExtensions
code-creation,Builtin,2,14642,0x1686200,188,ReflectGetPrototypeOf
code-creation,Builtin,2,14649,0x16862c0,300,ReflectSetPrototypeOf
code-creation,Builtin,2,14655,0x1686400,296,ReflectGet
code-creation,Builtin,2,14662,0x1686540,160,ReflectDeleteProperty
code-creation,Builtin,2,14668,0x1686600,148,ReflectHas
code-creation,Builtin,2,14674,0x16866c0,5168,RegExpPrototypeExecSlow
code-creation,Builtin,2,14681,0x1687b00,5160,RegExpPrototypeExec
code-creation,Builtin,2,14687,0x1688f40,2400,RegExpPrototypeMatchAll
code-creation,Builtin,2,14694,0x16898c0,9480,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,14701,0x168be00,8880,RegExpMatchFast
code-creation,Builtin,2,14707,0x168e0c0,3640,RegExpPrototypeMatch
code-creation,Builtin,2,14714,0x168ef00,6340,RegExpReplace
code-creation,Builtin,2,14720,0x1690800,528,RegExpPrototypeReplace
code-creation,Builtin,2,14727,0x1690a40,1408,RegExpSearchFast
code-creation,Builtin,2,14734,0x1691000,1652,RegExpPrototypeSearch
code-creation,Builtin,2,14753,0x1691680,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,14761,0x1691780,5872,RegExpSplit
code-creation,Builtin,2,14767,0x1692e80,480,RegExpPrototypeSplit
code-creation,Builtin,2,14773,0x1693080,2264,RegExpPrototypeTest
code-creation,Builtin,2,14780,0x1693980,1356,RegExpPrototypeTestFast
code-creation,Builtin,2,14787,0x1693f00,236,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,14793,0x1694000,252,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,14800,0x1694100,252,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,14807,0x1694200,252,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,14818,0x1694300,252,RegExpPrototypeLinearGetter
code-creation,Builtin,2,14824,0x1694400,252,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,14831,0x1694500,280,RegExpPrototypeStickyGetter
code-creation,Builtin,2,14838,0x1694640,280,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,14845,0x1694780,2316,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,14852,0x16950c0,1516,StringPrototypeAt
code-creation,Builtin,2,14858,0x16956c0,3076,StringPrototypeEndsWith
code-creation,Builtin,2,14865,0x1696300,488,CreateHTML
code-creation,Builtin,2,14871,0x1696500,164,StringPrototypeAnchor
code-creation,Builtin,2,14878,0x16965c0,132,StringPrototypeBig
code-creation,Builtin,2,14884,0x1696680,132,StringPrototypeBlink
code-creation,Builtin,2,14891,0x1696740,132,StringPrototypeBold
code-creation,Builtin,2,14897,0x1696800,172,StringPrototypeFontcolor
code-creation,Builtin,2,14904,0x16968c0,172,StringPrototypeFontsize
code-creation,Builtin,2,14911,0x1696980,132,StringPrototypeFixed
code-creation,Builtin,2,14917,0x1696a40,132,StringPrototypeItalics
code-creation,Builtin,2,14924,0x1696b00,172,StringPrototypeLink
code-creation,Builtin,2,14931,0x1696bc0,132,StringPrototypeSmall
code-creation,Builtin,2,14937,0x1696c80,132,StringPrototypeStrike
code-creation,Builtin,2,14944,0x1696d40,132,StringPrototypeSub
code-creation,Builtin,2,14950,0x1696e00,132,StringPrototypeSup
code-creation,Builtin,2,14957,0x1696ec0,1060,StringPrototypeIncludes
code-creation,Builtin,2,14964,0x1697300,644,StringPrototypeIndexOf
code-creation,Builtin,2,14970,0x16975c0,348,StringPrototypeIterator
code-creation,Builtin,2,14977,0x1697740,2048,StringIteratorPrototypeNext
code-creation,Builtin,2,14984,0x1697f80,1344,StringPrototypeMatch
code-creation,Builtin,2,14990,0x1698500,1344,StringPrototypeSearch
code-creation,Builtin,2,14997,0x1698a80,836,StringPrototypePadStart
code-creation,Builtin,2,15004,0x1698e00,840,StringPrototypePadEnd
code-creation,Builtin,2,15010,0x1699180,120,StringRepeat
code-creation,Builtin,2,15016,0x1699200,408,StringPrototypeRepeat
code-creation,Builtin,2,15023,0x16993c0,11280,StringPrototypeReplaceAll
code-creation,Builtin,2,15030,0x169c000,3440,StringPrototypeSlice
code-creation,Builtin,2,15036,0x169cd80,3092,StringPrototypeStartsWith
code-creation,Builtin,2,15043,0x169d9c0,3384,StringPrototypeSubstr
code-creation,Builtin,2,15050,0x169e700,3312,StringPrototypeSubstring
code-creation,Builtin,2,15057,0x169f400,7024,StringPrototypeTrim
code-creation,Builtin,2,15063,0x16a0f80,6428,StringPrototypeTrimStart
code-creation,Builtin,2,15070,0x16a28c0,5944,StringPrototypeTrimEnd
code-creation,Builtin,2,15076,0x16a4000,164,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,15084,0x16a40c0,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,15090,0x16a4180,176,SymbolPrototypeToString
code-creation,Builtin,2,15097,0x16a4240,156,SymbolPrototypeValueOf
code-creation,Builtin,2,15104,0x16a4300,1180,TypedArrayPrototypeAt
code-creation,Builtin,2,15110,0x16a47c0,10204,CreateTypedArray
code-creation,Builtin,2,15117,0x16a6fc0,1772,TypedArrayPrototypeEvery
code-creation,Builtin,2,15123,0x16a76c0,440,TypedArrayPrototypeEntries
code-creation,Builtin,2,15130,0x16a7880,3680,TypedArrayPrototypeFilter
code-creation,Builtin,2,15137,0x16a8700,1112,TypedArrayPrototypeFind
code-creation,Builtin,2,15144,0x16a8b80,1116,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,15151,0x16a9000,1104,TypedArrayPrototypeFindLast
code-creation,Builtin,2,15157,0x16a9480,1108,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,15165,0x16a9900,968,TypedArrayPrototypeForEach
code-creation,Builtin,2,15172,0x16a9d00,2372,TypedArrayFrom
code-creation,Builtin,2,15178,0x16aa680,428,TypedArrayPrototypeKeys
code-creation,Builtin,2,15185,0x16aa840,1032,TypedArrayOf
code-creation,Builtin,2,15191,0x16aac80,1080,TypedArrayPrototypeReduce
code-creation,Builtin,2,15198,0x16ab0c0,1080,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,15204,0x16ab500,2780,TypedArrayPrototypeSet
code-creation,Builtin,2,15211,0x16ac000,3964,TypedArrayPrototypeSlice
code-creation,Builtin,2,15221,0x16acf80,1784,TypedArrayPrototypeSome
code-creation,Builtin,2,15227,0x16ad680,1056,TypedArrayMergeSort
code-creation,Builtin,2,15234,0x16adac0,1644,TypedArrayPrototypeSort
code-creation,Builtin,2,15241,0x16ae140,2812,TypedArrayPrototypeSubArray
code-creation,Builtin,2,15248,0x16aec40,440,TypedArrayPrototypeValues
code-creation,Builtin,2,15255,0x16aee00,980,WeakRefConstructor
code-creation,Builtin,2,15261,0x16af200,184,WeakRefDeref
code-creation,Builtin,2,15267,0x16af2c0,696,NewSloppyArgumentsElements
code-creation,Builtin,2,15274,0x16af580,308,NewStrictArgumentsElements
code-creation,Builtin,2,15281,0x16af6c0,336,NewRestArgumentsElements
code-creation,Builtin,2,15288,0x16af840,1404,FastNewSloppyArguments
code-creation,Builtin,2,15294,0x16afdc0,528,FastNewStrictArguments
code-creation,Builtin,2,15302,0x16b0000,560,FastNewRestArguments
code-creation,Builtin,2,15309,0x16b0240,700,StringSlowFlatten
code-creation,Builtin,2,15315,0x16b0500,2096,StringIndexOf
code-creation,Builtin,2,15321,0x16b0d40,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,15328,0x16b0d80,20,TestHelperPlus1
code-creation,Builtin,2,15335,0x16b0dc0,20,TestHelperPlus2
code-creation,Builtin,2,15341,0x16b0e00,96,NewSmiBox
code-creation,Builtin,2,15347,0x16b0e80,24,ReturnTwoValues
code-creation,Builtin,2,15354,0x16b0ec0,32,Load_FastSmiElements_0
code-creation,Builtin,2,15360,0x16b0f00,32,Load_FastObjectElements_0
code-creation,Builtin,2,15367,0x16b0f40,148,Load_FastDoubleElements_0
code-creation,Builtin,2,15374,0x16b1000,32,Store_FastSmiElements_0
code-creation,Builtin,2,15381,0x16b1040,92,Store_FastObjectElements_0
code-creation,Builtin,2,15388,0x16b10c0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,15394,0x16b1100,40,Delete_FastSmiElements_0
code-creation,Builtin,2,15401,0x16b1140,40,Delete_FastObjectElements_0
code-creation,Builtin,2,15408,0x16b1180,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,15415,0x16b11c0,324,SortCompareDefault
code-creation,Builtin,2,15421,0x16b1340,96,SortCompareUserFn
code-creation,Builtin,2,15428,0x16b13c0,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,15435,0x16b1400,308,Copy
code-creation,Builtin,2,15441,0x16b1540,5756,MergeAt
code-creation,Builtin,2,15447,0x16b2bc0,792,GallopLeft
code-creation,Builtin,2,15454,0x16b2f00,832,GallopRight
code-creation,Builtin,2,15460,0x16b3280,3836,ArrayTimSort
code-creation,Builtin,2,15466,0x16b4180,2144,ArrayPrototypeSort
code-creation,Builtin,2,15473,0x16b4a00,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,15479,0x16b4a80,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,15486,0x16b4b00,76,WasmTaggedToFloat64
code-creation,Builtin,2,15493,0x16b4b80,72,WasmMemoryGrow
code-creation,Builtin,2,15499,0x16b4c00,100,WasmTableInit
code-creation,Builtin,2,15505,0x16b4c80,100,WasmTableCopy
code-creation,Builtin,2,15512,0x16b4d00,84,WasmTableFill
code-creation,Builtin,2,15518,0x16b4d80,72,WasmTableGrow
code-creation,Builtin,2,15524,0x16b4e00,144,WasmTableGet
code-creation,Builtin,2,15530,0x16b4ec0,236,WasmTableSet
code-creation,Builtin,2,15537,0x16b4fc0,96,WasmRefFunc
code-creation,Builtin,2,15543,0x16b5040,148,WasmAllocateFixedArray
code-creation,Builtin,2,15550,0x16b5100,44,WasmThrow
code-creation,Builtin,2,15556,0x16b5140,56,WasmRethrow
code-creation,Builtin,2,15562,0x16b5180,44,WasmTriggerTierUp
code-creation,Builtin,2,15568,0x16b51c0,32,WasmStackGuard
code-creation,Builtin,2,15575,0x16b5200,32,WasmStackOverflow
code-creation,Builtin,2,15581,0x16b5240,40,WasmTraceMemory
code-creation,Builtin,2,15588,0x16b5280,32,WasmTraceEnter
code-creation,Builtin,2,15594,0x16b52c0,40,WasmTraceExit
code-creation,Builtin,2,15600,0x16b5300,344,WasmAllocateJSArray
code-creation,Builtin,2,15607,0x16b5480,104,WasmAllocatePair
code-creation,Builtin,2,15613,0x16b5500,64,WasmAllocateRtt
code-creation,Builtin,2,15620,0x16b5580,72,WasmAllocateFreshRtt
code-creation,Builtin,2,15626,0x16b5600,124,WasmAllocateStructWithRtt
code-creation,Builtin,2,15633,0x16b5680,140,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,15640,0x16b5740,176,WasmAllocateArray_InitZero
code-creation,Builtin,2,15650,0x16b5800,180,WasmAllocateArray_InitNull
code-creation,Builtin,2,15657,0x16b58c0,140,WasmArrayCopyWithChecks
code-creation,Builtin,2,15663,0x16b5980,248,WasmAllocateObjectWrapper
code-creation,Builtin,2,15670,0x16b5a80,52,WasmSubtypeCheck
code-creation,Builtin,2,15677,0x16b5ac0,8,WasmInt32ToNumber
code-creation,Builtin,2,15683,0x16b5b00,116,WasmUint32ToNumber
code-creation,Builtin,2,15689,0x16b5b80,144,UintPtr53ToNumber
code-creation,Builtin,2,15696,0x16b5c40,96,WasmAtomicNotify
code-creation,Builtin,2,15702,0x16b5cc0,116,WasmI32AtomicWait64
code-creation,Builtin,2,15709,0x16b5d40,116,WasmI64AtomicWait64
code-creation,Builtin,2,15715,0x16b5dc0,596,WasmGetOwnProperty
code-creation,Builtin,2,15722,0x16b6040,40,WasmTrap
code-creation,Builtin,2,15728,0x16b6080,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,15734,0x16b60c0,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,15741,0x16b6100,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,15748,0x16b6140,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,15755,0x16b6180,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,15762,0x16b61c0,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,15768,0x16b6200,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,15776,0x16b6240,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,15782,0x16b6280,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,15789,0x16b62c0,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,15797,0x16b6300,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,15816,0x16b6340,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,15824,0x16b6380,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,15830,0x16b63c0,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,15837,0x16b6400,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,15844,0x16b6440,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,15851,0x16b6480,172,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,15858,0x16b6540,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,15866,0x16b6580,116,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,15873,0x16b6600,112,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,15880,0x16b6680,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,15888,0x16b66c0,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,15895,0x16b67c0,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,15902,0x16b68c0,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,15910,0x16b6900,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,15917,0x16b6940,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,15924,0x16b6980,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,15931,0x16b69c0,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,15939,0x16b6a80,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,15945,0x16b6ac0,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,15952,0x16b6b00,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,15960,0x16b6b40,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,15967,0x16b6b80,2740,Load_GenericElementsAccessor_0
code-creation,Builtin,2,15974,0x16b7640,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,15981,0x16b7680,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,15988,0x16b76c0,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,15995,0x16b7700,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,16002,0x16b77c0,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,16010,0x16b7880,116,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,16017,0x16b7900,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,16024,0x16b7940,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,16032,0x16b7a00,112,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,16039,0x16b7a80,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,16049,0x16b7ac0,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,16057,0x16b7b80,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,16064,0x16b7bc0,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,16072,0x16b7c00,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,16079,0x16b7e80,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,16087,0x16b7f80,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,16094,0x16b7fc0,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,16102,0x16b80c0,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,16109,0x16b81c0,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,16116,0x16b8200,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,16123,0x16b8300,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,16130,0x16b8340,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,16138,0x16b8380,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,16145,0x16b8440,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,16152,0x16b8480,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,16160,0x16b84c0,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,16167,0x16b8580,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,16174,0x16b85c0,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,16181,0x16b8600,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,16188,0x16b86c0,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,16195,0x16b8700,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,16203,0x16b8740,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,16210,0x16b8800,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,16217,0x16b88c0,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,16224,0x16b8980,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,16232,0x16b8a40,12,CollatorConstructor
code-creation,Builtin,2,16238,0x16b8a80,12,CollatorInternalCompare
code-creation,Builtin,2,16245,0x16b8ac0,12,CollatorPrototypeCompare
code-creation,Builtin,2,16252,0x16b8b00,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,16259,0x16b8b40,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,16266,0x16b8b80,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,16273,0x16b8bc0,12,DatePrototypeToLocaleString
code-creation,Builtin,2,16281,0x16b8c00,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,16296,0x16b8c40,12,DateTimeFormatConstructor
code-creation,Builtin,2,16305,0x16b8c80,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,16314,0x16b8cc0,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,16323,0x16b8d00,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,16333,0x16b8d40,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,16348,0x16b8d80,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,16364,0x16b8dc0,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,16373,0x16b8e00,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,16382,0x16b8e40,12,DisplayNamesConstructor
code-creation,Builtin,2,16390,0x16b8e80,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,16400,0x16b8ec0,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,16410,0x16b8f00,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,16419,0x16b8f40,12,IntlGetCanonicalLocales
code-creation,Builtin,2,16437,0x16b8f80,12,IntlSupportedValuesOf
code-creation,Builtin,2,16446,0x16b8fc0,12,ListFormatConstructor
code-creation,Builtin,2,16454,0x16b9000,228,ListFormatPrototypeFormat
code-creation,Builtin,2,16463,0x16b9100,228,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,16473,0x16b9200,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,16482,0x16b9240,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,16492,0x16b9280,12,LocaleConstructor
code-creation,Builtin,2,16506,0x16b92c0,12,LocalePrototypeBaseName
code-creation,Builtin,2,16515,0x16b9300,12,LocalePrototypeCalendar
code-creation,Builtin,2,16524,0x16b9340,12,LocalePrototypeCalendars
code-creation,Builtin,2,16533,0x16b9380,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,16542,0x16b93c0,12,LocalePrototypeCollation
code-creation,Builtin,2,16551,0x16b9400,12,LocalePrototypeCollations
code-creation,Builtin,2,16561,0x16b9440,12,LocalePrototypeHourCycle
code-creation,Builtin,2,16615,0x16b9480,12,LocalePrototypeHourCycles
code-creation,Builtin,2,16624,0x16b94c0,12,LocalePrototypeLanguage
code-creation,Builtin,2,16633,0x16b9500,12,LocalePrototypeMaximize
code-creation,Builtin,2,16642,0x16b9540,12,LocalePrototypeMinimize
code-creation,Builtin,2,16651,0x16b9580,12,LocalePrototypeNumeric
code-creation,Builtin,2,16661,0x16b95c0,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,16670,0x16b9600,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,16680,0x16b9640,12,LocalePrototypeRegion
code-creation,Builtin,2,16689,0x16b9680,12,LocalePrototypeScript
code-creation,Builtin,2,16698,0x16b96c0,12,LocalePrototypeTextInfo
code-creation,Builtin,2,16707,0x16b9700,12,LocalePrototypeTimeZones
code-creation,Builtin,2,16716,0x16b9740,12,LocalePrototypeToString
code-creation,Builtin,2,16726,0x16b9780,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,16735,0x16b97c0,12,NumberFormatConstructor
code-creation,Builtin,2,16744,0x16b9800,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,16754,0x16b9840,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,16763,0x16b9880,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,16773,0x16b98c0,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,16783,0x16b9900,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,16793,0x16b9940,12,PluralRulesConstructor
code-creation,Builtin,2,16802,0x16b9980,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,16812,0x16b99c0,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,16821,0x16b9a00,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,16830,0x16b9a40,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,16839,0x16b9a80,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,16849,0x16b9ac0,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,16859,0x16b9b00,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,16872,0x16b9b40,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,16888,0x16b9b80,12,SegmenterConstructor
code-creation,Builtin,2,16897,0x16b9bc0,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,16907,0x16b9c00,12,SegmenterPrototypeSegment
code-creation,Builtin,2,16916,0x16b9c40,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,16926,0x16b9c80,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,16935,0x16b9cc0,12,SegmentsPrototypeContaining
code-creation,Builtin,2,16944,0x16b9d00,12,SegmentsPrototypeIterator
code-creation,Builtin,2,16954,0x16b9d40,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,16963,0x16b9d80,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,16973,0x16b9dc0,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,16983,0x16b9e00,204,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,16992,0x16b9f00,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,17001,0x16b9f40,648,StringToLowerCaseIntl
code-creation,Builtin,2,17010,0x16ba200,12,V8BreakIteratorConstructor
code-creation,Builtin,2,17019,0x16ba240,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,17029,0x16ba280,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,17038,0x16ba2c0,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,17048,0x16ba300,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,17057,0x16ba340,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,17067,0x16ba380,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,17076,0x16ba3c0,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,17086,0x16ba400,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,17100,0x16ba440,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,17110,0x16ba480,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,17119,0x16ba4c0,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,17129,0x16ba500,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,17139,0x16ba540,24,Wide
code-creation,BytecodeHandler,0,17149,0x16ba580,24,ExtraWide
code-creation,BytecodeHandler,0,17162,0x16ba5c0,104,DebugBreakWide
code-creation,BytecodeHandler,0,17173,0x16ba640,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,17184,0x16ba6c0,164,DebugBreak0
code-creation,BytecodeHandler,0,17194,0x16ba780,104,DebugBreak1
code-creation,BytecodeHandler,0,17202,0x16ba800,104,DebugBreak2
code-creation,BytecodeHandler,0,17211,0x16ba880,104,DebugBreak3
code-creation,BytecodeHandler,0,17220,0x16ba900,104,DebugBreak4
code-creation,BytecodeHandler,0,17228,0x16ba980,104,DebugBreak5
code-creation,BytecodeHandler,0,17237,0x16baa00,104,DebugBreak6
code-creation,BytecodeHandler,0,17245,0x16baa80,32,Ldar
code-creation,BytecodeHandler,0,17253,0x16baac0,68,LdaZero
code-creation,BytecodeHandler,0,17261,0x16bab40,76,LdaSmi
code-creation,BytecodeHandler,0,17271,0x16babc0,72,LdaUndefined
code-creation,BytecodeHandler,0,17280,0x16bac40,72,LdaNull
code-creation,BytecodeHandler,0,17288,0x16bacc0,72,LdaTheHole
code-creation,BytecodeHandler,0,17296,0x16bad40,24,LdaTrue
code-creation,BytecodeHandler,0,17305,0x16bad80,24,LdaFalse
code-creation,BytecodeHandler,0,17315,0x16badc0,76,LdaConstant
code-creation,BytecodeHandler,0,17323,0x16bae40,132,LdaContextSlot
code-creation,BytecodeHandler,0,17331,0x16baf00,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,17340,0x16bafc0,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,17350,0x16bb040,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,17361,0x16bb0c0,32,Star
code-creation,BytecodeHandler,0,17370,0x16bb100,40,Mov
code-creation,BytecodeHandler,0,17378,0x16bb140,40,PushContext
code-creation,BytecodeHandler,0,17387,0x16bb180,36,PopContext
code-creation,BytecodeHandler,0,17400,0x16bb1c0,56,TestReferenceEqual
code-creation,BytecodeHandler,0,17415,0x16bb200,60,TestUndetectable
tick,0x7f0810c0f0af,17444,0,0x0,6
tick,0x7f0810c0f0af,17461,0,0x0,6
tick,0x7f0810c0f0af,17465,0,0x0,6
tick,0x129c370,17471,0,0x0,6
code-creation,BytecodeHandler,0,17476,0x16bb240,44,TestNull
code-creation,BytecodeHandler,0,17490,0x16bb280,44,TestUndefined
code-creation,BytecodeHandler,0,17499,0x16bb2c0,360,TestTypeOf
code-creation,BytecodeHandler,0,17509,0x16bb440,6092,LdaGlobal
code-creation,BytecodeHandler,0,17519,0x16bcc40,4596,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,17527,0x16bde40,160,StaGlobal
code-creation,BytecodeHandler,0,17532,0x16bdf00,156,StaContextSlot
code-creation,BytecodeHandler,0,17537,0x16bdfc0,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,17542,0x16be040,124,LdaLookupSlot
code-creation,BytecodeHandler,0,17547,0x16be0c0,244,LdaLookupContextSlot
code-creation,BytecodeHandler,0,17553,0x16be1c0,4840,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,17558,0x16bf4c0,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,17563,0x16bf540,244,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,17569,0x16bf640,4808,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,17575,0x16c0940,220,StaLookupSlot
code-creation,BytecodeHandler,0,17580,0x16c0a40,5292,LdaNamedProperty
code-creation,BytecodeHandler,0,17585,0x16c1f00,184,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,17591,0x16c1fc0,216,LdaKeyedProperty
code-creation,BytecodeHandler,0,17596,0x16c20c0,160,LdaModuleVariable
code-creation,BytecodeHandler,0,17601,0x16c2180,292,StaModuleVariable
code-creation,BytecodeHandler,0,17606,0x16c22c0,176,StaNamedProperty
code-creation,BytecodeHandler,0,17611,0x16c2380,176,StaNamedOwnProperty
code-creation,BytecodeHandler,0,17617,0x16c2440,168,StaKeyedProperty
code-creation,BytecodeHandler,0,17622,0x16c2500,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,17632,0x16c25c0,200,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,17637,0x16c26c0,164,CollectTypeProfile
code-creation,BytecodeHandler,0,17643,0x16c2780,1036,Add
code-creation,BytecodeHandler,0,17647,0x16c2bc0,1072,Sub
code-creation,BytecodeHandler,0,17652,0x16c3000,1032,Mul
code-creation,BytecodeHandler,0,17657,0x16c3440,992,Div
code-creation,BytecodeHandler,0,17661,0x16c3840,920,Mod
code-creation,BytecodeHandler,0,17666,0x16c3c00,984,Exp
code-creation,BytecodeHandler,0,17673,0x16c4000,884,BitwiseOr
code-creation,BytecodeHandler,0,17682,0x16c4380,892,BitwiseXor
code-creation,BytecodeHandler,0,17689,0x16c4700,892,BitwiseAnd
code-creation,BytecodeHandler,0,17697,0x16c4a80,904,ShiftLeft
code-creation,BytecodeHandler,0,17706,0x16c4e40,904,ShiftRight
code-creation,BytecodeHandler,0,17713,0x16c5200,1028,ShiftRightLogical
code-creation,BytecodeHandler,0,17720,0x16c5640,964,AddSmi
code-creation,BytecodeHandler,0,17729,0x16c5a40,1008,SubSmi
code-creation,BytecodeHandler,0,17736,0x16c5e40,920,MulSmi
code-creation,BytecodeHandler,0,17748,0x16c6200,928,DivSmi
code-creation,BytecodeHandler,0,17753,0x16c65c0,824,ModSmi
code-creation,BytecodeHandler,0,17758,0x16c6900,892,ExpSmi
code-creation,BytecodeHandler,0,17763,0x16c6c80,492,BitwiseOrSmi
code-creation,BytecodeHandler,0,17768,0x16c6e80,492,BitwiseXorSmi
code-creation,BytecodeHandler,0,17773,0x16c7080,492,BitwiseAndSmi
code-creation,BytecodeHandler,0,17778,0x16c7280,492,ShiftLeftSmi
code-creation,BytecodeHandler,0,17783,0x16c7480,492,ShiftRightSmi
code-creation,BytecodeHandler,0,17788,0x16c7680,644,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,17793,0x16c7940,664,Inc
code-creation,BytecodeHandler,0,17798,0x16c7c00,664,Dec
code-creation,BytecodeHandler,0,17803,0x16c7ec0,648,Negate
code-creation,BytecodeHandler,0,17808,0x16c8180,488,BitwiseNot
code-creation,BytecodeHandler,0,17813,0x16c8380,120,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,17818,0x16c8400,44,LogicalNot
code-creation,BytecodeHandler,0,17823,0x16c8440,208,TypeOf
code-creation,BytecodeHandler,0,17827,0x16c8540,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,17833,0x16c85c0,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,17838,0x16c8640,40,GetSuperConstructor
code-creation,BytecodeHandler,0,17844,0x16c8680,1120,CallAnyReceiver
code-creation,BytecodeHandler,0,17849,0x16c8b00,1120,CallProperty
code-creation,BytecodeHandler,0,17854,0x16c8f80,1004,CallProperty0
code-creation,BytecodeHandler,0,17859,0x16c9380,1020,CallProperty1
code-creation,BytecodeHandler,0,17864,0x16c9780,1032,CallProperty2
code-creation,BytecodeHandler,0,17869,0x16c9bc0,1004,CallUndefinedReceiver
code-creation,BytecodeHandler,0,17874,0x16c9fc0,1048,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,17879,0x16ca400,1020,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,17885,0x16ca800,1040,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,17890,0x16cac40,1120,CallWithSpread
code-creation,BytecodeHandler,0,17895,0x16cb0c0,124,CallRuntime
code-creation,BytecodeHandler,0,17900,0x16cb140,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,17905,0x16cb200,80,CallJSRuntime
code-creation,BytecodeHandler,0,17910,0x16cb280,1248,InvokeIntrinsic
code-creation,BytecodeHandler,0,17915,0x16cb780,1020,Construct
code-creation,BytecodeHandler,0,17920,0x16cbb80,544,ConstructWithSpread
code-creation,BytecodeHandler,0,17925,0x16cbdc0,1948,TestEqual
code-creation,BytecodeHandler,0,17930,0x16cc580,1076,TestEqualStrict
code-creation,BytecodeHandler,0,17935,0x16cc9c0,1636,TestLessThan
code-creation,BytecodeHandler,0,17949,0x16cd040,1636,TestGreaterThan
code-creation,BytecodeHandler,0,17956,0x16cd6c0,1636,TestLessThanOrEqual
code-creation,BytecodeHandler,0,17963,0x16cdd40,1636,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,17971,0x16ce3c0,884,TestInstanceOf
code-creation,BytecodeHandler,0,17977,0x16ce740,160,TestIn
code-creation,BytecodeHandler,0,17984,0x16ce800,112,ToName
code-creation,BytecodeHandler,0,17991,0x16ce880,220,ToNumber
code-creation,BytecodeHandler,0,17997,0x16ce980,240,ToNumeric
code-creation,BytecodeHandler,0,18008,0x16cea80,112,ToObject
code-creation,BytecodeHandler,0,18015,0x16ceb00,116,ToString
code-creation,BytecodeHandler,0,18022,0x16ceb80,404,CreateRegExpLiteral
code-creation,BytecodeHandler,0,18029,0x16ced40,1488,CreateArrayLiteral
code-creation,BytecodeHandler,0,18036,0x16cf340,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,18043,0x16cf3c0,796,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,18051,0x16cf700,2256,CreateObjectLiteral
code-creation,BytecodeHandler,0,18057,0x16d0000,228,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,18065,0x16d0100,172,CloneObject
code-creation,BytecodeHandler,0,18071,0x16d01c0,216,GetTemplateObject
code-creation,BytecodeHandler,0,18078,0x16d02c0,328,CreateClosure
code-creation,BytecodeHandler,0,18085,0x16d0440,120,CreateBlockContext
code-creation,BytecodeHandler,0,18092,0x16d04c0,132,CreateCatchContext
code-creation,BytecodeHandler,0,18099,0x16d0580,260,CreateFunctionContext
code-creation,BytecodeHandler,0,18106,0x16d06c0,260,CreateEvalContext
code-creation,BytecodeHandler,0,18113,0x16d0800,132,CreateWithContext
code-creation,BytecodeHandler,0,18119,0x16d08c0,1584,CreateMappedArguments
code-creation,BytecodeHandler,0,18126,0x16d0f00,596,CreateUnmappedArguments
code-creation,BytecodeHandler,0,18134,0x16d1180,636,CreateRestParameter
code-creation,BytecodeHandler,0,18141,0x16d1400,424,JumpLoop
code-creation,BytecodeHandler,0,18147,0x16d15c0,44,Jump
code-creation,BytecodeHandler,0,18153,0x16d1600,56,JumpConstant
code-creation,BytecodeHandler,0,18160,0x16d1640,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,18167,0x16d16c0,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,18174,0x16d1740,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,18181,0x16d17c0,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,18188,0x16d1840,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,18196,0x16d18c0,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,18202,0x16d1940,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,18209,0x16d19c0,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,18216,0x16d1a40,156,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,18224,0x16d1b00,156,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,18231,0x16d1bc0,144,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,18238,0x16d1c80,144,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,18245,0x16d1d40,68,JumpIfTrue
code-creation,BytecodeHandler,0,18251,0x16d1dc0,68,JumpIfFalse
code-creation,BytecodeHandler,0,18258,0x16d1e40,68,JumpIfNull
code-creation,BytecodeHandler,0,18265,0x16d1ec0,68,JumpIfNotNull
code-creation,BytecodeHandler,0,18271,0x16d1f40,68,JumpIfUndefined
code-creation,BytecodeHandler,0,18278,0x16d1fc0,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,18285,0x16d2040,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,18292,0x16d20c0,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,18299,0x16d2140,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,18314,0x16d21c0,468,ForInEnumerate
code-creation,BytecodeHandler,0,18328,0x16d23c0,264,ForInPrepare
tick,0x7f0810b97b10,18341,0,0x0,6
code-creation,BytecodeHandler,0,18390,0x16d2500,64,ForInContinue
code-creation,BytecodeHandler,0,18397,0x16d2580,264,ForInNext
code-creation,BytecodeHandler,0,18402,0x16d26c0,48,ForInStep
code-creation,BytecodeHandler,0,18407,0x16d2700,36,SetPendingMessage
code-creation,BytecodeHandler,0,18412,0x16d2740,116,Throw
code-creation,BytecodeHandler,0,18417,0x16d27c0,116,ReThrow
code-creation,BytecodeHandler,0,18422,0x16d2840,112,Return
code-creation,BytecodeHandler,0,18427,0x16d28c0,200,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,18432,0x16d29c0,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,18438,0x16d2a80,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,18444,0x16d2b40,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,18449,0x16d2c00,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,18455,0x16d2c80,500,SuspendGenerator
code-creation,BytecodeHandler,0,18463,0x16d2e80,128,ResumeGenerator
code-creation,BytecodeHandler,0,18468,0x16d2f40,156,GetIterator
code-creation,BytecodeHandler,0,18473,0x16d3000,116,Debugger
code-creation,BytecodeHandler,0,18478,0x16d3080,124,IncBlockCounter
code-creation,BytecodeHandler,0,18483,0x16d3100,56,Abort
code-creation,BytecodeHandler,0,18488,0x16d3140,32,Star0
code-creation,BytecodeHandler,0,18492,0x16d3180,60,Illegal
code-creation,BytecodeHandler,0,18498,0x16d31c0,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,18503,0x16d3240,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,18508,0x16d32c0,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,18513,0x16d3340,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,18519,0x16d33c0,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,18524,0x16d3440,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,18530,0x16d34c0,32,Ldar.Wide
code-creation,BytecodeHandler,0,18535,0x16d3500,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,18540,0x16d3540,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,18545,0x16d3580,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,18550,0x16d3600,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,18556,0x16d3680,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,18562,0x16d36c0,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,18568,0x16d3700,32,Star.Wide
code-creation,BytecodeHandler,0,18573,0x16d3740,40,Mov.Wide
code-creation,BytecodeHandler,0,18577,0x16d3780,40,PushContext.Wide
code-creation,BytecodeHandler,0,18583,0x16d37c0,36,PopContext.Wide
code-creation,BytecodeHandler,0,18588,0x16d3800,56,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,18593,0x16d3840,4724,LdaGlobal.Wide
code-creation,BytecodeHandler,0,18599,0x16d4ac0,4660,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,18604,0x16d5d00,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,18609,0x16d5dc0,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,18615,0x16d5e80,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,18620,0x16d5f00,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,18626,0x16d5fc0,248,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,18631,0x16d60c0,4912,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,18637,0x16d7400,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18643,0x16d74c0,248,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18649,0x16d75c0,4876,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18655,0x16d8900,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,18660,0x16d8a00,5296,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,18665,0x16d9ec0,192,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,18671,0x16d9fc0,164,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,18677,0x16da080,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,18682,0x16da140,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,18687,0x16da280,180,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,18693,0x16da340,180,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,18698,0x16da400,172,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,18704,0x16da4c0,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,18709,0x16da580,204,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,18715,0x16da680,168,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,18721,0x16da740,988,Add.Wide
code-creation,BytecodeHandler,0,18726,0x16dab40,1024,Sub.Wide
code-creation,BytecodeHandler,0,18731,0x16daf80,980,Mul.Wide
code-creation,BytecodeHandler,0,18736,0x16db380,996,Div.Wide
code-creation,BytecodeHandler,0,18741,0x16db780,924,Mod.Wide
code-creation,BytecodeHandler,0,18746,0x16dbb40,1008,Exp.Wide
code-creation,BytecodeHandler,0,18751,0x16dbf40,916,BitwiseOr.Wide
code-creation,BytecodeHandler,0,18756,0x16dc300,924,BitwiseXor.Wide
code-creation,BytecodeHandler,0,18761,0x16dc6c0,924,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,18766,0x16dca80,936,ShiftLeft.Wide
code-creation,BytecodeHandler,0,18774,0x16dce40,936,ShiftRight.Wide
code-creation,BytecodeHandler,0,18779,0x16dd200,1056,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,18784,0x16dd640,924,AddSmi.Wide
code-creation,BytecodeHandler,0,18789,0x16dda00,968,SubSmi.Wide
code-creation,BytecodeHandler,0,18794,0x16dde00,920,MulSmi.Wide
code-creation,BytecodeHandler,0,18799,0x16de1c0,924,DivSmi.Wide
code-creation,BytecodeHandler,0,18804,0x16de580,824,ModSmi.Wide
code-creation,BytecodeHandler,0,18809,0x16de8c0,892,ExpSmi.Wide
code-creation,BytecodeHandler,0,18814,0x16dec40,500,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,18820,0x16dee40,500,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,18825,0x16df040,500,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,18830,0x16df240,500,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,18835,0x16df440,500,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,18841,0x16df640,652,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,18846,0x16df900,624,Inc.Wide
code-creation,BytecodeHandler,0,18851,0x16dfb80,624,Dec.Wide
code-creation,BytecodeHandler,0,18856,0x16dfe00,652,Negate.Wide
code-creation,BytecodeHandler,0,18861,0x16e00c0,496,BitwiseNot.Wide
code-creation,BytecodeHandler,0,18866,0x16e02c0,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,18872,0x16e0340,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,18878,0x16e03c0,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,18883,0x16e0400,1120,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,18888,0x16e0880,1120,CallProperty.Wide
code-creation,BytecodeHandler,0,18894,0x16e0d00,1008,CallProperty0.Wide
code-creation,BytecodeHandler,0,18899,0x16e1100,1024,CallProperty1.Wide
code-creation,BytecodeHandler,0,18904,0x16e1540,1036,CallProperty2.Wide
code-creation,BytecodeHandler,0,18909,0x16e1980,1004,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,18915,0x16e1d80,1052,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,18921,0x16e21c0,1024,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,18927,0x16e2600,1044,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,18932,0x16e2a40,1120,CallWithSpread.Wide
code-creation,BytecodeHandler,0,18938,0x16e2ec0,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,18943,0x16e2f80,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,18948,0x16e3040,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,18953,0x16e30c0,1252,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,18959,0x16e35c0,968,Construct.Wide
code-creation,BytecodeHandler,0,18964,0x16e39c0,484,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,18969,0x16e3bc0,1976,TestEqual.Wide
code-creation,BytecodeHandler,0,18975,0x16e4380,1080,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,18980,0x16e47c0,1524,TestLessThan.Wide
code-creation,BytecodeHandler,0,18985,0x16e4dc0,1524,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,18991,0x16e53c0,1524,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,18996,0x16e59c0,1524,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,19002,0x16e5fc0,892,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,19015,0x16e6340,164,TestIn.Wide
code-creation,BytecodeHandler,0,19022,0x16e6400,116,ToName.Wide
code-creation,BytecodeHandler,0,19029,0x16e6480,224,ToNumber.Wide
code-creation,BytecodeHandler,0,19035,0x16e6580,240,ToNumeric.Wide
code-creation,BytecodeHandler,0,19042,0x16e6680,116,ToObject.Wide
code-creation,BytecodeHandler,0,19049,0x16e6700,408,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,19056,0x16e68c0,1400,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,19063,0x16e6e40,796,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,19071,0x16e7180,2168,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,19078,0x16e7a00,176,CloneObject.Wide
code-creation,BytecodeHandler,0,19085,0x16e7ac0,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,19092,0x16e7b80,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,19099,0x16e7d00,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,19106,0x16e7d80,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,19116,0x16e7e40,260,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,19123,0x16e7f80,260,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,19131,0x16e80c0,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,19138,0x16e8180,440,JumpLoop.Wide
code-creation,BytecodeHandler,0,19145,0x16e8340,44,Jump.Wide
code-creation,BytecodeHandler,0,19151,0x16e8380,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,19158,0x16e83c0,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,19165,0x16e8440,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,19172,0x16e84c0,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,19180,0x16e8540,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,19187,0x16e85c0,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,19195,0x16e8640,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,19202,0x16e86c0,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,19210,0x16e8740,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,19218,0x16e87c0,156,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,19225,0x16e8880,156,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,19233,0x16e8940,144,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,19240,0x16e8a00,144,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,19247,0x16e8ac0,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,19254,0x16e8b40,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,19261,0x16e8bc0,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,19268,0x16e8c40,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,19275,0x16e8cc0,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,19282,0x16e8d40,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,19289,0x16e8dc0,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,19296,0x16e8e40,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,19303,0x16e8ec0,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,19310,0x16e8f40,472,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,19317,0x16e9140,264,ForInPrepare.Wide
code-creation,BytecodeHandler,0,19324,0x16e9280,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,19331,0x16e9300,268,ForInNext.Wide
code-creation,BytecodeHandler,0,19338,0x16e9440,48,ForInStep.Wide
code-creation,BytecodeHandler,0,19345,0x16e9480,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,19352,0x16e9540,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,19360,0x16e9600,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,19367,0x16e9680,516,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,19374,0x16e98c0,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,19381,0x16e9980,160,GetIterator.Wide
code-creation,BytecodeHandler,0,19388,0x16e9a40,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,19395,0x16e9b00,56,Abort.Wide
code-creation,BytecodeHandler,0,19402,0x16e9b40,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,19409,0x16e9bc0,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,19416,0x16e9c40,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,19423,0x16e9cc0,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,19430,0x16e9d40,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,19437,0x16e9dc0,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,19444,0x16e9e40,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,19451,0x16e9e80,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,19458,0x16e9ec0,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,19465,0x16e9f00,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19472,0x16e9f80,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19480,0x16ea000,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19487,0x16ea040,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19495,0x16ea080,28,Star.ExtraWide
code-creation,BytecodeHandler,0,19505,0x16ea0c0,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,19512,0x16ea100,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,19519,0x16ea140,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,19526,0x16ea180,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,19533,0x16ea1c0,4712,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,19540,0x16eb440,4648,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,19548,0x16ec680,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,19555,0x16ec740,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19562,0x16ec800,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19570,0x16ec880,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,19577,0x16ec940,244,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19584,0x16eca40,4900,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,19592,0x16edd80,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,19599,0x16ede40,244,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,19607,0x16edf40,4864,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,19615,0x16ef280,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,19622,0x16ef380,5276,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,19630,0x16f0840,188,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,19637,0x16f0900,160,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,19644,0x16f09c0,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,19652,0x16f0a80,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,19659,0x16f0bc0,176,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,19666,0x16f0c80,176,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,19674,0x16f0d40,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,19681,0x16f0e00,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,19688,0x16f0ec0,200,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,19745,0x16f0fc0,168,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,19753,0x16f1080,988,Add.ExtraWide
code-creation,BytecodeHandler,0,19760,0x16f1480,1024,Sub.ExtraWide
code-creation,BytecodeHandler,0,19766,0x16f18c0,976,Mul.ExtraWide
code-creation,BytecodeHandler,0,19773,0x16f1cc0,992,Div.ExtraWide
code-creation,BytecodeHandler,0,19780,0x16f20c0,920,Mod.ExtraWide
code-creation,BytecodeHandler,0,19787,0x16f2480,1004,Exp.ExtraWide
code-creation,BytecodeHandler,0,19794,0x16f2880,912,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,19801,0x16f2c40,924,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,19808,0x16f3000,924,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,19815,0x16f33c0,936,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,19822,0x16f3780,936,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,19829,0x16f3b40,1056,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,19836,0x16f3f80,920,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,19843,0x16f4340,964,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,19850,0x16f4740,916,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,19857,0x16f4b00,924,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,19864,0x16f4ec0,820,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,19871,0x16f5200,892,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,19877,0x16f5580,500,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,19885,0x16f5780,500,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,19892,0x16f5980,500,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,19899,0x16f5b80,500,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,19906,0x16f5d80,500,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,19913,0x16f5f80,652,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,19921,0x16f6240,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,19927,0x16f64c0,620,Dec.ExtraWide
code-creation,BytecodeHandler,0,19934,0x16f6740,652,Negate.ExtraWide
code-creation,BytecodeHandler,0,19944,0x16f6a00,496,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,19951,0x16f6c00,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,19958,0x16f6c80,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,19966,0x16f6d00,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,19973,0x16f6d40,1116,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,19981,0x16f71c0,1116,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,19988,0x16f7640,1004,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,19995,0x16f7a40,1016,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,20002,0x16f7e40,1028,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,20009,0x16f8280,1000,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,20017,0x16f8680,1048,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,20024,0x16f8ac0,1020,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,20032,0x16f8ec0,1040,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,20040,0x16f9300,1116,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,20047,0x16f9780,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,20054,0x16f9840,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,20061,0x16f9900,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,20072,0x16f9980,1252,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,20079,0x16f9e80,964,Construct.ExtraWide
code-creation,BytecodeHandler,0,20086,0x16fa280,480,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,20094,0x16fa480,1976,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,20101,0x16fac40,1080,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,20108,0x16fb080,1520,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,20115,0x16fb680,1520,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,20122,0x16fbc80,1520,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,20130,0x16fc280,1520,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,20137,0x16fc880,888,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,20145,0x16fcc00,160,TestIn.ExtraWide
code-creation,BytecodeHandler,0,20151,0x16fccc0,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,20158,0x16fcd40,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,20165,0x16fce40,240,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,20172,0x16fcf40,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,20179,0x16fcfc0,408,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,20187,0x16fd180,1396,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,20194,0x16fd700,796,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,20202,0x16fda40,2168,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,20209,0x16fe2c0,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,20216,0x16fe380,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,20224,0x16fe440,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,20231,0x16fe5c0,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,20238,0x16fe640,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,20245,0x16fe700,256,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,20253,0x16fe840,256,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,20260,0x16fe980,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,20268,0x16fea40,436,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,20275,0x16fec00,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,20281,0x16fec40,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,20289,0x16fec80,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20296,0x16fed00,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20303,0x16fed80,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,20311,0x16fee00,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,20319,0x16fee80,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20329,0x16fef00,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,20337,0x16fef80,80,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,20344,0x16ff000,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,20352,0x16ff080,156,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,20359,0x16ff140,156,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,20367,0x16ff200,140,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,20374,0x16ff2c0,140,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,20382,0x16ff380,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,20389,0x16ff400,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,20396,0x16ff480,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,20403,0x16ff500,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,20410,0x16ff580,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,20417,0x16ff600,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,20437,0x16ff680,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,20445,0x16ff700,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,20452,0x16ff780,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,20460,0x16ff800,472,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,20467,0x16ffa00,264,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,20474,0x16ffb40,64,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,20481,0x16ffbc0,264,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,20489,0x16ffd00,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,20496,0x16ffd40,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,20503,0x16ffe00,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,20511,0x16ffec0,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,20518,0x16fff40,512,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,20526,0x1700180,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,20533,0x1700200,156,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,20540,0x17002c0,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,20547,0x1700340,56,Abort.ExtraWide
tick,0x7f0810fb2f10,20558,0,0x0,6
tick,0x7f0810c0f0af,20565,0,0x0,6
new,MemoryChunk,0x512dc00000,262144
new,MemoryChunk,0x36e7b7880000,262144
tick,0x1d5061e,21138,0,0x0,5
tick,0x1d5163f,22195,0,0x0,5
tick,0x126be97,23298,0,0x0,5
new,MemoryChunk,0x3966212c0000,262144
tick,0x126cd36,24394,0,0x0,5
new,MemoryChunk,0xdd574200000,262144
tick,0x1107a96,25490,0,0x0,5
new,MemoryChunk,0x109acf080000,262144
code-creation,Eval,10,26472,0x109acf085a46,5, node:internal/main/run_main_module:1:1,0x109acf085900,~
script-source,96,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x109acf085a46,96,0,632,C0O0C4O632,,
code-creation,Function,10,26528,0x109acf085aee,58, node:internal/main/run_main_module:1:1,0x109acf0859c0,~
code-source-info,0x109acf085aee,96,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
tick,0x7f0810fa53ec,26554,0,0x0,3
code-creation,LazyCompile,10,26849,0x109acf085d2e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x2842ea08fdb8,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x109acf085d2e,9,10316,10659,C0O10325C2O10336C4O10332C9O10352C13O10373C14O10393C19O10406C24O10410C29O10410C35O10551C37O10561C47O10609C60O10567C65O10561C66O10630C71O10630C75O10657,,
code-creation,LazyCompile,10,27472,0x109acf086a3e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x2842ea08fce8,~
code-source-info,0x109acf086a3e,9,9529,10090,C0O9547C6O9562C12O9591C16O9599C17O9627C22O9635C23O9648C30O9691C37O9722C45O9691C63O9821C70O9821C75O9856C89O9891C103O9848C108O9929C109O9941C124O9971C126O9984C141O10004C152O10023C160O10055C165O10004C170O10078C174O10086,,
tick,0xd4eca6,27657,1,0xb83830,2,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf085af1
code-creation,Eval,10,27933,0x109acf087a86,5, node:internal/bootstrap/pre_execution:1:1,0x109acf087690,~
script-source,97,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  emitExperimentalWarning\x2C\n} = require('internal/util');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false\x2C\n                                    initialzeModules = true) {\n  refreshRuntimeOptions();\n\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupFetch();\n  setupWebCrypto();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n\n  if (!initialzeModules) {\n    return;\n  }\n\n  initializeCJSLoader();\n  initializeESMLoader();\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction refreshRuntimeOptions() {\n  refreshOptions();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    // Only set it to true during snapshot building.\n    configurable: getOptionValue('--build-snapshot')\x2C\n    value: process.argv[0]\n  });\n\n  process.exitCode = undefined;\n  process._exiting = false;\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // We need to initialize the global console here again with process.stdout\n  // and friends for snapshot deserialization.\n  const globalConsole = require('internal/console/global');\n  const { initializeGlobalConsole } = require('internal/console/constructor');\n  initializeGlobalConsole(globalConsole);\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// https://fetch.spec.whatwg.org/\nfunction setupFetch() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-fetch')) {\n    return;\n  }\n\n  emitExperimentalWarning('Fetch');\n\n  const undici = require('internal/deps/undici/undici');\n  ObjectDefineProperty(globalThis\x2C 'fetch'\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: undici.fetch\n  });\n  ObjectDefineProperty(globalThis\x2C 'FormData'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.FormData\n  });\n  ObjectDefineProperty(globalThis\x2C 'Headers'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Headers\n  });\n  ObjectDefineProperty(globalThis\x2C 'Request'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Request\n  });\n  ObjectDefineProperty(globalThis\x2C 'Response'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Response\n  });\n}\n\n// TODO(aduh95): move this to internal/bootstrap/browser when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-webcrypto')) {\n    return;\n  }\n\n  let webcrypto;\n  ObjectDefineProperty(globalThis\x2C 'crypto'\x2C\n                       ObjectGetOwnPropertyDescriptor({\n                         get crypto() {\n                           webcrypto ??= require('internal/crypto/webcrypto');\n                           return webcrypto.crypto;\n                         }\n                       }\x2C 'crypto'));\n  if (internalBinding('config').hasOpenSSL) {\n    webcrypto ??= require('internal/crypto/webcrypto');\n    ObjectDefineProperty(globalThis\x2C 'Crypto'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.Crypto\n    });\n    ObjectDefineProperty(globalThis\x2C 'CryptoKey'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.CryptoKey\n    });\n    ObjectDefineProperty(globalThis\x2C 'SubtleCrypto'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.SubtleCrypto\n    });\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  refreshRuntimeOptions\x2C\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupFetch\x2C\n  setupWebCrypto\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x109acf087a86,97,0,18847,C0O0C4O18847,,
code-creation,Function,10,28947,0x109acf08871e,500, node:internal/bootstrap/pre_execution:1:1,0x109acf087a00,~
code-source-info,0x109acf08871e,97,0,18847,C0O0C217O25C223O43C229O67C235O101C241O112C247O127C253O156C259O256C265O256C270O196C276O214C282O236C288O321C294O321C299O293C305O388C311O388C316O359C322O434C328O434C333O423C339O495C345O495C350O521C355O461C361O544C367O544C371O544C373O18393C380O18414C386O18439C392O18461C398O18483C404O18506C410O18520C416O18538C422O18555C428O18573C434O18603C440O18629C446O18652C452O18682C458O18714C464O18736C470O18763C476O18786C482O18806C488O18829C494O18408C499O18846,,
tick,0x7f0810b84410,28982,1,0xb83830,3,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf085af1
code-creation,LazyCompile,10,29209,0x109acf08a186,247,prepareMainThreadExecution node:internal/bootstrap/pre_execution:27:36,0x109acf087ab8,~
code-source-info,0x109acf08a186,97,608,2666,C20O695C23O695C26O840C31O840C34O942C37O942C41O977C44O977C47O1006C50O1006C53O1026C56O1026C59O1051C62O1051C65O1076C68O1076C71O1092C74O1092C77O1290C80O1302C85O1306C91O1330C94O1338C105O1394C110O1398C115O1367C119O1359C123O1425C126O1425C129O1517C132O1517C135O1623C138O1623C141O1645C144O1645C147O1704C150O1704C153O2027C156O2027C159O2102C162O2102C165O2299C168O2299C171O2326C174O2326C177O2360C180O2360C183O2388C186O2388C189O2409C193O2438C194O2445C195O2453C198O2453C201O2478C204O2478C207O2521C213O2521C218O2563C223O2581C229O2563C233O2611C236O2611C239O2635C242O2635C246O2665,,
code-creation,LazyCompile,10,29255,0x109acf08b726,10,refreshRuntimeOptions node:internal/bootstrap/pre_execution:95:31,0x109acf087b08,~
code-source-info,0x109acf08b726,97,2698,2724,C0O2705C5O2705C9O2723,,
code-creation,LazyCompile,10,29285,0x109acf08b80e,22,refreshOptions node:internal/options:39:24,0x2989f3599880,~
script-source,92,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction refreshOptions() {\n  optionsMap = undefined;\n  aliasesMap = undefined;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\n};\n
code-source-info,0x109acf08b80e,92,902,960,C0O909C4O920C10O935C14O946C21O959,,
code-creation,LazyCompile,10,29467,0x109acf08bb76,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x136fed73f160,~
script-source,25,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x109acf08bb76,25,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x129c370,31127,0,0x0,3,0x1229670,0x109acf08a1a5,0x109acf085afd
tick,0x7f0810fb36ac,31139,0,0x0,3,0x1229670,0x109acf08a1a5,0x109acf085afd
code-creation,LazyCompile,10,31200,0x109acf08e466,460,patchProcessObject node:internal/bootstrap/pre_execution:99:28,0x109acf087b58,~
code-source-info,0x109acf08e466,97,2753,4815,C0O2787C6O2787C11O2833C19O2833C24O2865C30O2865C35O2903C40O2904C44O2930C55O2951C62O3064C68O3064C79O3119C85O3123C92O2930C97O3136C101O3153C105O3168C109O3185C113O3196C116O3204C126O3222C130O3212C134O3235C141O3262C148O3266C155O3280C161O3314C168O3318C175O3280C182O3396C188O3396C196O3429C199O3437C207O3452C215O3468C222O3472C226O3452C231O3445C241O3690C247O3690C252O3764C258O3764C263O3736C268O3807C272O3990C281O3990C286O4036C295O4036C300O4089C309O4089C314O4149C323O4149C328O4207C337O4207C342O4267C351O4267C356O4331C365O4331C370O4396C379O4396C384O4467C393O4467C398O4537C407O4537C412O4597C421O4597C426O4667C437O4667C442O4737C453O4737C459O4814,,
code-creation,LazyCompile,10,31263,0x109acf08e7f6,69,internalBinding node:internal/bootstrap/loaders:164:45,0x2842ea08f838,~
code-source-info,0x109acf08e7f6,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
code-creation,LazyCompile,10,31353,0x109acf08ea9e,69,refreshHrtimeBuffer node:internal/process/per_thread:66:29,0x273b9798d270,~
script-source,30,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    process.off('exit'\x2C handleProcessExit);\n\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0x109acf08ea9e,30,1412,1852,C0O1599C7O1626C10O1634C17O1610C25O1608C31O1786C38O1822C41O1830C53O1803C61O1801C68O1851,,
tick,0x7f0810c0f0af,31988,0,0x0,3,0x1229670,0x109acf08e48e,0x109acf08a1ab,0x109acf085afd
code-creation,LazyCompile,10,32019,0x109acf08fa1e,82,getOptionValue node:internal/options:44:24,0x2989f35998f0,~
code-source-info,0x109acf08fa1e,92,985,1228,C0O1018C3O1018C7O1063C15O1063C22O1113C30O1135C38O1135C43O1122C47O1113C53O1150C55O1175C60O1181C61O1203C66O1203C74O1218C81O1226,,
code-creation,LazyCompile,10,32055,0x109acf08fb76,33,getCLIOptionsFromBinding node:internal/options:18:34,0x2989f3599588,~
code-source-info,0x109acf08fb76,92,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
code-creation,LazyCompile,10,32545,0x109acf08fd36,175,resolve node:path:1091:10,0x273b979baca8,~
script-source,41,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x109acf08fd36,41,33781,34691,C0O33781C3O33816C6O33847C8O33877C12O33884C16O33897C18O33891C25O33901C27O33945C28O33947C35O33958C42O33964C45O33964C49O33983C57O33983C62O34057C68O34064C73O34081C75O34106C87O34132C92O34154C99O34181C107O34220C109O34216C113O33920C118O33859C121O34436C126O34482C137O34451C143O34568C147O34598C152O34609C156O34624C157O34655C163O34662C174O34687,,
tick,0x7f0810fb3696,34881,0,0x0,3,0x1229670,0x109acf08e548,0x109acf08a1ab,0x109acf085afd
tick,0x7f0810b843fc,34893,0,0x0,3,0x1229670,0x109acf08e548,0x109acf08a1ab,0x109acf085afd
code-creation,LazyCompile,10,34898,0x109acf092f6e,30,validateString node:internal/validators:118:24,0x2842ea0bc068,~
script-source,15,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!isInt32(value)) {\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n  }\n  if (!isUint32(value)) {\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const useDefaultOptions = options == null;\n    const allowArray = useDefaultOptions ? false : options.allowArray;\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\n    const nullable = useDefaultOptions ? false : options.nullable;\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0x109acf092f6e,15,3405,3514,C0O3423C6O3458C22O3464C27O3458C29O3513,,
code-creation,LazyCompile,10,35380,0x109acf093906,13, node:path:1082:10,0x273b979bac58,~
code-source-info,0x109acf093906,41,33630,33649,C0O33644C3O33644C8O33644C12O33649,,
tick,0x129c37f,35401,0,0x0,3,0x1229670,0x109acf08fd6f,0x109acf08e548,0x109acf08a1ab,0x109acf085afd
code-creation,LazyCompile,10,35422,0x109acf093a06,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x2989f359dd40,~
script-source,95,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x109acf093a06,95,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
code-creation,LazyCompile,10,35721,0x109acf09406e,442,normalizeString node:path:66:25,0x273b979ba7c0,~
code-source-info,0x109acf09406e,41,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,35780,0x109acf0943ee,8,isPosixPathSeparator node:path:56:30,0x273b979ba720,~
code-source-info,0x109acf0943ee,41,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,35894,0x109acf094626,37,initializeGlobalConsole node:internal/console/constructor:672:33,0x273b9799e610,~
script-source,37,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\n\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (!new.target) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      value: key\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  value(instance) {\n    return instance[kIsConsole];\n  }\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { ...consolePropAttributes\x2C value: stderr }\n      });\n    }\n  }\x2C\n  [kBindStreamsLazy]: {\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\n        }\x2C\n        '_stderr': {\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\n        }\n      });\n    }\n  }\x2C\n  [kBindProperties]: {\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\n        }\x2C\n        '_ignoreErrors': {\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\n        }\x2C\n        '_times': { ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          ...consolePropAttributes\x2C\n          value: groupIndentation\n        }\x2C\n        [SymbolToStringTag]: {\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\n        }\n      });\n    }\n  }\x2C\n  [kWriteToConsole]: {\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = StringPrototypeReplace(string\x2C /\\n/g\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\n  }\x2C\n  [kGetInspectOptions]: {\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = stream.isTTY && (\n          typeof stream.getColorDepth === 'function' ?\n            stream.getColorDepth() > 2 : true);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\n  }\x2C\n  [kFormatForStdout]: {\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n  [kFormatForStderr]: {\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    if (cliTable === undefined) cliTable = require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = ObjectCreate(null);\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          if (map[key] === undefined)\n            map[key] = [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true\x2C 'auto');\n}\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  initializeGlobalConsole\x2C\n  formatTime // exported for tests\n};\n
code-source-info,0x109acf094626,37,19939,20050,C0O19959C2O19973C4O19972C11O19990C16O20003C18O20017C20O20016C29O20033C36O20049,,
tick,0x129c370,36973,0,0x0,3,0x1229670,0x109acf08e572,0x109acf08a1ab,0x109acf085afd
code-creation,LazyCompile,10,36991,0x109acf095f8e,94,value node:internal/console/constructor:196:20,0x273b9799db90,~
code-source-info,0x109acf095f8e,37,5584,6164,C0O5584C15O5605C16O5605C18O5623C19O5623C21O5637C33O5687C38O5758C46O5865C60O5926C65O5997C73O6108C87O5637C93O6163,,
code-creation,LazyCompile,10,37102,0x109acf0965d6,362,value node:internal/console/constructor:223:20,0x273b9799dc18,~
code-source-info,0x109acf0965d6,37,6242,7416,C17O6298C29O6375C45O6445C48O6415C66O6514C82O6584C85O6554C103O6647C116O6687C119O6687C136O6743C149O6777C152O6773C170O6868C176O6883C189O6917C192O6913C211O6939C217O6957C230O6987C244O7009C250O7027C262O7057C276O7074C282O7094C295O7124C309O7139C315O7179C328O7219C342O7256C346O7276C355O6298C361O7415,,
code-creation,LazyCompile,10,37172,0x109acf0969ee,18,createWriteErrorHandler node:internal/console/constructor:338:33,0x273b9799dec0,~
code-source-info,0x109acf0969ee,37,10118,10975,C0O10118C13O10147C17O10973,,
code-creation,LazyCompile,10,37243,0x109acf096aee,27,SafeMap node:internal/per_context/primordials:360:16,0x2842ea089f10,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x109acf096aee,6,10335,10352,C3O10341C7O10347C11O10341C26O10351,,
tick,0x129c370,37948,0,0x0,3,0x1229670,0x109acf09666e,0x109acf094643,0x109acf08e572,0x109acf08a1ab,0x109acf085afd
code-creation,LazyCompile,10,37970,0x109acf0979fe,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:150:33,0x109acf087ba8,~
code-source-info,0x109acf0979fe,97,4849,5074,C16O4901C21O4901C26O4927C28O4944C36O4974C43O5037C49O5055C56O4944C62O5073,,
code-creation,LazyCompile,10,38037,0x109acf097ba6,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:323:33,0x109acf087f18,~
code-source-info,0x109acf097ba6,97,9557,9784,C0O9599C6O9599C11O9572C16O9671C22O9671C27O9642C32O9713C35O9738C40O9713C45O9783,,
code-creation,LazyCompile,10,38087,0x109acf097d3e,77,toggleTraceCategoryState node:internal/process/per_thread:390:34,0x273b9798d990,~
code-source-info,0x109acf097d3e,30,11159,11456,C0O11183C4O11212C10O11247C16O11278C21O11322C26O11323C33O11268C39O11347C44O11368C49O11368C55O11387C61O11419C66O11440C71O11440C76O11455,,
code-creation,LazyCompile,10,38119,0x109acf097eee,42,setupPerfHooks node:internal/bootstrap/pre_execution:329:24,0x109acf087f68,~
code-source-info,0x109acf097eee,97,9809,9929,C0O9816C6O9816C11O9852C16O9853C20O9876C26O9876C31O9906C36O9907C41O9928,,
code-creation,LazyCompile,10,38165,0x109acf09806e,42,refreshTimeOrigin node:internal/perf/performance:181:27,0x2b4a88f96320,~
script-source,74,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('name');\n  }\n  name = `${name}`;\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('type');\n  }\n  type = `${type}`;\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x109acf09806e,74,3860,4017,C0O3867C7O3888C10O3900C25O3984C28O3984C35O3867C41O4016,,
tick,0x7f0810b9064e,38455,0,0x0,3,0x1229670,0x109acf097efe,0x109acf08a1b8,0x109acf085afd
code-creation,LazyCompile,10,38471,0x109acf098796,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x39a167d90b28,~
script-source,46,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x109acf098796,46,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,38556,0x109acf098a06,62,setupInspectorHooks node:internal/bootstrap/pre_execution:334:29,0x109acf087fb8,~
code-source-info,0x109acf098a06,97,9959,10512,C0O10302C6O10306C11O10331C17O10396C23O10396C28O10366C33O10380C38O10442C44O10442C49O10470C54O10471C61O10511,,
code-creation,Eval,10,38685,0x109acf098db6,5, node:internal/inspector_async_hook:1:1,0x109acf098c00,~
script-source,98,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x109acf098db6,98,0,1972,C0O0C4O1972,,
code-creation,Function,10,38803,0x109acf098fd6,79, node:internal/inspector_async_hook:1:1,0x109acf098d30,~
code-source-info,0x109acf098fd6,98,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
code-creation,LazyCompile,10,38907,0x109acf09956e,69,setupWarningHandler node:internal/bootstrap/pre_execution:162:29,0x109acf087bf8,~
code-source-info,0x109acf09956e,97,5104,5301,C0O5139C6O5139C11O5123C16O5178C24O5182C33O5226C38O5230C45O5247C50O5262C53O5270C61O5270C68O5300,,
code-creation,LazyCompile,10,39030,0x109acf0997e6,20,addListener node:events:618:58,0x136fed726c28,~
script-source,23,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\nconst { inspect } = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number\x2C\n       *   requireManualDestroy?: boolean\x2C\n       * }} [options]\n       */\n      constructor(ee\x2C type\x2C options) {\n        super(type\x2C options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string\x2C\n         *   triggerAsyncId?: number\x2C\n         *   requireManualDestroy?: boolean\x2C\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name\x2C 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\n        }\n\n        /**\n         * @param {symbol\x2Cstring} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event\x2C ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\n  enumerable: true\x2C\n  get: lazyEventEmitterAsyncResource\x2C\n  set: undefined\x2C\n  configurable: true\x2C\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition\x2C please also update any\n// re-definitions\x2C such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target\x2C { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`\x2C\n        { name: 'MaxListenersExceededWarning'\x2C emitter: target\x2C type: type\x2C count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x109acf0997e6,23,18237,18309,C0O18258C14O18265C19O18307,,
tick,0x7f0810b9064f,40727,0,0x0,3,0x1229670,0x109acf0995ab,0x109acf08a1c4,0x109acf085afd
tick,0x7f0810b84300,40739,0,0x0,3,0x1229670,0x109acf0995ab,0x109acf08a1c4,0x109acf085afd
code-creation,LazyCompile,10,40792,0x109acf09beae,378,_addListener node:events:555:22,0x136fed726b88,~
code-source-info,0x109acf09beae,23,16167,18039,C0O16209C2O16218C4O16232C6O16245C9O16245C13O16289C18O16300C20O16332C22O16358C27O16358C32O16356C39O16382C40O16402C46O16568C52O16610C60O16663C77O16610C82O16842C87O16861C89O16878C93O16893C97O17004C99O17017C103O17033C109O17042C115O17071C121O17176C129O17210C140O17221C149O17231C166O17244C175O17254C182O17200C193O17329C197O17359C202O17359C209O17406C214O17406C219O17464C222O17468C227O17498C228O17504C233O17520C240O17527C245O17544C251O17560C252O17576C256O17654C264O17736C281O17746C284O17746C304O17794C307O17802C312O17794C327O17772C338O17933C344O17947C348O17969C356O17654C362O17986C365O17994C370O17994C375O18023C377O18037,,
code-creation,LazyCompile,10,40838,0x109acf09c1be,15,checkListener node:events:258:23,0x136fed7264e8,~
code-source-info,0x109acf09c1be,23,7627,7683,C0O7642C8O7642C14O7682,,
code-creation,LazyCompile,10,40866,0x109acf09c2ae,30, node:internal/validators:236:42,0x2842ea0bc500,~
code-source-info,0x109acf09c2ae,15,7214,7330,C0O7235C6O7272C22O7278C27O7272C29O7329,,
code-creation,LazyCompile,10,40982,0x109acf09c52e,380,emit node:events:475:44,0x136fed726ac8,~
code-source-info,0x109acf09c52e,23,13881,16143,C0O13881C8O13915C10O13921C14O13958C19O13969C21O14001C27O14023C29O14022C34O14064C41O14069C51O14064C56O14098C60O14127C68O14158C72O14176C73O14189C74O14248C78O14271C80O14288C86O14295C91O14306C92O14315C96O14324C98O14342C100O14331C108O14387C110O14399C120O14444C126O14454C132O14399C137O14469C145O14494C157O14543C174O14543C186O14469C197O14865C199O14865C200O14917C205O14948C211O14964C219O14962C220O14997C225O15094C232O15094C238O15138C240O15150C244O15160C246O15160C247O15221C249O15227C253O15238C255O15269C256O15282C257O15286C263O15350C268O15350C275O15504C281O15557C296O15557C303O15634C308O15664C311O15664C316O15702C318O15707C320O15707C325O15742C327O15751C332O15755C337O15755C344O16017C350O16072C365O16072C370O15716C375O15689C378O16129C379O16141,,
code-creation,LazyCompile,10,41070,0x109acf09c8ce,172,startListeningIfSignal node:internal/process/signal:22:32,0x2989f359c7f0,~
script-source,94,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x109acf09c8ce,94,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,41169,0x109acf09cc8e,19,isSignal node:internal/process/signal:17:18,0x2989f359c638,~
code-source-info,0x109acf09cc8e,94,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,41234,0x109acf09d0be,215,setupFetch node:internal/bootstrap/pre_execution:173:20,0x109acf087c48,~
code-source-info,0x109acf09d0be,97,5356,6314,C0O5363C3O5375C8O5382C13O5392C21O5426C27O5426C33O5472C34O5479C35O5487C43O5487C47O5539C53O5539C58O5581C65O5602C76O5709C84O5581C89O5723C96O5744C107O5855C115O5723C120O5872C127O5893C138O6003C146O5872C151O6019C158O6040C169O6150C177O6019C182O6166C189O6187C200O6298C208O6166C214O6313,,
code-creation,LazyCompile,10,41302,0x109acf09d2d6,5,get node:internal/bootstrap/node:135:6,0x2842ea094ab0,~
script-source,10,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `node::RunBootstrapping()` in `src/node.cc`\x2C and is\n// responsible for setting up node.js core before executing main scripts\n// under `lib/internal/main/`.\n//\n// This file is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/bootstrap/pre_execution.js` or in main scripts. The majority\n// of the code here focuses on setting up the global proxy and the process\n// object in a synchronous manner.\n// As special caution is given to the performance of the startup process\x2C\n// many dependencies are invoked lazily.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: to save copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/bootstrap/loaders.js`: to setup internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `NativeModule`.\n//\n// This file is run to bootstrap both the main thread and the worker threads.\n// After this file is run\x2C certain properties are setup according to the\n// configuration of the Node.js instance using the files in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/bootstrap/pre_execution.js` depending on the runtime states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nsetupPrepareStackTrace();\n\nconst {\n  Array\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFill\x2C\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPreventExtensions\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  ReflectSet\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst { deprecate\x2C lazyDOMExceptionClass } = require('internal/util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\nprocess._exiting = false;\n\n// process.config is serialized config.gypi\nconst nativeModule = internalBinding('native_module');\n\n// TODO(@jasnell): Once this has gone through one full major\n// release cycle\x2C remove the Proxy and setter and update the\n// getter to either return a read-only object or always return\n// a freshly parsed version of nativeModule.config.\n\nconst deprecationHandler = {\n  warned: false\x2C\n  message: 'Setting process.config is deprecated. ' +\n           'In the future the property will be read-only.'\x2C\n  code: 'DEP0150'\x2C\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message\x2C {\n        type: 'DeprecationWarning'\x2C\n        code: this.code\n      });\n      this.warned = true;\n    }\n  }\x2C\n\n  defineProperty(target\x2C key\x2C descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target\x2C key\x2C descriptor);\n  }\x2C\n\n  deleteProperty(target\x2C key) {\n    this.maybeWarn();\n    delete target[key];\n  }\x2C\n\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  }\x2C\n\n  set(target\x2C key\x2C value) {\n    this.maybeWarn();\n    return ReflectSet(target\x2C key\x2C value);\n  }\x2C\n\n  get(target\x2C key\x2C receiver) {\n    const val = ReflectGet(target\x2C key\x2C receiver);\n    if (val != null && typeof val === 'object') {\n      // eslint-disable-next-line node-core/prefer-primordials\n      return new Proxy(val\x2C deprecationHandler);\n    }\n    return val;\n  }\x2C\n\n  setPrototypeOf(target\x2C proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target\x2C proto);\n  }\n};\n\n// eslint-disable-next-line node-core/prefer-primordials\nlet processConfig = new Proxy(\n  JSONParse(nativeModule.config)\x2C\n  deprecationHandler);\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  enumerable: true\x2C\n  configurable: true\x2C\n  get() { return processConfig; }\x2C\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n\n  process.getActiveResourcesInfo = function() {\n    const timerCounts = internalTimers.getTimerCounts();\n    return ArrayPrototypeConcat(\n      rawMethods._getActiveRequestsInfo()\x2C\n      rawMethods._getActiveHandlesInfo()\x2C\n      ArrayPrototypeFill(new Array(timerCounts.timeoutCount)\x2C 'Timeout')\x2C\n      ArrayPrototypeFill(new Array(timerCounts.immediateCount)\x2C 'Immediate'));\n  };\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n  queueMicrotask\n} = require('internal/process/task_queues');\n\nif (!config.noBrowserGlobals) {\n  // Override global console from the one provided by the VM\n  // to the one implemented by Node.js\n  // https://console.spec.whatwg.org/#console-namespace\n  exposeNamespace(globalThis\x2C 'console'\x2C\n                  createGlobalConsole(globalThis.console));\n\n  const { URL\x2C URLSearchParams } = require('internal/url');\n  // https://url.spec.whatwg.org/#url\n  exposeInterface(globalThis\x2C 'URL'\x2C URL);\n  // https://url.spec.whatwg.org/#urlsearchparams\n  exposeInterface(globalThis\x2C 'URLSearchParams'\x2C URLSearchParams);\n  exposeGetterAndSetter(globalThis\x2C\n                        'DOMException'\x2C\n                        lazyDOMExceptionClass\x2C\n                        (value) => {\n                          exposeInterface(globalThis\x2C 'DOMException'\x2C value);\n                        });\n\n  const {\n    TextEncoder\x2C TextDecoder\n  } = require('internal/encoding');\n  // https://encoding.spec.whatwg.org/#textencoder\n  exposeInterface(globalThis\x2C 'TextEncoder'\x2C TextEncoder);\n  // https://encoding.spec.whatwg.org/#textdecoder\n  exposeInterface(globalThis\x2C 'TextDecoder'\x2C TextDecoder);\n\n  const {\n    AbortController\x2C\n    AbortSignal\x2C\n  } = require('internal/abort_controller');\n  exposeInterface(globalThis\x2C 'AbortController'\x2C AbortController);\n  exposeInterface(globalThis\x2C 'AbortSignal'\x2C AbortSignal);\n\n  const {\n    EventTarget\x2C\n    Event\x2C\n  } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'EventTarget'\x2C EventTarget);\n  exposeInterface(globalThis\x2C 'Event'\x2C Event);\n  const {\n    MessageChannel\x2C\n    MessagePort\x2C\n    MessageEvent\x2C\n  } = require('internal/worker/io');\n  exposeInterface(globalThis\x2C 'MessageChannel'\x2C MessageChannel);\n  exposeInterface(globalThis\x2C 'MessagePort'\x2C MessagePort);\n  exposeInterface(globalThis\x2C 'MessageEvent'\x2C MessageEvent);\n\n  // https://html.spec.whatwg.org/multipage/webappapis.html#windoworworkerglobalscope\n  const timers = require('timers');\n  defineOperation(globalThis\x2C 'clearInterval'\x2C timers.clearInterval);\n  defineOperation(globalThis\x2C 'clearTimeout'\x2C timers.clearTimeout);\n  defineOperation(globalThis\x2C 'setInterval'\x2C timers.setInterval);\n  defineOperation(globalThis\x2C 'setTimeout'\x2C timers.setTimeout);\n\n  defineOperation(globalThis\x2C 'queueMicrotask'\x2C queueMicrotask);\n\n  // https://www.w3.org/TR/hr-time-2/#the-performance-attribute\n  defineReplacableAttribute(globalThis\x2C 'performance'\x2C\n                            require('perf_hooks').performance);\n\n  // Non-standard extensions:\n  defineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\n  defineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\n  const {\n    structuredClone\x2C\n  } = require('internal/structured_clone');\n  defineOperation(globalThis\x2C 'structuredClone'\x2C structuredClone);\n}\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because snapshot is built without code cache.\n  // TODO(joyeecheung): https://github.com/nodejs/node/issues/31074\n  // Make it possible to build snapshot with code cache\n  get cached_builtins() {\n    return nativeModule.hasCachedBuiltins();\n  }\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n// Preload modules so that they are included in the builtin snapshot.\nrequire('fs');\nrequire('v8');\nrequire('vm');\nrequire('url');\nrequire('internal/options');\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\n    }\n  } = require('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\n  });\n  // Make process globally available to users by putting it on the global proxy\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    value: process\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n    atob\x2C\n    btoa\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  ObjectDefineProperties(globalThis\x2C {\n    'Buffer': {\n      value: Buffer\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n    'atob': {\n      value: atob\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n    'btoa': {\n      value: btoa\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n  });\n}\n\nfunction createGlobalConsole(consoleFromVM) {\n  const consoleFromNode =\n    require('internal/console/global');\n  if (config.hasInspector) {\n    const inspector = require('internal/util/inspector');\n    // This will be exposed by `require('inspector').console` later.\n    inspector.consoleFromVM = consoleFromVM;\n    // TODO(joyeecheung): postpone this until the first time inspector\n    // is activated.\n    inspector.wrapConsole(consoleFromNode\x2C consoleFromVM);\n    const { setConsoleExtensionInstaller } = internalBinding('inspector');\n    // Setup inspector command line API.\n    setConsoleExtensionInstaller(inspector.installConsoleExtensions);\n  }\n  return consoleFromNode;\n}\n\n// https://heycam.github.io/webidl/#es-namespaces\nfunction exposeNamespace(target\x2C name\x2C namespaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: namespaceObject\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\n  });\n}\n\nfunction exposeGetterAndSetter(target\x2C name\x2C getter\x2C setter = undefined) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get: getter\x2C\n    set: setter\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\n  });\n}\n\n// https://heycam.github.io/webidl/#Replaceable\nfunction defineReplacableAttribute(target\x2C name\x2C value) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value\x2C\n  });\n}\n
code-source-info,0x109acf09d2d6,10,4156,4184,C0O4161C4O4182,,
tick,0x7f0810c0f0af,42228,0,0x0,3,0x1229670,0x109acf09d0c1,0x109acf08a1ca,0x109acf085afd
code-creation,LazyCompile,10,42244,0x109acf09e4e6,52,get node:internal/bootstrap/node:112:6,0x2842ea094a10,~
code-source-info,0x109acf09e4e6,10,3542,3806,C0O3584C14O3584C20O3623C29O3738C35O3760C43O3745C48O3780C49O3791C51O3802,,
code-creation,LazyCompile,10,42331,0x109acf09e966,268,setupWebCrypto node:internal/bootstrap/pre_execution:216:24,0x109acf087c98,~
code-source-info,0x109acf09e966,97,6443,7542,C0O6443C8O6450C13O6462C18O6469C23O6479C33O6513C39O6513C45O6570C46O6577C47O6589C48O6589C50O6602C61O6623C71O6668C102O6668C108O6602C113O6939C121O6943C126O6968C132O6987C146O7001C150O6997C152O7043C163O7064C177O7184C185O7043C190O7203C201O7224C215O7347C223O7203C228O7369C239O7390C253O7516C261O7369C267O7541,,
code-creation,LazyCompile,10,42387,0x109acf09ec96,75,setupDebugEnv node:internal/bootstrap/pre_execution:295:23,0x109acf087e28,~
code-source-info,0x109acf09ec96,97,8807,9017,C0O8814C6O8814C11O8847C19O8875C24O8879C29O8848C34O8894C42O8898C48O8942C54O8942C59O8979C64O8992C69O8993C74O9016,,
code-creation,LazyCompile,10,42474,0x109acf09f02e,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x136fed71cfa0,~
script-source,22,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x109acf09f02e,22,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,42714,0x109acf09f636,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:274:40,0x109acf087d60,~
code-source-info,0x109acf09f636,97,8372,8558,C0O8379C8O8384C14O8424C15O8431C16O8465C22O8465C27O8446C32O8515C38O8548C43O8548C48O8557,,
code-creation,LazyCompile,10,42757,0x109acf09f84e,62,initializeReport node:internal/bootstrap/pre_execution:284:26,0x109acf087db0,~
code-source-info,0x109acf09f84e,97,8585,8783,C0O8585C8O8611C16O8611C21O8600C27O8649C42O8670C47O8741C55O8649C61O8782,,
tick,0x7f0810b84348,42781,0,0x0,3,0x1229670,0x109acf09ecb3,0x109acf08a204,0x109acf085afd
code-creation,Eval,10,42920,0x109acf09fdbe,5, node:internal/process/report:1:1,0x109acf09fbc8,~
script-source,99,node:internal/process/report,'use strict';\nconst {\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined) {\n      validateString(file\x2C 'file');\n    }\n\n    if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x109acf09fdbe,99,0,2545,C0O0C4O2545,,
code-creation,Function,10,43074,0x109acf0a08ce,306, node:internal/process/report:1:1,0x109acf09fd38,~
code-source-info,0x109acf0a08ce,99,0,2545,C0O0C48O42C51O42C56O68C61O24C67O165C70O165C75O86C81O105C87O123C93O145C99O208C102O208C106O208C108O245C114O288C119O292C127O678C281O2494C288O2515C294O2535C300O2509C305O2544,,
code-creation,LazyCompile,10,43264,0x109acf0a2786,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:303:40,0x109acf087e78,~
code-source-info,0x109acf0a2786,97,9118,9214,C0O9154C6O9154C11O9133C16O9193C20O9213,,
code-creation,LazyCompile,10,43312,0x109acf0a288e,57,addSignalHandler node:internal/process/report:98:26,0x109acf09fdf0,~
code-source-info,0x109acf0a288e,99,2144,2290,C0O2154C5O2161C10O2161C16O2191C22O2226C27O2235C32O2235C38O2253C41O2261C49O2261C56O2289,,
code-creation,LazyCompile,10,43357,0x109acf0a2e56,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:309:46,0x109acf087ec8,~
code-source-info,0x109acf0a2e56,97,9261,9523,C0O9261C8O9283C18O9283C23O9327C25O9344C26O9351C27O9355C35O9355C40O9385C45O9386C50O9446C58O9446C63O9424C69O9464C74O9472C79O9475C84O9472C91O9522,,
code-creation,LazyCompile,10,43416,0x109acf0a30e6,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:439:37,0x109acf088098,~
code-source-info,0x109acf0a30e6,97,13275,13804,C0O13282C3O13294C8O13298C14O13336C20O13336C25O13380C33O13403C38O13407C46O13380C52O13433C53O13443C57O13433C61O13524C64O13539C73O13597C76O13605C81O13609C90O13656C93O13671C102O13713C108O13713C113O13737C118O13738C124O13777C127O13792C132O13777C137O13803,,
code-creation,LazyCompile,10,43533,0x109acf0a34de,455,initializePolicy node:internal/bootstrap/pre_execution:467:26,0x109acf088138,~
code-source-info,0x109acf0a34de,97,14103,15901,C0O14137C10O14137C15O14180C17O14210C21O14218C35O14218C41O14343C49O14343C55O14320C60O14335C65O14462C67O14479C75O14483C81O14498C87O14499C94O14539C100O14571C108O14553C116O14628C120O14650C126O14650C132O14628C138O14664C149O14680C153O14694C161O14708C167O14766C175O14766C180O14800C190O14800C197O14875C207O14875C212O14917C214O14970C222O14970C227O15048C235O15048C241O15016C246O15028C251O15097C257O15097C263O15147C269O15147C275O15206C277O15232C279O15256C283O15237C288O15346C290O15362C295O15297C300O15325C305O15388C311O15424C317O15424C322O15465C328O15465C334O15494C340O15514C344O15501C349O15534C356O15581C358O15610C360O15651C366O15673C376O15673C383O15651C389O15265C394O15219C397O15708C401O15735C415O15741C420O15735C421O15824C429O15824C435O15865C441O15889C447O15866C454O15900,,
code-creation,LazyCompile,10,43591,0x109acf0a38ce,63,initializeClusterIPC node:internal/bootstrap/pre_execution:458:30,0x109acf0880e8,~
code-source-info,0x109acf0a38ce,97,13835,14076,C0O13842C3O13854C10O13858C18O13873C23O13877C29O13915C35O13915C40O13947C45O13947C49O14036C52O14051C62O14075,,
code-creation,LazyCompile,10,43651,0x109acf0a3a3e,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:562:38,0x109acf088278,~
code-source-info,0x109acf0a3a3e,97,17634,17783,C0O17678C6O17678C11O17649C16O17729C21O17758C26O17782,,
tick,0x1109754,43690,0,0x0,3,0x1229670,0x109acf08a234,0x109acf085afd
code-creation,Eval,10,43925,0x109acf0a442e,5, node:internal/source_map/source_map_cache:1:1,0x109acf0a40c8,~
script-source,100,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x109acf0a442e,100,0,7630,C0O0C4O7630,,
code-creation,Function,10,44328,0x109acf0a4aa6,435, node:internal/source_map/source_map_cache:1:1,0x109acf0a43a8,~
code-source-info,0x109acf0a4aa6,100,0,7630,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7494C399O7515C405O7532C411O7556C417O7580C423O7603C429O7509C434O7629,,
code-creation,LazyCompile,10,44497,0x109acf0a588e,82,debuglog node:internal/util/debuglog:71:18,0x136fed71d2f0,~
code-source-info,0x109acf0a588e,22,2232,3219,C0O2232C28O2357C32O2357C34O2759C35O2759C37O2781C41O2781C43O2869C48O3068C58O3089C63O3114C74O3068C79O3203C81O3217,,
code-creation,Eval,10,44725,0x109acf0a5e0e,5, node:internal/util/iterable_weak_map:1:1,0x109acf0a5bc0,~
script-source,101,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x109acf0a5e0e,101,0,1958,C0O0C4O1958,,
code-creation,Function,10,44847,0x109acf0a656e,196, node:internal/util/iterable_weak_map:1:1,0x109acf0a5d88,~
code-source-info,0x109acf0a656e,101,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,44867,0x109acf0a66ee,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x109acf0a6098,~
code-source-info,0x109acf0a66ee,101,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
tick,0xb442a4,44887,1,0xb83830,3,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf0a4bcd,0x109acf086aa5,0x109acf085d75,0x109acf0a3a44,0x109acf08a234,0x109acf085afd
code-creation,Eval,10,45184,0x109acf0a73f6,5, node:internal/modules/cjs/helpers:1:1,0x109acf0a7140,~
script-source,102,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\n/**\n *\n * @param {string | URL} referrer\n * @returns {string}\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x109acf0a73f6,102,0,6812,C0O0C4O6812,,
code-creation,Function,10,45543,0x109acf0a7976,536, node:internal/modules/cjs/helpers:1:1,0x109acf0a7370,~
code-source-info,0x109acf0a7976,102,0,6812,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6652C488O6673C494O6699C500O6716C506O6732C512O6752C518O6775C524O6799C530O6667C535O6811,,
code-creation,LazyCompile,10,45692,0x109acf0a862e,27,SafeSet node:internal/per_context/primordials:373:16,0x2842ea08a098,~
code-source-info,0x109acf0a862e,6,10662,10679,C3O10668C7O10674C11O10668C26O10678,,
code-creation,LazyCompile,10,45750,0x109acf0a8726,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x109acf0a5e90,~
code-source-info,0x109acf0a8726,101,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,45806,0x109acf0a8aae,27,SafeWeakMap node:internal/per_context/primordials:366:16,0x2842ea089fd0,~
code-source-info,0x109acf0a8aae,6,10506,10523,C3O10512C7O10518C11O10512C26O10522,,
tick,0x7f0810bde090,45828,0,0x0,3,0x123ee50,0x109acf0a4bfb,0x109acf086aa5,0x109acf085d75,0x109acf0a3a44,0x109acf08a234,0x109acf085afd
code-creation,LazyCompile,10,45840,0x109acf0a8bb6,27,SafeFinalizationRegistry node:internal/per_context/primordials:387:16,0x2842ea08a220,~
code-source-info,0x109acf0a8bb6,6,11112,11157,C3O11132C7O11138C11O11132C26O11156,,
code-creation,LazyCompile,10,45985,0x109acf0a942e,492,initializeDeprecations node:internal/bootstrap/pre_execution:352:32,0x109acf088008,~
code-source-info,0x109acf0a942e,97,10738,13237,C0O10738C11O10767C19O10767C24O10753C29O10822C39O10822C44O11013C52O11013C57O11054C65O11054C70O11107C99O11099C127O11099C130O11425C141O11445C145O11487C156O11561C167O11651C178O11606C187O11472C196O11710C199O11443C203O11088C269O11987C277O11987C282O11966C287O12016C289O12044C304O12065C311O12183C315O12044C320O12215C324O12245C334O12281C344O12358C351O12263C356O12261C360O12444C370O12486C381O12468C386O12466C390O12825C394O12825C396O12836C407O12857C418O12886C426O12928C434O12836C439O13041C445O13041C447O13051C458O13072C469O13100C477O13141C485O13051C491O13236,,
code-creation,LazyCompile,10,46072,0x109acf0a9946,53,initializeWASI node:internal/bootstrap/pre_execution:516:24,0x109acf088188,~
code-source-info,0x109acf0a9946,97,15926,16132,C0O15958C6O15958C11O15941C16O16024C21O16028C29O16028C35O16043C37O16074C43O16074C47O16068C52O16131,,
code-creation,LazyCompile,10,46117,0x109acf0a9b46,66,initializeCJSLoader node:internal/bootstrap/pre_execution:523:29,0x109acf0881d8,~
code-source-info,0x109acf0a9b46,97,16162,16477,C0O16187C6O16187C11O16229C16O16234C20O16254C26O16292C31O16299C36O16299C40O16395C51O16416C56O16452C60O16410C65O16476,,
tick,0x1143409,46900,1,0xb83830,2,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,47138,0x109acf0abb0e,5, node:internal/modules/cjs/loader:1:1,0x109acf0ab228,~
script-source,103,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier\x2C _\x2C importAssertions) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C\n                             loader.getBaseURL(normalizeReferrerURL(filename))\x2C\n                             importAssertions);\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C\n                             loader.getBaseURL(normalizeReferrerURL(filename))\x2C\n                             importAssertions);\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x109acf0abb0e,103,0,40215,C0O0C4O40215,,
code-creation,Function,10,49232,0x109acf0ad8ae,2547, node:internal/modules/cjs/loader:1:1,0x109acf0aba88,~
code-source-info,0x109acf0ad8ae,103,0,40215,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13489C2107O13489C2109O14264C2116O14264C2118O14282C2126O14299C2134O16975C2141O16975C2143O17052C2147O17060C2155O17052C2157O17068C2161O17131C2169O17155C2179O18739C2187O18763C2195O19909C2203O19936C2211O21484C2223O21502C2235O21879C2249O21484C2259O21484C2261O23167C2269O23180C2277O26111C2285O26135C2293O29982C2297O29989C2311O30004C2319O30918C2323O30925C2337O30943C2345O31381C2346O31381C2348O31416C2349O31416C2351O32705C2355O32712C2369O32731C2377O34613C2381O34620C2395O34639C2403O36435C2407O36442C2421O36463C2429O36863C2433O36870C2447O36891C2455O37704C2461O37754C2467O37704C2469O38338C2475O38359C2483O38377C2491O38395C2499O39364C2507O39387C2515O39974C2523O40003C2531O40191C2537O40205C2546O40214,,
tick,0x7f0810fb36e7,49361,1,0xb83830,3,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810b84300,49373,1,0xb83830,3,0xd81050,0x109acf086a84,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,49579,0x109acf0b190e,5, node:internal/modules/package_json_reader:1:1,0x109acf0b1768,~
script-source,104,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x109acf0b190e,104,0,983,C0O0C4O983,,
code-creation,Function,10,49652,0x109acf0b1a5e,113, node:internal/modules/package_json_reader:1:1,0x109acf0b1888,~
code-source-info,0x109acf0b1a5e,104,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
new,MemoryChunk,0x7f07fc040000,262144
code-creation,Function,11,49811,0x7f07fc043080,1296,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x2842ea08fce8,^
code-source-info,0x7f07fc043080,9,9529,10090,,,
code-creation,Function,11,49833,0x7f07fc043640,116,isPosixPathSeparator node:path:56:30,0x273b979ba720,^
code-source-info,0x7f07fc043640,41,1854,1902,,,
code-creation,Function,11,49852,0x7f07fc043740,676,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x2842ea08fdb8,^
code-source-info,0x7f07fc043740,9,10316,10659,,,
code-creation,Function,11,49871,0x7f07fc043a80,588,getOptionValue node:internal/options:44:24,0x2989f35998f0,^
code-source-info,0x7f07fc043a80,92,985,1228,,,
code-creation,Function,11,49892,0x7f07fc043d80,444,getCLIOptionsFromBinding node:internal/options:18:34,0x2989f3599588,^
code-source-info,0x7f07fc043d80,92,497,598,,,
code-creation,Eval,10,50065,0x109acf0b253e,5, node:internal/process/esm_loader:1:1,0x109acf0b2348,~
script-source,105,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\n\nexports.esmLoader = esmLoader;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  // customLoaders CURRENTLY can be only 1 (a string)\n  // Once chaining is implemented\x2C it will be string[]\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (!customLoaders.length) return;\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const exports = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(exports);\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x109acf0b253e,105,0,2766,C0O0C4O2766,,
code-creation,Function,10,50228,0x109acf0b27de,182, node:internal/process/esm_loader:1:1,0x109acf0b24b8,~
code-source-info,0x109acf0b27de,105,0,2766,C0O0C44O25C50O111C56O111C61O137C66O67C72O167C78O167C83O153C89O258C95O258C100O217C106O323C112O323C117O305C123O381C129O381C134O358C140O413C144O448C148O749C152O789C156O1259C159O1259C164O1259C166O1277C168O1295C172O2411C176O2427C181O2765,,
tick,0xeb0404,50265,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,50685,0x109acf0b3b6e,5, node:internal/modules/esm/loader:1:1,0x109acf0b36c0,~
script-source,106,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\nconst { MessageChannel } = require('internal/worker/io');\n\nconst {\n  ERR_INTERNAL_ASSERTION\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance\x2C URL } = require('internal/url');\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst {\n  initializeImportMeta\n} = require('internal/modules/esm/initialize_import_meta');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\nconst {\n  fetchModule\x2C\n} = require('internal/modules/esm/fetch_module');\n\n\n/**\n * Prevent the specifier resolution warning from being printed twice\n */\nlet emittedSpecifierResolutionWarning = false;\n\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {Function[]} globalPreloaders First-in-first-out list of\n   * preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {Function[]} loaders First-in-first-out list of loader hooks.\n   */\n  #loaders = [\n    defaultLoad\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {Function[]} resolvers First-in-first-out list of resolver hooks\n   */\n  #resolvers = [\n    defaultResolve\x2C\n  ];\n\n  #importMetaInitializer = initializeImportMeta;\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  constructor() {\n    if (getOptionValue('--experimental-loader')) {\n      emitExperimentalWarning('Custom ESM Loaders');\n    }\n    if (getOptionValue('--experimental-network-imports')) {\n      emitExperimentalWarning('Network Imports');\n    }\n    if (getOptionValue('--experimental-specifier-resolution') === 'node' && !emittedSpecifierResolutionWarning) {\n      process.emitWarning(\n        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.'\x2C\n        'ExperimentalWarning'\n      );\n      emittedSpecifierResolutionWarning = true;\n    }\n  }\n\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {object | object[]} customLoaders A list of exports from\n   * user-defined loaders (as returned by ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\n\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) ArrayPrototypePush(\n        this.#globalPreloaders\x2C\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\n      );\n      if (resolver) ArrayPrototypePush(\n        this.#resolvers\x2C\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\n      );\n      if (loader) ArrayPrototypePush(\n        this.#loaders\x2C\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\n      );\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }\x2C importAssertions) => {\n          return this.import(specifier\x2C\n                             this.getBaseURL(url)\x2C\n                             importAssertions);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Returns the url to use for the resolution of a given cache key url\n   * These are not guaranteed to be the same.\n   *\n   * In WHATWG HTTP spec for ESM the cache key is the non-I/O bound\n   * synchronous resolution using only string operations\n   *   ~= resolveImportMap(new URL(specifier\x2C importerHREF))\n   *\n   * The url used for subsequent resolution is the response URL after\n   * all redirects have been resolved.\n   *\n   * https://example.com/foo redirecting to https://example.com/bar\n   * would have a cache key of https://example.com/foo and baseURL\n   * of https://example.com/bar\n   *\n   * MUST BE SYNCHRONOUS for import.meta initialization\n   * MUST BE CALLED AFTER receiving the url body due to I/O\n   * @param {string} url\n   * @returns {string}\n   */\n  getBaseURL(url) {\n    if (\n      StringPrototypeStartsWith(url\x2C 'http:') ||\n      StringPrototypeStartsWith(url\x2C 'https:')\n    ) {\n      // The request & response have already settled\x2C so they are in\n      // fetchModule's cache\x2C in which case\x2C fetchModule returns\n      // immediately and synchronously\n      url = fetchModule(new URL(url)\x2C { parentURL: url }).resolvedHREF;\n      // This should only occur if the module hasn't been fetched yet\n      if (typeof url !== 'string') {\n        throw new ERR_INTERNAL_ASSERTION(`Base url for module ${url} not loaded.`);\n      }\n    }\n    return url;\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAssertions) {\n    let importAssertionsForResolve;\n    if (this.#loaders.length !== 1) {\n      // We can skip cloning if there are no user provided loaders because\n      // the Node.js default resolve hook does not use import assertions.\n      importAssertionsForResolve =\n        ObjectAssign(ObjectCreate(null)\x2C importAssertions);\n    }\n    const { format\x2C url } =\n      await this.resolve(specifier\x2C parentURL\x2C importAssertionsForResolve);\n\n    let job = this.moduleMap.get(url\x2C importAssertions.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.moduleMap.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format) {\n    const moduleProvider = async (url\x2C isMain) => {\n      const {\n        format: finalFormat\x2C\n        source\x2C\n      } = await this.load(url\x2C {\n        format\x2C\n        importAssertions\x2C\n      });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C url);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAssertions\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C importAssertions.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<object | object[]>} A list of module export(s).\n   */\n  async import(specifiers\x2C parentURL\x2C importAssertions) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) specifiers = [specifiers];\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL\x2C importAssertions)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    return wasArr ?\n      namespaces :\n      namespaces[0];\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} url The URL/path of the module to be loaded\n   * @param {object} context Metadata about the module\n   * @returns {object}\n   */\n  async load(url\x2C context = {}) {\n    const defaultLoader = this.#loaders[0];\n\n    const loader = this.#loaders.length === 1 ?\n      defaultLoader :\n      this.#loaders[1];\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\n\n    if (typeof loaded !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader load'\x2C\n        loaded\x2C\n      );\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_UNKNOWN_MODULE_FORMAT(\n        dataUrl ? dataUrl[1] : format\x2C\n        url);\n    }\n\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n      'loader load'\x2C\n      'source'\x2C\n      source\n    );\n\n    return {\n      format\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count) return;\n\n    for (let i = 0; i < count; i++) {\n      const channel = new MessageChannel();\n      const {\n        port1: insidePreload\x2C\n        port2: insideLoader\x2C\n      } = channel;\n\n      insidePreload.unref();\n      insideLoader.unref();\n\n      const preload = this.#globalPreloaders[i]({\n        port: insideLoader\n      });\n\n      if (preload == null) return;\n\n      if (typeof preload !== 'string') {\n        throw new ERR_INVALID_RETURN_VALUE(\n          'string'\x2C\n          'loader globalPreloadCode'\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin'\x2C 'port'\x2C 'setImportMetaCallback']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n      // We only allow replacing the importMetaInitializer during preload\x2C\n      // after preload is finished\x2C we disable the ability to replace it\n      //\n      // This exposes accidentally setting the initializer too late by\n      // throwing an error.\n      let finished = false;\n      let replacedImportMetaInitializer = false;\n      let next = this.#importMetaInitializer;\n      try {\n        // Calls the compiled preload source text gotten from the hook\n        // Since the parameters are named we use positional parameters\n        // see compileFunction above to cross reference the names\n        FunctionPrototypeCall(\n          preloadInit\x2C\n          globalThis\x2C\n          // Param getBuiltin\n          (builtinName) => {\n            if (NativeModule.canBeRequiredByUsers(builtinName)) {\n              return require(builtinName);\n            }\n            throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n          }\x2C\n          // Param port\n          insidePreload\x2C\n          // Param setImportMetaCallback\n          (fn) => {\n            if (finished || typeof fn !== 'function') {\n              throw new ERR_INVALID_ARG_TYPE('fn'\x2C fn);\n            }\n            replacedImportMetaInitializer = true;\n            const parent = next;\n            next = (meta\x2C context) => {\n              return fn(meta\x2C context\x2C parent);\n            };\n          });\n      } finally {\n        finished = true;\n        if (replacedImportMetaInitializer) {\n          this.#importMetaInitializer = next;\n        }\n      }\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    this.#importMetaInitializer(meta\x2C context);\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAssertions} [importAssertions] Assertions from the import\n   *                                              statement or expression.\n   * @returns {{ url: string }}\n   */\n  async resolve(\n    originalSpecifier\x2C\n    parentURL\x2C\n    importAssertions = ObjectCreate(null)\n  ) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) throw new ERR_INVALID_ARG_TYPE(\n      'parentURL'\x2C\n      ['string'\x2C 'URL']\x2C\n      parentURL\x2C\n    );\n\n    const conditions = DEFAULT_CONDITIONS;\n\n    const defaultResolver = this.#resolvers[0];\n\n    const resolver = this.#resolvers.length === 1 ?\n      defaultResolver :\n      this.#resolvers[1];\n    const resolution = await resolver(\n      originalSpecifier\x2C\n      {\n        conditions\x2C\n        importAssertions\x2C\n        parentURL\x2C\n      }\x2C\n      defaultResolver\x2C\n    );\n\n    if (typeof resolution !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader resolve'\x2C\n        resolution\x2C\n      );\n    }\n\n    const { format\x2C url } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string'\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (typeof url !== 'string') { // non-strings can be coerced to a url string\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    new URL(url); // Intentionally trigger error if `url` is invalid\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x109acf0b3b6e,106,0,18784,C0O0C4O18784,,
tick,0x7f0810fb3828,54542,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x129c377,54560,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810b84473,54571,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Function,10,54581,0x109acf0b444e,685, node:internal/modules/esm/loader:1:1,0x109acf0b3ae8,~
code-source-info,0x109acf0b444e,106,0,18784,C0O0C128O79C134O79C138O130C144O139C150O155C156O177C162O199C168O224C174O249C180O265C186O281C191O305C197O319C203O342C209O363C215O378C221O407C227O463C233O463C238O444C244O675C250O675C255O701C260O505C266O531C272O555C278O580C284O617C290O645C296O755C302O755C307O717C313O732C319O747C325O816C331O816C336O788C342O895C348O895C353O852C359O872C365O945C371O945C375O945C377O1007C383O1007C387O1007C389O1104C395O1104C400O1062C406O1080C412O1180C418O1180C423O1155C429O1260C435O1260C440O1244C446O1322C452O1322C457O1306C463O1397C469O1397C474O1378C480O1453C486O1453C491O1436C497O1618C498O1618C665O18734C672O18703C677O18753C679O18771C684O18783,,
code-creation,Function,10,54616,0x109acf0b4916,154,<instance_members_initializer> node:internal/modules/esm/loader:76:3,0x109acf0b3f60,~
code-source-info,0x109acf0b4916,106,2066,2909,C3O2086C17O2241C28O2247C45O2421C56O2427C73O2476C88O2570C95O2570C109O2688C119O2775C126O2775C140O2898C153O2909,,
tick,0x1167b70,54842,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b45c1,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,54949,0x109acf0b63ae,5, node:internal/modules/esm/module_map:1:1,0x109acf0b61c0,~
script-source,107,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nconst {\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleMap`);\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x109acf0b63ae,107,0,1444,C0O0C4O1444,,
code-creation,Function,10,55048,0x109acf0b67e6,175, node:internal/modules/esm/module_map:1:1,0x109acf0b6328,~
code-source-info,0x109acf0b67e6,107,0,1444,C0O0C23O33C26O33C30O33C32O109C35O109C40O85C46O159C52O175C57O213C60O213C65O246C78O247C84O213C86O324C89O324C94O350C99O299C105O385C108O385C113O366C123O495C167O1416C169O1431C174O1443,,
code-creation,Eval,10,55336,0x109acf0b7346,5, node:internal/modules/esm/module_job:1:1,0x109acf0b7050,~
script-source,108,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C importAssertions = ObjectCreate(null)\x2C\n              moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.importAssertions = importAssertions;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier\x2C assertions) => {\n        const baseURL = this.loader.getBaseURL(url);\n        const jobPromise = this.loader.getModuleJob(specifier\x2C baseURL\x2C assertions);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        let format;\n        try {\n          // This might throw for non-CommonJS modules because we aren't passing\n          // in the import assertions and some formats require them; but we only\n          // care about CommonJS for the purposes of this error message.\n          ({ format } =\n            await this.loader.load(childFileURL));\n        } catch {\n          // Continue regardless of error.\n        }\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x109acf0b7346,108,0,8238,C0O0C4O8238,,
code-creation,Function,10,55766,0x109acf0b783e,343, node:internal/modules/esm/module_job:1:1,0x109acf0b72c0,~
code-source-info,0x109acf0b783e,108,0,8238,C0O0C88O25C94O47C100O68C106O90C112O112C117O133C123O149C128O173C134O187C139O205C145O230C151O246C157O269C163O290C169O301C175O328C181O352C187O378C193O402C199O470C205O470C210O455C216O534C222O534C227O511C233O596C239O596C244O570C250O660C256O660C260O660C262O712C265O712C267O744C269O744C271O785C272O785C274O815C278O815C280O933C284O933C323O8192C330O8161C335O8210C337O8225C342O8237,,
tick,0xeaa830,55910,1,0xafbff0,5,0xd81050,0x109acf08e80f,0x109acf0b790b,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b6800,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45c1,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,56047,0x109acf0b9496,5, node:internal/modules/esm/assert:1:1,0x109acf0b92a0,~
script-source,109,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectCreate\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\n/**\n * Define a map of module formats to import assertion types (the value of\n * `type` in `assert { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an assertion type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' assert { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import assertions.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAssertions Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAssertions(url\x2C format\x2C\n                            importAssertions = ObjectCreate(null)) {\n  const validType = formatTypeMap[format];\n\n  switch (validType) {\n    case undefined:\n      // Ignore assertions for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import assertions object.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAssertions.type);\n\n    case importAssertions.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAssertions.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      handleInvalidType(url\x2C importAssertions.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAssertions\x2C\n};\n
code-source-info,0x109acf0b9496,109,0,3624,C0O0C4O3624,,
code-creation,Function,10,56250,0x109acf0b976e,201, node:internal/modules/esm/assert:1:1,0x109acf0b9410,~
code-source-info,0x109acf0b976e,109,0,3624,C0O0C46O25C51O49C57O75C63O91C68O107C74O182C77O182C82O163C88O341C91O341C96O367C101O225C107O261C113O298C119O468C121O468C123O659C130O695C136O730C142O781C148O812C154O659C156O1240C159O1264C169O1240C174O1240C176O3557C183O3578C189O3601C195O3572C200O3623,,
code-creation,LazyCompile,10,56353,0x109acf0b9d76,9, node:internal/modules/esm/assert:43:3,0x109acf0b9568,~
code-source-info,0x109acf0b9d76,109,1295,1333,C0O1310C2O1314C4O1310C8O1333,,
tick,0x11b4c74,56980,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,57270,0x109acf0bb90e,5, node:internal/modules/esm/resolve:1:1,0x109acf0bb170,~
script-source,110,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   pjsonPath: string\x2C\n *   exports?: ExportConfig\x2C\n *   name?: string\x2C\n *   main?: string\x2C\n *   type?: PackageType\x2C\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormatWithoutErrors(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap(); /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @param {boolean} preserveSymlinks\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  let path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n\n    // Directory\n    if (file === undefined) {\n      file = StringPrototypeEndsWith(path\x2C '/') ?\n        (resolveDirectoryEntry(resolved) || resolved) : resolveDirectoryEntry(new URL(`${resolved}/`));\n\n      if (file === resolved) return file;\n\n      if (file === undefined) {\n        throw new ERR_MODULE_NOT_FOUND(\n          resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n      }\n    }\n\n    path = file;\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(path\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const { search\x2C hash } = resolved;\n    resolved =\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {\n        // Continue regardless of error.\n      }\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(\n          exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath)) {\n    const request = pattern ?\n      StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    throwInvalidSubpath(request\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace(\n        patternRegEx\x2C\n        resolved.href\x2C\n        () => subpath\n      )\n    );\n  }\n\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0) {\n      return null;\n    }\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET') {\n          continue;\n        }\n        throw e;\n      }\n      if (resolveResult === undefined) {\n        continue;\n      }\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolveResult === undefined)\n          continue;\n        return resolveResult;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n\n    return resolveResult;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C\n      target\x2C\n      bestMatchSubpath\x2C\n      bestMatch\x2C\n      base\x2C\n      true\x2C\n      false\x2C\n      conditions);\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n    return resolveResult;\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolveResult != null) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                     bestMatchSubpath\x2C\n                                                     bestMatch\x2C base\x2C true\x2C\n                                                     true\x2C conditions);\n          if (resolveResult != null) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null)\n    validPackageName = false;\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {resolved: URL\x2C format? : string}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  if (NativeModule.canBeRequiredByUsers(specifier))\n    return new URL('node:' + specifier);\n\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n    if (packageSubpath === '.') {\n      return legacyMainResolve(\n        packageJSONUrl\x2C\n        packageConfig\x2C\n        base\n      );\n    }\n\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @param {boolean} preserveSymlinks\n * @returns {url: URL\x2C format?: string}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' ||\n    base.protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier\x2C base\x2C conditions);\n      }\n    }\n  }\n  if (resolved.protocol !== 'file:') {\n    return resolved;\n  }\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\n// TODO(@JakobJingleheimer): de-dupe `specifier` & `parsed`\nfunction checkIfDisallowedImport(specifier\x2C parsed\x2C parsedParentURL) {\n  if (parsedParentURL) {\n    const parentURL = fileURLToPath(parsedParentURL?.href);\n\n    if (\n      parsedParentURL.protocol === 'http:' ||\n      parsedParentURL.protocol === 'https:'\n    ) {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // data: and blob: disallowed due to allowing file: access via\n        // indirection\n        if (parsed &&\n          parsed.protocol !== 'https:' &&\n          parsed.protocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier\x2C\n            parentURL\x2C\n            'remote imports cannot import from a local location.'\n          );\n        }\n\n        return { url: parsed.href };\n      }\n      if (NativeModule.canBeRequiredByUsers(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier\x2C\n          parentURL\x2C\n          'remote imports cannot import from a local location.'\n        );\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier\x2C\n        parentURL\x2C\n        'only relative and absolute specifiers are supported.'\n      );\n    }\n  }\n}\n\nfunction throwIfUnsupportedURLProtocol(url) {\n  if (url.protocol !== 'file:' && url.protocol !== 'data:' &&\n      url.protocol !== 'node:') {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);\n  }\n}\n\nfunction throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports) {\n  if (\n    parsed &&\n    parsed.protocol !== 'file:' &&\n    parsed.protocol !== 'data:' &&\n    (\n      !experimentalNetworkImports ||\n      (\n        parsed.protocol !== 'https:' &&\n        parsed.protocol !== 'http:'\n      )\n    )\n  ) {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C ArrayPrototypeConcat(\n      'file'\x2C\n      'data'\x2C\n      experimentalNetworkImports ? ['https'\x2C 'http'] : []\x2C\n    ));\n  }\n}\n\nasync function defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        // Prevent network requests from firing if resolution would be banned.\n        // Network requests can extract data by doing things like putting\n        // secrets in query params\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  let parsed;\n  try {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      parsed = new URL(specifier\x2C parsedParentURL);\n    } else {\n      parsed = new URL(specifier);\n    }\n\n    if (parsed.protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (\n          parsed.protocol === 'https:' ||\n          parsed.protocol === 'http:'\n        )\n      )\n    ) {\n      return { url: parsed.href };\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns\x2C DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier\x2C\n    parsed\x2C\n    parsedParentURL\x2C\n  );\n\n  if (maybeReturn) return maybeReturn;\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return { url: specifier };\n\n  throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports);\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(\n      specifier\x2C\n      parentURL\x2C\n      conditions\x2C\n      isMain ? preserveSymlinksMain : preserveSymlinks\n    );\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  throwIfUnsupportedURLProtocol(url);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems\x2C silencing them\n    url: url.href\x2C\n    format: defaultGetFormatWithoutErrors(url\x2C context)\x2C\n  };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n};\n\n// cycle\nconst {\n  defaultGetFormatWithoutErrors\x2C\n} = require('internal/modules/esm/get_format');\n\nif (policy) {\n  const $defaultResolve = defaultResolve;\n  module.exports.defaultResolve = async function defaultResolve(\n    specifier\x2C\n    context\n  ) {\n    const ret = await $defaultResolve(specifier\x2C context\x2C $defaultResolve);\n    // This is a preflight check to avoid data exfiltration by query params etc.\n    policy.manifest.mightAllow(ret.url\x2C () =>\n      new ERR_MANIFEST_DEPENDENCY_MISSING(\n        context.parentURL\x2C\n        specifier\x2C\n        context.conditions\n      )\n    );\n    return ret;\n  };\n}\n
code-source-info,0x109acf0bb90e,110,0,39422,C0O0C4O39422,,
code-creation,Function,10,59310,0x109acf0bc9e6,1173, node:internal/modules/esm/resolve:1:1,0x109acf0bb888,~
code-source-info,0x109acf0bc9e6,110,0,39422,C0O0C406O25C412O41C418O65C424O87C430O110C436O123C442O140C447O156C453O185C459O218C465O228C471O251C477O283C483O306C488O317C494O328C500O338C506O365C512O392C518O418C524O448C530O474C536O498C542O522C548O585C551O585C555O585C557O640C560O640C565O623C571O728C574O728C579O689C585O705C591O717C597O770C600O770C605O751C611O865C617O865C626O909C633O865C635O989C638O989C643O962C649O967C655O977C661O1031C667O1031C671O1031C673O1099C679O1099C683O1099C685O1180C691O1180C695O1180C697O1247C703O1247C707O1247C709O1325C712O1325C717O1287C723O1292C729O1307C735O1732C738O1732C743O1758C748O1360C754O1390C760O1415C766O1447C772O1477C778O1507C784O1542C790O1566C796O1600C802O1633C808O1663C814O1696C820O1796C823O1796C828O1782C834O1863C837O1863C841O1863C843O1935C849O1935C854O1984C860O1984C865O2039C876O2100C883O2142C884O2142C938O2164C989O2100C993O2100C995O2216C1003O2216C1008O2216C1010O2557C1013O2557C1018O2557C1020O4846C1022O4846C1027O4846C1029O4886C1031O4886C1036O4886C1038O5025C1042O5025C1044O10336C1048O10336C1050O11310C1054O11310C1056O14620C1060O14620C1062O14823C1066O14823C1068O14856C1072O14856C1074O38637C1081O38658C1087O38680C1093O38698C1099O38717C1105O38742C1111O38760C1117O38785C1123O38652C1127O38866C1130O38866C1135O38831C1141O38911C1152O38951C1154O38951C1156O38976C1165O38999C1172O39421,,
tick,0x7f0810b778f9,59401,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810fb36e3,59415,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
new,MemoryChunk,0x25349b140000,262144
code-creation,Eval,10,59731,0xdd57423f566,5, node:internal/modules/esm/get_format:1:1,0xdd57423f2e0,~
script-source,111,node:internal/modules/esm/get_format,'use strict';\nconst {\n  RegExpPrototypeExec\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst { basename\x2C extname\x2C relative } = require('path');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\nconst {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  mimeToFormat\x2C\n} = require('internal/modules/esm/formats');\n\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst { getPackageType\x2C getPackageScopeConfig } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:': getDataProtocolModuleFormat\x2C\n  'file:': getFileProtocolModuleFormat\x2C\n  'http:': getHttpProtocolModuleFormat\x2C\n  'https:': getHttpProtocolModuleFormat\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\n/**\n * @param {URL} parsed\n * @returns {string | null}\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = RegExpPrototypeExec(\n    /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    parsed.pathname\x2C\n  ) || [ null\x2C null\x2C null ];\n\n  return mimeToFormat(mime);\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @param {boolean} ignoreErrors\n * @returns {string}\n */\nfunction getFileProtocolModuleFormat(url\x2C context\x2C ignoreErrors) {\n  const filepath = fileURLToPath(url);\n  const ext = extname(filepath);\n  if (ext === '.js') {\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs';\n  }\n\n  const format = extensionFormatMap[ext];\n  if (format) return format;\n\n  if (experimentalSpecifierResolution !== 'node') {\n    // Explicit undefined return indicates load hook should rerun format check\n    if (ignoreErrors) return undefined;\n    let suggestion = '';\n    if (getPackageType(url) === 'module' && ext === '') {\n      const config = getPackageScopeConfig(url);\n      const fileBasename = basename(filepath);\n      const relativePath = StringPrototypeSlice(relative(config.pjsonPath\x2C filepath)\x2C 1);\n      suggestion = 'Loading extensionless files is not supported inside of ' +\n        '"type":"module" package.json contexts. The package.json file ' +\n        `${config.pjsonPath} caused this "type":"module" context. Try ` +\n        `changing ${filepath} to have a file extension. Note the "bin" ` +\n        'field of package.json can point to a file with an extension\x2C for example ' +\n        `{"type":"module"\x2C"bin":{"${fileBasename}":"${relativePath}.js"}}`;\n    }\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C filepath\x2C suggestion);\n  }\n\n  return getLegacyExtensionFormat(ext) ?? null;\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | undefined} only works when enabled\n */\nfunction getHttpProtocolModuleFormat(url\x2C context) {\n  if (experimentalNetworkImports) {\n    return PromisePrototypeThen(\n      PromiseResolve(fetchModule(url\x2C context))\x2C\n      (entry) => {\n        return mimeToFormat(entry.headers['content-type']);\n      }\n    );\n  }\n}\n\n/**\n * @param {URL | URL['href']} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\n  const parsed = new URL(url);\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol))\n    return null;\n  return protocolHandlers[parsed.protocol](parsed\x2C context\x2C true);\n}\n\n/**\n * @param {URL | URL['href']} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C context\x2C false) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  defaultGetFormatWithoutErrors\x2C\n  extensionFormatMap\x2C\n};\n
code-source-info,0xdd57423f566,111,0,4193,C0O0C4O4193,,
code-creation,Function,10,59961,0xdd57423f9e6,368, node:internal/modules/esm/get_format:1:1,0xdd57423f4e0,~
code-source-info,0xdd57423f9e6,111,0,4193,C0O0C90O24C96O47C101O63C106O79C112O112C118O136C124O154C130O233C133O233C138O201C144O211C150O220C156O277C159O277C164O258C169O330C172O330C177O314C183O454C186O454C191O386C197O408C203O436C209O533C212O533C216O533C218O625C221O625C225O625C227O730C230O730C235O688C241O704C247O802C250O802C255O779C261O784C267O866C270O866C275O892C280O835C286O926C288O939C300O972C306O1012C312O1052C318O1093C322O1124C330O926C335O926C337O4096C344O4117C350O4137C356O4170C362O4111C367O4192,,
tick,0x7f0810b9b11f,60176,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,60264,0x25349b141d4e,5, node:internal/modules/esm/fetch_module:1:1,0x25349b141a78,~
script-source,112,node:internal/modules/esm/fetch_module,'use strict';\nconst {\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  Buffer: { concat: BufferConcat }\x2C\n} = require('buffer');\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_NETWORK_IMPORT_BAD_RESPONSE\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n} = require('internal/errors').codes;\nconst { URL } = require('internal/url');\nconst net = require('net');\nconst { once } = require('events');\nconst { compose } = require('stream');\n/**\n * @typedef CacheEntry\n * @property {Promise<string> | string} resolvedHREF\n * @property {Record<string\x2C string>} headers\n * @property {Promise<Buffer> | Buffer} body\n */\n\n/**\n * Only for GET requests\x2C other requests would need new Map\n * HTTP cache semantics keep diff caches\n *\n * It caches either the promise or the cache entry since import.meta.url needs\n * the value synchronously for the response location after all redirects.\n *\n * Maps HREF to pending cache entry\n * @type {Map<string\x2C Promise<CacheEntry> | CacheEntry>}\n */\nconst cacheForGET = new SafeMap();\n\n// [1] The V8 snapshot doesn't like some C++ APIs to be loaded eagerly. Do it\n// lazily/at runtime and not top level of an internal module.\n\n// [2] Creating a new agent instead of using the gloabl agent improves\n// performance and precludes the agent becoming tainted.\n\nlet HTTPSAgent;\nfunction HTTPSGet(url\x2C opts) {\n  const https = require('https'); // [1]\n  HTTPSAgent ??= new https.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return https.get(url\x2C {\n    agent: HTTPSAgent\x2C\n    ...opts\x2C\n  });\n}\n\nlet HTTPAgent;\nfunction HTTPGet(url\x2C opts) {\n  const http = require('http'); // [1]\n  HTTPAgent ??= new http.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return http.get(url\x2C {\n    agent: HTTPAgent\x2C\n    ...opts\x2C\n  });\n}\n\nfunction dnsLookup(name\x2C opts) {\n  // eslint-disable-next-line no-func-assign\n  dnsLookup = require('dns/promises').lookup;\n  return dnsLookup(name\x2C opts);\n}\n\nlet zlib;\nfunction createBrotliDecompress() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createBrotliDecompress = zlib.createBrotliDecompress;\n  return createBrotliDecompress();\n}\n\nfunction createUnzip() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createUnzip = zlib.createUnzip;\n  return createUnzip();\n}\n\n/**\n * @param {URL} parsed\n * @returns {Promise<CacheEntry> | CacheEntry}\n */\nfunction fetchWithRedirects(parsed) {\n  const existing = cacheForGET.get(parsed.href);\n  if (existing) {\n    return existing;\n  }\n  const handler = parsed.protocol === 'http:' ? HTTPGet : HTTPSGet;\n  const result = (async () => {\n    const req = handler(parsed\x2C {\n      headers: { Accept: '*/*' }\x2C\n    });\n    // Note that `once` is used here to handle `error` and that it hits the\n    // `finally` on network error/timeout.\n    const { 0: res } = await once(req\x2C 'response');\n    try {\n      const isRedirect = res.statusCode >= 300 && res.statusCode <= 303;\n      const hasLocation = ObjectPrototypeHasOwnProperty(res.headers\x2C 'location');\n      if (isRedirect && hasLocation) {\n        const location = new URL(res.headers.location\x2C parsed);\n        if (location.protocol !== 'http:' && location.protocol !== 'https:') {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            res.headers.location\x2C\n            parsed.href\x2C\n            'cannot redirect to non-network location'\n          );\n        }\n        const entry = await fetchWithRedirects(location);\n        cacheForGET.set(parsed.href\x2C entry);\n        return entry;\n      }\n      if (res.statusCode === 404) {\n        const err = new ERR_MODULE_NOT_FOUND(parsed.href\x2C null);\n        err.message = `Cannot find module '${parsed.href}'\x2C HTTP 404`;\n        throw err;\n      }\n      if (res.statusCode > 303 || res.statusCode < 200) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          res.headers.location\x2C\n          parsed.href\x2C\n          'cannot redirect to non-network location');\n      }\n      const { headers } = res;\n      const contentType = headers['content-type'];\n      if (!contentType) {\n        throw new ERR_NETWORK_IMPORT_BAD_RESPONSE(\n          parsed.href\x2C\n          "the 'Content-Type' header is required"\n        );\n      }\n      /**\n       * @type {CacheEntry}\n       */\n      const entry = {\n        resolvedHREF: parsed.href\x2C\n        headers: {\n          'content-type': res.headers['content-type']\x2C\n        }\x2C\n        body: (async () => {\n          let bodyStream = res;\n          if (res.headers['content-encoding'] === 'br') {\n            bodyStream = compose(res\x2C createBrotliDecompress());\n          } else if (\n            res.headers['content-encoding'] === 'gzip' ||\n            res.headers['content-encoding'] === 'deflate'\n          ) {\n            bodyStream = compose(res\x2C createUnzip());\n          }\n          const buffers = await bodyStream.toArray();\n          const body = BufferConcat(buffers);\n          entry.body = body;\n          return body;\n        })()\x2C\n      };\n      cacheForGET.set(parsed.href\x2C entry);\n      await entry.body;\n      return entry;\n    } finally {\n      req.destroy();\n    }\n  })();\n  cacheForGET.set(parsed.href\x2C result);\n  return result;\n}\n\nconst allowList = new net.BlockList();\nallowList.addAddress('::1'\x2C 'ipv6');\nallowList.addRange('127.0.0.1'\x2C '127.255.255.255');\n\n/**\n * Returns if an address has local status by if it is going to a local\n * interface or is an address resolved by DNS to be a local interface\n * @param {string} hostname url.hostname to test\n * @returns {Promise<boolean>}\n */\nasync function isLocalAddress(hostname) {\n  try {\n    if (\n      StringPrototypeStartsWith(hostname\x2C '[') &&\n      StringPrototypeEndsWith(hostname\x2C ']')\n    ) {\n      hostname = StringPrototypeSlice(hostname\x2C 1\x2C -1);\n    }\n    const addr = await dnsLookup(hostname\x2C { verbatim: true });\n    const ipv = addr.family === 4 ? 'ipv4' : 'ipv6';\n    return allowList.check(addr.address\x2C ipv);\n  } catch {\n    // If it errored\x2C the answer is no.\n  }\n  return false;\n}\n\n/**\n * Fetches a location with a shared cache following redirects.\n * Does not respect HTTP cache headers.\n *\n * This splits the header and body Promises so that things only needing\n * headers don't need to wait on the body.\n *\n * In cases where the request & response have already settled\x2C this returns the\n * cache value synchronously.\n *\n * @param {URL} parsed\n * @param {ESModuleContext} context\n * @returns {ReturnType<typeof fetchWithRedirects>}\n */\nfunction fetchModule(parsed\x2C { parentURL }) {\n  const { href } = parsed;\n  const existing = cacheForGET.get(href);\n  if (existing) {\n    return existing;\n  }\n  if (parsed.protocol === 'http:') {\n    return PromisePrototypeThen(isLocalAddress(parsed.hostname)\x2C (is) => {\n      if (is !== true) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          href\x2C\n          parentURL\x2C\n          'http can only be used to load local resources (use https instead).'\n        );\n      }\n      return fetchWithRedirects(parsed);\n    });\n  }\n  return fetchWithRedirects(parsed);\n}\n\nmodule.exports = {\n  fetchModule: fetchModule\x2C\n};\n
code-source-info,0x25349b141d4e,112,0,7132,C0O0C4O7132,,
code-creation,Function,10,60639,0x25349b1421ae,349, node:internal/modules/esm/fetch_module:1:1,0x25349b141cc8,~
code-source-info,0x25349b1421ae,112,0,7132,C0O0C107O24C113O57C119O81C124O92C130O119C136O143C142O235C148O235C153O235C158O215C164O358C170O358C175O384C180O264C186O297C192O332C198O408C204O408C209O400C215O445C221O445C226O478C232O478C237O469C243O517C249O517C254O505C260O1093C262O1093C267O1093C269O1383C270O1383C272O1611C273O1611C275O1990C276O1990C278O5259C283O5251C288O5251C290O5272C293O5282C304O5282C310O5309C313O5319C324O5319C330O7082C337O7116C343O7097C348O7131,,
tick,0x1192e05,61245,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b14228b,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,61910,0x25349b14490e,5, node:net:1:1,0x25349b1440e0,~
script-source,113,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  Boolean\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  genericNodeError\x2C\n  uvExceptionWithHostPort\x2C\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nconst kPerfHooksNetConnectContext = Symbol('kPerfHooksNetConnectContext');\nconst {\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        value: 0\x2C writable: true\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\n        self._readableState);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party'\x2C\n    { code: 'EPIPE' }\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable\x2C initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (this._handle.setKeepAlive && enable !== this[kSetKeepAlive]) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable\x2C initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  get: function() {\n    return this.connecting;\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close'\x2C isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    this._peername = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getpeername(this._peername);\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  } else if (addressType === 6 || addressType === 4) {\n    startPerf(self\x2C kPerfHooksNetConnectContext\x2C { type: 'net'\x2C name: 'connect'\x2C detail: { host: address\x2C port } });\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: options.family\x2C\n    hints: options.hints || 0\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true\x2C self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n    stopPerf(self\x2C kPerfHooksNetConnectContext);\n  } else {\n    self.connecting = false;\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n    backlog\x2C\n  };\n\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C pipeName\x2C -1\x2C -1\x2C\n                    backlog\x2C undefined\x2C options.exclusive);\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\n  });\n\n  if (self.noDelay && handle.setNoDelay) {\n    handle.setNoDelay(true);\n  }\n\n  if (self.keepAlive && self.setKeepAlive) {\n    handle.setKeepAlive(true\x2C handle.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0x25349b14490e,113,0,49559,C0O0C4O49559,,
code-creation,Function,10,64525,0x25349b14780e,2605, node:net:1:1,0x25349b144888,~
code-source-info,0x25349b14780e,113,0,49559,C0O0C426O1159C432O1175C438O1200C444O1211C450O1221C456O1236C462O1254C468O1278C473O1302C478O1349C484O1349C488O1349C490O1383C496O1383C500O1383C502O1414C508O1414C513O1447C527O1448C533O1414C535O1572C541O1572C546O1502C552O1510C557O1520C562O1530C568O1554C574O1612C580O1612C584O1612C586O1696C589O1696C594O1650C600O1667C606O1680C612O1739C618O1739C623O1728C629O1786C632O1786C637O1766C643O1836C646O1836C651O1819C657O1931C660O1931C665O1878C671O1885C677O1914C683O2026C686O2026C691O1970C697O1978C703O2008C709O2157C715O2157C720O2066C726O2080C737O2121C743O2138C749O2355C755O2355C760O2200C766O2217C772O2233C778O2249C783O2269C789O2280C794O2296C799O2316C805O2327C811O2340C817O2756C823O2756C828O2756C833O2419C839O2451C845O2477C851O2504C857O2529C863O2557C869O2588C875O2616C881O2639C887O2664C893O2682C899O2707C905O2727C911O2809C917O2809C922O2792C928O2964C934O2964C939O2851C945O2874C951O2894C957O2911C963O2929C969O2945C975O3024C978O3024C982O3024C984O3122C990O3122C995O3064C1001O3096C1007O3202C1008O3202C1010O3215C1011O3215C1013O3224C1014O3224C1016O3239C1017O3239C1019O3280C1025O3280C1030O3263C1036O3320C1042O3320C1047O3307C1053O3375C1055O3375C1057O3412C1059O3412C1061O3437C1064O3445C1071O3454C1074O3437C1076O3481C1080O3481C1082O3528C1085O3528C1089O3528C1091O3604C1097O3604C1102O3577C1108O3590C1114O7080C1117O7080C1121O7080C1123O7124C1126O7124C1130O7124C1132O7169C1135O7169C1139O7169C1141O7214C1144O7214C1148O7214C1150O7273C1153O7273C1157O7273C1159O11785C1162O11813C1170O11831C1175O11838C1180O11785C1185O11850C1191O11886C1196O11850C1201O11926C1204O11933C1213O11955C1217O12181C1220O12188C1229O12205C1233O13717C1236O13724C1243O13745C1247O13767C1250O13774C1259O13795C1263O14305C1266O14312C1275O14333C1279O14716C1282O14723C1291O14746C1295O15232C1298O15239C1307O15257C1311O15307C1317O15335C1331O15370C1339O15307C1344O15420C1350O15448C1364O15474C1372O15420C1377O15559C1383O15587C1397O15621C1405O15559C1410O15943C1416O15971C1430O16005C1438O15943C1443O16091C1449O16119C1454O16130C1460O16153C1471O16091C1476O16518C1479O16525C1488O16541C1492O16776C1495O16783C1504O16797C1508O16990C1511O16997C1520O17013C1524O17353C1527O17360C1536O17377C1540O17567C1543O17574C1552O17589C1556O17926C1559O17933C1568O17955C1576O18108C1579O18115C1588O18134C1596O19093C1599O19100C1608O19123C1616O19584C1624O19584C1634O19704C1642O19704C1652O19803C1660O19803C1670O19899C1678O19899C1688O19990C1691O19997C1700O20020C1708O20302C1716O20302C1726O20400C1734O20400C1744O20489C1747O20496C1752O20506C1756O20524C1764O20576C1767O20583C1776O20607C1784O21374C1787O21381C1796O21399C1804O21473C1807O21480C1816O21497C1824O21741C1832O21741C1842O21881C1850O21881C1860O25525C1863O25532C1872O25550C1880O29951C1883O29958C1892O29972C1900O30165C1903O30172C1912O30188C1920O33628C1923O33656C1935O33680C1944O33628C1954O33692C1960O33692C1970O37678C1973O37685C1984O37704C1992O39165C1995O39172C2008O39189C2016O43146C2022O43174C2043O43207C2055O43146C2065O43298C2068O43305C2081O43323C2089O44581C2092O44588C2105O44613C2113O45372C2116O45379C2129O45395C2137O46267C2140O46274C2153O46304C2161O46782C2164O46789C2176O46812C2189O46836C2197O47154C2203O47179C2224O47203C2236O47243C2248O47154C2258O47290C2264O47318C2281O47344C2293O47379C2305O47290C2315O47421C2318O47428C2331O47451C2339O47697C2342O47704C2355O47718C2363O47821C2366O47828C2379O47844C2387O47952C2389O48007C2390O48007C2392O48014C2403O48037C2404O48037C2406O48061C2415O48769C2420O49041C2430O49083C2440O49121C2450O49138C2460O49397C2470O49426C2480O49437C2490O49459C2500O49475C2510O49493C2520O49503C2530O49513C2540O49531C2595O49056C2604O49558,,
tick,0x7f0810b84300,64659,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b14228b,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810b843d2,64674,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b14228b,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810fb3696,64681,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b14228b,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,64976,0x25349b14d236,5, node:internal/net:1:1,0x25349b14d070,~
script-source,114,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n
code-source-info,0x25349b14d236,114,0,1749,C0O0C4O1749,,
code-creation,Function,10,65091,0x25349b14d626,617, node:internal/net:1:1,0x25349b14d1b0,~
code-source-info,0x25349b14d626,114,0,1749,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O1633C576O1654C582O1662C588O1672C594O1682C601O1721C611O1648C616O1748,,
code-creation,Eval,10,65413,0x25349b150886,5, node:internal/dtrace:1:1,0x25349b150740,~
script-source,115,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n};\n
code-source-info,0x25349b150886,115,0,568,C0O0C4O568,,
code-creation,Function,10,65491,0x25349b150d5e,140, node:internal/dtrace:1:1,0x25349b150800,~
code-source-info,0x25349b150d5e,115,0,568,C0O30C3O30C8O322C17O334C25O68C36O109C47O151C58O192C69O234C80O277C91O368C98O389C104O419C110O450C116O480C122O511C128O543C134O383C139O567,,
tick,0x129c377,65513,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b147bec,0x7f07fc043395,0x7f07fc0439d1,0x25349b14228b,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,LazyCompile,10,65778,0x25349b15158e,34,protoGetter node:net:746:21,0x25349b144d50,~
code-source-info,0x25349b15158e,113,19442,19582,C0O19463C8O19491C13O19502C20O19566C27O19463C33O19581,,
code-creation,LazyCompile,10,65890,0x25349b155716,37,get BlockList node:net:1834:16,0x25349b146c80,~
code-source-info,0x25349b155716,113,49178,49267,C0O49187C14O49201C19O49230C26O49197C32O49246C36O49263,,
code-creation,Eval,10,66082,0x25349b155c1e,5, node:internal/blocklist:1:1,0x25349b155a38,~
script-source,116,node:internal/blocklist,'use strict';\n\nconst {\n  Boolean\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\n} = primordials;\n\nconst {\n  BlockList: BlockListHandle\x2C\n} = internalBinding('block_list');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  SocketAddress\x2C\n  kHandle: kSocketAddressHandle\x2C\n} = require('internal/socketaddress');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst kHandle = Symbol('kHandle');\nconst { owner_symbol } = internalBinding('symbols');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\n\nconst { validateInt32\x2C validateString } = require('internal/validators');\n\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `BlockList ${inspect({\n      rules: this.rules\n    }\x2C opts)}`;\n  }\n\n  addAddress(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      address = new SocketAddress({\n        address\x2C\n        family\x2C\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n\n  addRange(start\x2C end\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start\x2C 'start');\n      validateString(family\x2C 'family');\n      start = new SocketAddress({\n        address: start\x2C\n        family\x2C\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end\x2C 'end');\n      validateString(family\x2C 'family');\n      end = new SocketAddress({\n        address: end\x2C\n        family\x2C\n      });\n    }\n    const ret = this[kHandle].addRange(\n      start[kSocketAddressHandle]\x2C\n      end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\n  }\n\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network\x2C 'network');\n      validateString(family\x2C 'family');\n      network = new SocketAddress({\n        address: network\x2C\n        family\x2C\n      });\n    }\n    switch (network.family) {\n      case 'ipv4':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\n        break;\n      case 'ipv6':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\n  }\n\n  check(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      try {\n        address = new SocketAddress({\n          address\x2C\n          family\x2C\n        });\n      } catch {\n        // Ignore the error. If it's not a valid address\x2C return false.\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n\n  get rules() {\n    return this[kHandle].getRules();\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\n\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== undefined)\n      handle[owner_symbol] = this;\n  }\n}\n\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\n\nmodule.exports = {\n  BlockList\x2C\n  InternalBlockList\x2C\n};\n
code-source-info,0x25349b155c1e,116,0,3877,C0O0C4O3877,,
code-creation,Function,10,66304,0x25349b156626,359, node:internal/blocklist:1:1,0x25349b155b98,~
code-source-info,0x25349b156626,116,0,3877,C0O0C35O25C41O36C46O60C51O127C54O127C59O106C65O204C68O204C73O190C78O293C81O293C86O241C92O267C98O385C101O385C106O339C111O357C116O367C121O450C124O450C129O438C135O501C138O501C142O501C144O545C147O545C152O528C158O611C161O611C166O637C171O584C177O688C180O688C185O654C191O669C197O745C204O884C241O3223C251O3384C278O3519C301O3691C306O3725C311O3735C315O3713C319O3787C324O3808C329O3748C334O3821C341O3842C347O3855C353O3836C358O3876,,
tick,0x11b4c76,66577,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b156677,0x7f07fc043395,0x7f07fc0439d1,0x25349b155724,0x25349b1422c4,0x7f07fc043395,0x7f07fc0439d1,0xdd57423fa92,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,66624,0x25349b157f6e,5, node:internal/socketaddress:1:1,0x25349b157d78,~
script-source,117,node:internal/socketaddress,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  SocketAddress: _SocketAddress\x2C\n  AF_INET\x2C\n  AF_INET6\x2C\n} = internalBinding('block_list');\n\nconst {\n  validateObject\x2C\n  validateString\x2C\n  validatePort\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst kHandle = Symbol('kHandle');\nconst kDetail = Symbol('kDetail');\n\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== undefined;\n  }\n\n  constructor(options = {}) {\n    super();\n    validateObject(options\x2C 'options');\n    let { family = 'ipv4' } = options;\n    const {\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\n      port = 0\x2C\n      flowlabel = 0\x2C\n    } = options;\n\n    let type;\n    if (typeof family?.toLowerCase === 'function')\n      family = family.toLowerCase();\n    switch (family) {\n      case 'ipv4':\n        type = AF_INET;\n        break;\n      case 'ipv6':\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\n    }\n\n    validateString(address\x2C 'options.address');\n    validatePort(port\x2C 'options.port');\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\n\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  get address() {\n    return this[kDetail].address;\n  }\n\n  get port() {\n    return this[kDetail].port;\n  }\n\n  get family() {\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\n  }\n\n  get flowlabel() {\n    // The flow label can be changed internally.\n    return this[kHandle].flowlabel();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  toJSON() {\n    return {\n      address: this.address\x2C\n      port: this.port\x2C\n      family: this.family\x2C\n      flowlabel: this.flowlabel\x2C\n    };\n  }\n}\n\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\n\nInternalSocketAddress.prototype.constructor =\n  SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\n\nmodule.exports = {\n  SocketAddress\x2C\n  InternalSocketAddress\x2C\n  kHandle\x2C\n};\n
code-source-info,0x25349b157f6e,117,0,3207,C0O0C4O3207,,
code-creation,Function,10,66813,0x25349b158a96,366, node:internal/socketaddress:1:1,0x25349b157ee8,~
code-source-info,0x25349b158a96,117,0,3207,C0O0C38O25C43O49C48O143C51O143C56O100C62O118C68O129C74O257C77O257C82O185C88O203C94O221C100O237C106O345C109O345C114O345C119O313C125O419C128O419C133O405C138O466C141O466C146O454C152O557C155O557C160O511C165O529C170O539C175O618C178O618C182O618C184O653C187O653C191O653C193O701C226O2071C236O2313C246O2482C279O2877C302O2988C307O3028C312O3038C316O3010C320O3094C325O3119C330O3051C335O3132C342O3153C348O3170C354O3195C360O3147C365O3206,,
code-creation,LazyCompile,10,66988,0x25349b159846,72,BlockList node:internal/blocklist:40:14,0x25349b155c50,~
code-source-info,0x25349b159846,116,775,879,C3O784C11O784C23O797C28O802C33O817C36O813C41O811C45O840C50O845C52O844C58O854C64O868C71O878,,
code-creation,LazyCompile,10,67061,0x25349b159fee,115,addAddress node:internal/blocklist:60:13,0x25349b155cf0,~
code-source-info,0x25349b159fee,116,1149,1460,C14O1182C19O1201C24O1201C31O1235C39O1235C44O1277C52O1277C57O1317C69O1355C75O1372C81O1327C87O1400C89O1405C91O1404C95O1414C102O1433C104O1432C108O1414C114O1459,,
code-creation,LazyCompile,10,67104,0x25349b15a16e,20,isSocketAddress node:internal/socketaddress:43:25,0x25349b157ff0,~
code-source-info,0x25349b15a16e,117,742,798,C0O756C9O771C11O770C18O780C19O794,,
code-creation,LazyCompile,10,67197,0x25349b15a906,323,SocketAddress node:internal/socketaddress:47:14,0x25349b157fa0,~
code-source-info,0x25349b15a906,117,813,1761,C7O813C13O834C21O834C33O847C41O847C46O893C58O940C69O958C81O998C89O1014C97O1055C99O1065C106O1082C117O1134C122O1134C127O1153C146O1198C151O1222C153O1256C158O1281C160O1311C168O1369C175O1317C180O1311C181O1389C189O1389C194O1437C202O1437C207O1477C220O1477C225O1537C230O1542C235O1557C252O1553C257O1551C261O1609C266O1614C274O1630C276O1629C280O1639C291O1663C296O1686C301O1711C306O1739C310O1639C315O1623C322O1760,,
code-creation,LazyCompile,10,67267,0x25349b15ac56,99, node:internal/validators:154:3,0x2842ea0bc218,~
code-source-info,0x25349b15ac56,15,4372,4931,C0O4430C4O4470C9O4506C14O4544C21O4580C26O4616C33O4652C38O4666C46O4713C50O4727C53O4727C67O4802C75O4867C91O4873C96O4867C98O4930,,
code-creation,LazyCompile,10,67334,0x25349b15ae06,129,validatePort node:internal/validators:211:22,0x2842ea0bc3f0,~
code-source-info,0x25349b15ae06,15,6402,6760,C24O6446C44O6543C47O6543C52O6568C58O6576C65O6592C70O6603C72O6609C75O6598C86O6630C92O6654C99O6664C101O6682C117O6688C122O6682C123O6742C125O6754C128O6758,,
code-creation,LazyCompile,10,67391,0x25349b15b056,149, node:internal/validators:101:40,0x2842ea0bc018,~
code-source-info,0x25349b15b056,15,2874,3378,C0O2905C6O2942C22O2948C27O2942C28O3003C31O3008C37O3031C42O3036C48O3068C64O3074C69O3068C70O3145C80O3197C90O3236C109O3203C114O3197C115O3273C120O3295C125O3308C141O3314C146O3308C148O3377,,
code-creation,LazyCompile,10,67422,0x25349b15b1de,9,isUint32 node:internal/validators:40:18,0x2842ea0bbeb8,~
code-source-info,0x25349b15b1de,15,796,841,C0O808C2O832C5O821C8O839,,
code-creation,LazyCompile,10,67512,0x25349b15b6d6,229,addRange node:internal/blocklist:72:11,0x25349b155d40,~
code-source-info,0x25349b15b6d6,116,1472,2142,C17O1508C22O1527C27O1527C34O1559C42O1559C47O1597C55O1597C60O1637C72O1682C78O1697C84O1645C90O1725C95O1744C100O1744C107O1774C115O1774C120O1808C128O1808C133O1848C145O1891C151O1904C157O1854C163O1944C165O1949C167O1948C171O1958C178O1980C180O1979C186O2013C188O2012C192O1958C199O2041C200O2049C205O2066C221O2072C226O2066C228O2141,,
tick,0xd6ac80,67643,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0xdd57423faa0,0x7f07fc043395,0x7f07fc0439d1,0x109acf0bce50,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b45d9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,67677,0x25349b15bca6,5, node:internal/modules/esm/formats:1:1,0x25349b15bb30,~
script-source,118,node:internal/modules/esm/formats,'use strict';\n\nconst {\n  RegExpPrototypeTest\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n\n\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.json': 'json'\x2C\n  '.mjs': 'module'\x2C\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\x2C\n};\n\nif (experimentalWasmModules) {\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n}\n\n/**\n * @param {string} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    RegExpPrototypeTest(\n      /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i\x2C\n      mime\n    )\n  ) return 'module';\n  if (mime === 'application/json') return 'json';\n  if (experimentalWasmModules && mime === 'application/wasm') return 'wasm';\n  return null;\n}\n\nfunction getLegacyExtensionFormat(ext) {\n  return legacyExtensionFormatMap[ext];\n}\n\nmodule.exports = {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  legacyExtensionFormatMap\x2C\n  mimeToFormat\x2C\n};\n
code-source-info,0x25349b15bca6,118,0,1190,C0O0C4O1190,,
code-creation,Function,10,67763,0x25349b15bf5e,120, node:internal/modules/esm/formats:1:1,0x25349b15bc20,~
code-source-info,0x25349b15bf5e,118,0,1190,C0O0C24O25C30O90C33O90C38O71C43O153C46O153C50O153C52O228C57O368C61O368C63O504C67O537C73O601C79O565C83O1074C90O1095C96O1117C102O1145C108O1173C114O1089C119O1189,,
code-creation,Eval,10,67921,0x25349b15c6c6,5, node:internal/modules/esm/initialize_import_meta:1:1,0x25349b15c530,~
script-source,119,node:internal/modules/esm/initialize_import_meta,'use strict';\n\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n  getOptionValue('--experimental-import-meta-resolve');\nconst {\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n} = primordials;\nconst asyncESM = require('internal/process/esm_loader');\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\n/**\n * @param {object} meta\n * @param {{url: string}} context\n */\nfunction initializeImportMeta(meta\x2C context) {\n  let url = context.url;\n\n  // Alphabetical\n  if (experimentalImportMetaResolve) {\n    meta.resolve = createImportMetaResolve(url);\n  }\n\n  url = asyncESM.esmLoader.getBaseURL(url);\n\n  meta.url = url;\n}\n\nmodule.exports = {\n  initializeImportMeta\n};\n
code-source-info,0x25349b15c6c6,119,0,1023,C0O0C4O1023,,
code-creation,Function,10,67995,0x25349b15c88e,90, node:internal/modules/esm/initialize_import_meta:1:1,0x25349b15c640,~
code-source-info,0x25349b15c88e,119,0,1023,C0O0C28O42C31O42C36O23C41O111C44O111C48O111C50O175C56O199C62O248C65O248C69O248C71O978C78O999C84O993C89O1022,,
code-creation,Eval,10,68108,0x25349b15cda6,5, node:internal/modules/esm/load:1:1,0x25349b15cc30,~
script-source,120,node:internal/modules/esm/load,'use strict';\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\nconst { validateAssertions } = require('internal/modules/esm/assert');\n\n/**\n * Node.js default load hook.\n * @param {string} url\n * @param {object} context\n * @returns {object}\n */\nasync function defaultLoad(url\x2C context) {\n  const { importAssertions } = context;\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (format == null) {\n    format = await defaultGetFormat(url\x2C context);\n  }\n\n  validateAssertions(url\x2C format\x2C importAssertions);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url\x2C context);\n  }\n\n  return {\n    format\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x25349b15cda6,120,0,860,C0O0C4O860,,
code-creation,Function,10,68173,0x25349b15ceee,80, node:internal/modules/esm/load:1:1,0x25349b15cd20,~
code-source-info,0x25349b15ceee,120,0,860,C0O0C19O44C22O44C27O23C33O117C36O117C41O96C47O192C50O192C55O169C61O823C68O844C74O838C79O859,,
code-creation,Eval,10,68313,0x25349b15d4e6,5, node:internal/modules/esm/get_source:1:1,0x25349b15d2e0,~
script-source,121,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  ArrayPrototypeConcat\x2C\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\n\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\n\nconst { Buffer: { from: BufferFrom } } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C context\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = BufferFrom(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else if (experimentalNetworkImports && (\n    parsed.protocol === 'https:' ||\n    parsed.protocol === 'http:'\n  )) {\n    const res = await fetchModule(parsed\x2C context);\n    source = await res.body;\n  } else {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C ArrayPrototypeConcat([\n      'file'\x2C\n      'data'\x2C\n      experimentalNetworkImports ? ['https'\x2C 'http'] : []\x2C\n    ]));\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x25349b15d4e6,121,0,1869,C0O0C4O1869,,
code-creation,Function,10,68441,0x25349b15d67e,212, node:internal/modules/esm/get_source:1:1,0x25349b15d460,~
code-source-info,0x25349b15d67e,121,0,1869,C0O0C46O25C52O49C58O72C64O136C67O136C72O117C77O189C80O189C85O173C91O302C94O302C103O346C110O302C112O428C115O428C119O428C121O520C124O520C129O520C134O503C140O551C143O551C148O582C153O608C156O608C161O600C167O698C170O698C175O724C180O643C186O662C192O757C196O754C198O793C202O793C204O1824C206O1849C211O1868,,
tick,0x12a604f,68711,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,69318,0x25349b15ecc6,5, node:internal/fs/promises:1:1,0x25349b15e4a8,~
script-source,122,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  ObjectCreate\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst {\n  newReadableStreamFromStreamBase\x2C\n} = require('internal/webstreams/adapters');\n\nconst {\n  readableStreamCancel\x2C\n} = require('internal/webstreams/readablestream');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  };\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @returns {ReadableStream}\n   */\n  readableWebStream() {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    const readable = newReadableStreamFromStreamBase(\n      this[kHandle]\x2C\n      undefined\x2C\n      { ondone: () => this[kUnref]() });\n\n    this[kRef]();\n    this.once('close'\x2C () => {\n      readableStreamCancel(readable);\n    });\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\n      )\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    bufferOrOptions ??= ObjectCreate(null);\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = bufferOrOptions);\n\n    validateBuffer(buffer);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  if (buffers.length === 0) {\n    return { bytesWritten: 0\x2C buffers };\n  }\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validatePrimitiveStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x25349b15ecc6,122,0,24198,C0O0C4O24198,,
code-creation,Function,10,70598,0x25349b1614f6,1802, node:internal/fs/promises:1:1,0x25349b15ec40,~
code-source-info,0x25349b1614f6,122,0,24198,C0O0C517O25C523O47C529O56C535O67C541O78C547O94C553O117C559O128C565O152C571O170C577O187C583O208C589O239C594O249C600O344C604O344C610O372C616O289C622O297C628O310C634O322C640O332C646O393C650O393C654O393C656O435C664O435C670O424C676O628C684O628C690O628C696O478C702O505C708O532C714O555C720O590C726O604C732O686C740O686C746O664C752O745C760O745C766O726C772O1387C780O1387C786O1387C792O803C798O821C804O837C810O864C816O898C822O929C828O943C834O972C839O986C845O1000C851O1023C857O1043C863O1059C869O1072C875O1104C881O1121C887O1144C893O1163C899O1186C905O1207C911O1235C917O1264C922O1285C928O1309C934O1356C940O1437C948O1437C954O1425C959O1611C967O1611C973O1475C979O1492C985O1515C991O1534C997O1552C1003O1572C1009O1591C1015O1662C1023O1662C1027O1662C1029O1719C1037O1719C1043O1687C1049O1705C1054O1775C1062O1775C1068O1753C1073O1827C1081O1827C1087O1817C1092O1883C1100O1883C1106O1868C1112O1933C1120O1933C1124O1933C1126O1978C1130O1978C1134O1978C1136O2009C1140O2009C1144O2009C1146O2038C1150O2038C1154O2038C1156O2077C1160O2077C1164O2077C1166O2124C1170O2124C1174O2124C1176O2170C1180O2170C1184O2170C1186O2207C1190O2207C1194O2207C1196O2238C1200O2238C1204O2238C1206O2272C1210O2272C1214O2272C1216O2317C1220O2300C1226O2395C1234O2395C1240O2336C1245O2352C1250O2366C1255O2377C1260O2487C1268O2487C1274O2450C1280O2565C1288O2565C1294O2539C1300O2648C1304O2648C1306O2704C1310O2704C1312O2739C1313O2739C1315O2894C1316O2894C1318O3015C1446O6862C1456O7265C1466O7322C1478O7413C1488O7450C1520O2990C1522O23755C1528O23785C1536O23791C1542O23803C1548O23817C1554O23825C1558O23844C1568O23868C1574O23880C1580O23894C1586O23902C1592O23913C1598O23924C1604O23937C1610O23951C1616O23964C1622O23975C1628O23985C1634O23995C1640O24007C1646O24018C1652O24030C1662O24042C1672O24053C1682O24065C1692O24078C1702O24092C1712O24105C1722O24120C1732O24136C1742O24150C1762O24165C1772O24179C1782O24187C1792O23770C1801O24197,,
code-creation,Function,10,70654,0x25349b161f4e,27,<instance_members_initializer> node:internal/fs/promises:202:3,0x25349b160340,~
code-source-info,0x25349b161f4e,122,4497,5295,C0O4497C12O4505C26O5295,,
tick,0x7f0810b84473,70696,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x129be35,70842,1,0xb83830,6,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,71087,0x25349b164bde,5, node:internal/fs/rimraf:1:1,0x25349b164878,~
script-source,123,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x25349b164bde,123,0,7453,C0O0C4O7453,,
code-creation,Function,10,71476,0x25349b1651de,409, node:internal/fs/rimraf:1:1,0x25349b164b58,~
code-source-info,0x25349b1651de,123,0,7453,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7396C385O7415C391O7423C397O7439C403O7411C408O7452,,
code-creation,LazyCompile,10,71711,0x25349b1660de,188,from node:buffer:298:28,0x136fed731f30,~
script-source,24,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\n// Refs: https://infra.spec.whatwg.org/#forgiving-base64-decode\nconst kForgivingBase64AllowedChars = [\n  // ASCII whitespace\n  // Refs: https://infra.spec.whatwg.org/#ascii-whitespace\n  0x09\x2C 0x0A\x2C 0x0C\x2C 0x0D\x2C 0x20\x2C\n\n  // Uppercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('A') + i)\x2C\n\n  // Lowercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('a') + i)\x2C\n\n  // Decimal digits\n  ...ArrayFrom({ length: 10 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('0') + i)\x2C\n\n  0x2B\x2C // +\n  0x2F\x2C // /\n  0x3D\x2C // =\n];\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!ArrayPrototypeIncludes(kForgivingBase64AllowedChars\x2C\n                                StringPrototypeCharCodeAt(input\x2C n)))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0x25349b1660de,24,8479,9430,C3O8517C9O8552C12O8559C17O8595C18O8599C28O8654C33O8658C39O8689C51O8696C56O8745C57O8773C63O8790C68O8790C73O8805C78O8844C95O8935C104O8942C109O8982C110O9004C113O9004C118O9027C120O9040C122O9049C123O9055C125O9072C127O9071C134O9133C136O9139C138O9138C145O9157C151O9175C155O9220C158O9227C163O9267C164O9289C182O9295C187O9289,,
tick,0x7f0810b9063c,73640,0,0x0,3,0x1229670,0x25349b165351,0x7f07fc043395,0x7f07fc0439d1,0x25349b1617ee,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x129c370,73655,0,0x0,3,0x1229670,0x25349b165351,0x7f07fc043395,0x7f07fc0439d1,0x25349b1617ee,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,LazyCompile,10,73668,0x25349b168bae,110,fromString node:buffer:434:20,0x136fed732318,~
code-source-info,0x25349b168bae,24,12530,12964,C0O12557C2O12564C8O12609C14O12616C19O12640C25O12647C30O12660C35O12667C40O12684C41O12689C46O12707C51O12717C56O12754C59O12760C64O12790C66O12819C73O12825C78O12819C79O12876C85O12883C90O12896C95O12903C100O12920C101O12927C104O12934C109O12962,,
code-creation,LazyCompile,10,73736,0x25349b168d66,177,fromStringFast node:buffer:415:24,0x136fed732278,~
code-source-info,0x25349b168d66,24,11986,12509,C0O12023C5O12023C11O12046C14O12068C18O12077C21O12057C26O12089C31O12125C36O12096C41O12138C42O12142C44O12156C49O12167C51O12165C54O12153C59O12184C62O12184C65O12208C72O12223C77O12234C85O12208C91O12276C110O12276C116O12307C118O12318C123O12402C130O12421C135O12432C143O12406C149O12459C156O12473C162O12470C168O12483C171O12483C174O12498C176O12507,,
code-creation,LazyCompile,10,73778,0x25349b168f56,36,FastBuffer node:internal/buffer:958:14,0x136fed73eea8,~
code-source-info,0x25349b168f56,25,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,73811,0x25349b169056,23,write node:buffer:595:12,0x136fed732688,~
code-source-info,0x25349b169056,24,16598,16662,C0O16632C17O16632C22O16662,,
code-creation,LazyCompile,10,73845,0x25349b169146,42,alignPool node:buffer:161:19,0x136fed731cb0,~
code-source-info,0x25349b169146,24,4071,4175,C0O4105C4O4120C9O4133C19O4144C25O4156C34O4166C41O4174,,
tick,0xd4ec6e,74040,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,74411,0x25349b169f66,5, node:internal/webstreams/adapters:1:1,0x25349b169ba0,~
script-source,124,node:internal/webstreams/adapters,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  PromiseAll\x2C\n  PromisePrototypeThen\x2C\n  PromisePrototypeFinally\x2C\n  PromiseResolve\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ReadableStream\x2C\n  isReadableStream\x2C\n} = require('internal/webstreams/readablestream');\n\nconst {\n  WritableStream\x2C\n  isWritableStream\x2C\n} = require('internal/webstreams/writablestream');\n\nconst {\n  CountQueuingStrategy\x2C\n} = require('internal/webstreams/queuingstrategies');\n\nconst {\n  Writable\x2C\n  Readable\x2C\n  Duplex\x2C\n  destroy\x2C\n} = require('stream');\n\nconst {\n  isDestroyed\x2C\n  isReadable\x2C\n  isReadableEnded\x2C\n  isWritable\x2C\n  isWritableEnded\x2C\n} = require('internal/streams/utils');\n\nconst {\n  Buffer\x2C\n} = require('buffer');\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_STREAM_PREMATURE_CLOSE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  createDeferredPromise\x2C\n} = require('internal/util');\n\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  WriteWrap\x2C\n  ShutdownWrap\x2C\n  kReadBytesOrError\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\x2C\n} = internalBinding('stream_wrap');\n\nconst finished = require('internal/streams/end-of-stream');\n\nconst { UV_EOF } = internalBinding('uv');\n\n/**\n * @typedef {import('../../stream').Writable} Writable\n * @typedef {import('../../stream').Readable} Readable\n * @typedef {import('./writablestream').WritableStream} WritableStream\n * @typedef {import('./readablestream').ReadableStream} ReadableStream\n */\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n */\n\n/**\n * @param {Writable} streamWritable\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamWritable(streamWritable) {\n  // Not using the internal/streams/utils isWritableNodeStream utility\n  // here because it will return false if streamWritable is a Duplex\n  // whose writable option is false. For a Duplex that is not writable\x2C\n  // we want it to pass this check but return a closed WritableStream.\n  if (typeof streamWritable?._writableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamWritable'\x2C\n      'stream.Writable'\x2C\n      streamWritable);\n  }\n\n  if (isDestroyed(streamWritable) || !isWritable(streamWritable)) {\n    const writable = new WritableStream();\n    writable.close();\n    return writable;\n  }\n\n  const highWaterMark = streamWritable.writableHighWaterMark;\n  const strategy =\n    streamWritable.writableObjectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n  let backpressurePromise;\n  let closed;\n\n  function onDrain() {\n    if (backpressurePromise !== undefined)\n      backpressurePromise.resolve();\n  }\n\n  const cleanup = finished(streamWritable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError(undefined\x2C { cause: error });\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamWritable.on('error'\x2C () => {});\n    if (error != null) {\n      if (backpressurePromise !== undefined)\n        backpressurePromise.reject(error);\n      // If closed is not undefined\x2C the error is happening\n      // after the WritableStream close has already started.\n      // We need to reject it here.\n      if (closed !== undefined) {\n        closed.reject(error);\n        closed = undefined;\n      }\n      controller.error(error);\n      controller = undefined;\n      return;\n    }\n\n    if (closed !== undefined) {\n      closed.resolve();\n      closed = undefined;\n      return;\n    }\n    controller.error(new AbortError());\n    controller = undefined;\n  });\n\n  streamWritable.on('drain'\x2C onDrain);\n\n  return new WritableStream({\n    start(c) { controller = c; }\x2C\n\n    async write(chunk) {\n      if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {\n        backpressurePromise = createDeferredPromise();\n        return PromisePrototypeFinally(\n          backpressurePromise.promise\x2C () => {\n            backpressurePromise = undefined;\n          });\n      }\n    }\x2C\n\n    abort(reason) {\n      destroy(streamWritable\x2C reason);\n    }\x2C\n\n    close() {\n      if (closed === undefined && !isWritableEnded(streamWritable)) {\n        closed = createDeferredPromise();\n        streamWritable.end();\n        return closed.promise;\n      }\n\n      controller = undefined;\n      return PromiseResolve();\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {WritableStream} writableStream\n * @param {{\n *   decodeStrings? : boolean\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Writable}\n */\nfunction newStreamWritableFromWritableStream(writableStream\x2C options = {}) {\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'writableStream'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    decodeStrings = true\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  validateBoolean(decodeStrings\x2C 'options.decodeStrings');\n\n  const writer = writableStream.getWriter();\n  let closed = false;\n\n  const writable = new Writable({\n    highWaterMark\x2C\n    objectMode\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        error = error.filter((e) => e);\n        try {\n          callback(error.length === 0 ? undefined : error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (data) => writer.write(data.chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(writable\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        if (error != null) {\n          PromisePrototypeThen(\n            writer.abort(error)\x2C\n            done\x2C\n            done);\n        } else {\n          PromisePrototypeThen(\n            writer.close()\x2C\n            done\x2C\n            done);\n        }\n        return;\n      }\n\n      done();\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      // If the WritableStream closes before the stream.Writable has been\n      // ended\x2C we signal an error on the stream.Writable.\n      closed = true;\n      if (!isWritableEnded(writable))\n        destroy(writable\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      // If the WritableStream errors before the stream.Writable has been\n      // destroyed\x2C signal an error on the stream.Writable.\n      closed = true;\n      destroy(writable\x2C error);\n    });\n\n  return writable;\n}\n\n/**\n * @param {Readable} streamReadable\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamReadable(streamReadable) {\n  // Not using the internal/streams/utils isReadableNodeStream utility\n  // here because it will return false if streamReadable is a Duplex\n  // whose readable option is false. For a Duplex that is not readable\x2C\n  // we want it to pass this check but return a closed ReadableStream.\n  if (typeof streamReadable?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamReadable'\x2C\n      'stream.Readable'\x2C\n      streamReadable);\n  }\n\n  if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n\n  const objectMode = streamReadable.readableObjectMode;\n  const highWaterMark = streamReadable.readableHighWaterMark;\n  // When not running in objectMode explicitly\x2C we just fall\n  // back to a minimal strategy that just specifies the highWaterMark\n  // and no size algorithm. Using a ByteLengthQueuingStrategy here\n  // is unnecessary.\n  const strategy =\n    objectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n\n  function onData(chunk) {\n    // Copy the Buffer to detach it from the pool.\n    if (Buffer.isBuffer(chunk) && !objectMode)\n      chunk = new Uint8Array(chunk);\n    controller.enqueue(chunk);\n    if (controller.desiredSize <= 0)\n      streamReadable.pause();\n  }\n\n  streamReadable.pause();\n\n  const cleanup = finished(streamReadable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError(undefined\x2C { cause: error });\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamReadable.on('error'\x2C () => {});\n    if (error)\n      return controller.error(error);\n    controller.close();\n  });\n\n  streamReadable.on('data'\x2C onData);\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() { streamReadable.resume(); }\x2C\n\n    cancel(reason) {\n      destroy(streamReadable\x2C reason);\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {ReadableStream} readableStream\n * @param {{\n *   highWaterMark? : number\x2C\n *   encoding? : string\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Readable}\n */\nfunction newStreamReadableFromReadableStream(readableStream\x2C options = {}) {\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'readableStream'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    encoding\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n  validateBoolean(objectMode\x2C 'options.objectMode');\n\n  const reader = readableStream.getReader();\n  let closed = false;\n\n  const readable = new Readable({\n    objectMode\x2C\n    highWaterMark\x2C\n    encoding\x2C\n    signal\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            // Value should always be undefined here.\n            readable.push(null);\n          } else {\n            readable.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(readable\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          reader.cancel(error)\x2C\n          done\x2C\n          done);\n        return;\n      }\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      closed = true;\n      if (!isReadableEnded(readable))\n        readable.push(null);\n    }\x2C\n    (error) => {\n      closed = true;\n      destroy(readable\x2C error);\n    });\n\n  return readable;\n}\n\n/**\n * @typedef {import('./readablestream').ReadableWritablePair\n * } ReadableWritablePair\n * @typedef {import('../../stream').Duplex} Duplex\n */\n\n/**\n * @param {Duplex} duplex\n * @returns {ReadableWritablePair}\n */\nfunction newReadableWritablePairFromDuplex(duplex) {\n  // Not using the internal/streams/utils isWritableNodeStream and\n  // isReadableNodestream utilities here because they will return false\n  // if the duplex was created with writable or readable options set to\n  // false. Instead\x2C we'll check the readable and writable state after\n  // and return closed WritableStream or closed ReadableStream as\n  // necessary.\n  if (typeof duplex?._writableState !== 'object' ||\n      typeof duplex?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('duplex'\x2C 'stream.Duplex'\x2C duplex);\n  }\n\n  if (isDestroyed(duplex)) {\n    const writable = new WritableStream();\n    const readable = new ReadableStream();\n    writable.close();\n    readable.cancel();\n    return { readable\x2C writable };\n  }\n\n  const writable =\n    isWritable(duplex) ?\n      newWritableStreamFromStreamWritable(duplex) :\n      new WritableStream();\n\n  if (!isWritable(duplex))\n    writable.close();\n\n  const readable =\n    isReadable(duplex) ?\n      newReadableStreamFromStreamReadable(duplex) :\n      new ReadableStream();\n\n  if (!isReadable(duplex))\n    readable.cancel();\n\n  return { writable\x2C readable };\n}\n\n/**\n * @param {ReadableWritablePair} pair\n * @param {{\n *   allowHalfOpen? : boolean\x2C\n *   decodeStrings? : boolean\x2C\n *   encoding? : string\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Duplex}\n */\nfunction newStreamDuplexFromReadableWritablePair(pair = {}\x2C options = {}) {\n  validateObject(pair\x2C 'pair');\n  const {\n    readable: readableStream\x2C\n    writable: writableStream\x2C\n  } = pair;\n\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.readable'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.writable'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    allowHalfOpen = false\x2C\n    objectMode = false\x2C\n    encoding\x2C\n    decodeStrings = true\x2C\n    highWaterMark\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n\n  const writer = writableStream.getWriter();\n  const reader = readableStream.getReader();\n  let writableClosed = false;\n  let readableClosed = false;\n\n  const duplex = new Duplex({\n    allowHalfOpen\x2C\n    highWaterMark\x2C\n    objectMode\x2C\n    encoding\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        error = error.filter((e) => e);\n        try {\n          callback(error.length === 0 ? undefined : error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (data) => writer.write(data.chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(duplex\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      if (!writableClosed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            duplex.push(null);\n          } else {\n            duplex.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(duplex\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      async function closeWriter() {\n        if (!writableClosed)\n          await writer.abort(error);\n      }\n\n      async function closeReader() {\n        if (!readableClosed)\n          await reader.cancel(error);\n      }\n\n      if (!writableClosed || !readableClosed) {\n        PromisePrototypeThen(\n          PromiseAll([\n            closeWriter()\x2C\n            closeReader()\x2C\n          ])\x2C\n          done\x2C\n          done);\n        return;\n      }\n\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      writableClosed = true;\n      if (!isWritableEnded(duplex))\n        destroy(duplex\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      readableClosed = true;\n      if (!isReadableEnded(duplex))\n        duplex.push(null);\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  return duplex;\n}\n\n/**\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {{}} StreamBase\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamBase(streamBase\x2C strategy) {\n  validateObject(streamBase\x2C 'streamBase');\n\n  let current;\n\n  function createWriteWrap(controller\x2C promise) {\n    const req = new WriteWrap();\n    req.handle = streamBase;\n    req.oncomplete = onWriteComplete;\n    req.async = false;\n    req.bytes = 0;\n    req.buffer = null;\n    req.controller = controller;\n    req.promise = promise;\n    return req;\n  }\n\n  function onWriteComplete(status) {\n    if (status < 0) {\n      const error = errnoException(status\x2C 'write'\x2C this.error);\n      this.promise.reject(error);\n      this.controller.error(error);\n      return;\n    }\n    this.promise.resolve();\n  }\n\n  function doWrite(chunk\x2C controller) {\n    const promise = createDeferredPromise();\n    let ret;\n    let req;\n    try {\n      req = createWriteWrap(controller\x2C promise);\n      ret = streamBase.writeBuffer(req\x2C chunk);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = chunk;\n      req.async = !!streamBaseState[kLastWriteWasAsync];\n    } catch (error) {\n      promise.reject(error);\n    }\n\n    if (ret !== 0)\n      promise.reject(errnoException(ret\x2C 'write'\x2C req));\n    else if (!req.async)\n      promise.resolve();\n\n    return promise.promise;\n  }\n\n  return new WritableStream({\n    write(chunk\x2C controller) {\n      current = current !== undefined ?\n        PromisePrototypeThen(\n          current\x2C\n          () => doWrite(chunk\x2C controller)\x2C\n          (error) => controller.error(error)) :\n        doWrite(chunk\x2C controller);\n      return current;\n    }\x2C\n\n    close() {\n      const promise = createDeferredPromise();\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamBase(streamBase\x2C strategy\x2C options = {}) {\n  validateObject(streamBase\x2C 'streamBase');\n  validateObject(options\x2C 'options');\n\n  const {\n    ondone = () => {}\x2C\n  } = options;\n\n  if (typeof streamBase.onread === 'function')\n    throw new ERR_INVALID_STATE('StreamBase already has a consumer');\n\n  if (typeof ondone !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('options.ondone'\x2C 'Function'\x2C ondone);\n\n  let controller;\n\n  streamBase.onread = (arrayBuffer) => {\n    const nread = streamBaseState[kReadBytesOrError];\n\n    if (nread === 0)\n      return;\n\n    try {\n      if (nread === UV_EOF) {\n        controller.close();\n        streamBase.readStop();\n        try {\n          ondone();\n        } catch (error) {\n          controller.error(error);\n        }\n        return;\n      }\n\n      controller.enqueue(arrayBuffer);\n\n      if (controller.desiredSize <= 0)\n        streamBase.readStop();\n    } catch (error) {\n      controller.error(error);\n      streamBase.readStop();\n    }\n  };\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() {\n      streamBase.readStart();\n    }\x2C\n\n    cancel() {\n      const promise = createDeferredPromise();\n      try {\n        ondone();\n      } catch (error) {\n        promise.reject(error);\n        return promise.promise;\n      }\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\nmodule.exports = {\n  newWritableStreamFromStreamWritable\x2C\n  newReadableStreamFromStreamReadable\x2C\n  newStreamWritableFromWritableStream\x2C\n  newStreamReadableFromReadableStream\x2C\n  newReadableWritablePairFromDuplex\x2C\n  newStreamDuplexFromReadableWritablePair\x2C\n  newWritableStreamFromStreamBase\x2C\n  newReadableStreamFromStreamBase\x2C\n};\n
code-source-info,0x25349b169f66,124,0,24019,C0O0C4O24019,,
code-creation,Function,10,75633,0x25349b16a866,541, node:internal/webstreams/adapters:1:1,0x25349b169ee0,~
code-source-info,0x25349b16a866,124,0,24019,C0O0C162O25C168O46C174O60C180O84C186O111C192O129C198O209C201O209C206O169C212O187C218O307C221O307C226O267C232O285C238O391C241O391C246O365C252O499C255O499C260O452C266O464C272O476C278O486C284O612C287O612C292O529C298O544C304O558C310O577C316O591C322O670C325O670C330O658C336O858C339O858C344O700C355O731C361O757C367O784C373O807C379O842C385O924C388O924C393O897C399O1000C402O1000C407O961C413O980C419O1136C422O1136C427O1043C433O1056C439O1072C445O1093C451O1115C457O1186C460O1186C464O1186C466O1249C469O1249C474O1238C480O23691C487O23712C493O23751C499O23790C505O23829C511O23868C517O23905C523O23948C529O23983C535O23706C540O24018,,
tick,0x7f0810fb2f10,75669,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x11717c2,76173,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x1062bae,77242,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,77376,0x25349b17000e,5, node:internal/webstreams/readablestream:1:1,0x25349b16f248,~
script-source,125,node:internal/webstreams/readablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayBuffer\x2C\n  ArrayBufferPrototypeSlice\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  DataView\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsInteger\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeCatch\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  PromiseAll\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n  SymbolToStringTag\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  isArrayBufferView\x2C\n  isDataView\x2C\n} = require('internal/util/types');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  serialize\x2C\n  deserialize\x2C\n} = require('v8');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  kAborted\x2C\n} = require('internal/abort_controller');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  queueMicrotask\x2C\n} = require('internal/process/task_queues');\n\nconst {\n  kIsDisturbed\x2C\n  kIsErrored\x2C\n  kIsReadable\x2C\n} = require('internal/streams/utils');\n\nconst {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  WritableStreamDefaultWriter\x2C\n\n  isWritableStream\x2C\n  isWritableStreamLocked\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  writableStreamAbort\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterWrite\x2C\n} = require('internal/webstreams/writablestream');\n\nconst assert = require('internal/assert');\n\nconst kCancel = Symbol('kCancel');\nconst kClose = Symbol('kClose');\nconst kChunk = Symbol('kChunk');\nconst kError = Symbol('kError');\nconst kPull = Symbol('kPull');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n * @typedef {import('./writablestream').WritableStream} WritableStream\n */\n\n/**\n * @typedef {ReadableStreamDefaultController | ReadableByteStreamController\n * } ReadableStreamController\n */\n\n/**\n * @typedef {ReadableStreamDefaultReader | ReadableStreamBYOBReader\n * } ReadableStreamReader\n */\n\n/**\n * @callback UnderlyingSourceStartCallback\n * @param {ReadableStreamController} controller\n * @returns { any | Promise<void> }\n */\n\n/**\n * @callback UnderlyingSourcePullCallback\n * @param {ReadableStreamController} controller\n * @returns { Promise<void> }\n */\n\n/**\n * @callback UnderlyingSourceCancelCallback\n * @param {any} reason\n * @returns { Promise<void> }\n */\n\n/**\n * @typedef {{\n *   readable: ReadableStream\x2C\n *   writable: WritableStream\x2C\n * }} ReadableWritablePair\n */\n\n/**\n * @typedef {{\n *   preventClose? : boolean\x2C\n *   preventAbort? : boolean\x2C\n *   preventCancel? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} StreamPipeOptions\n */\n\n/**\n * @typedef {{\n *   start? : UnderlyingSourceStartCallback\x2C\n *   pull? : UnderlyingSourcePullCallback\x2C\n *   cancel? : UnderlyingSourceCancelCallback\x2C\n *   type? : "bytes"\x2C\n *   autoAllocateChunkSize? : number\n * }} UnderlyingSource\n */\n\nclass ReadableStream {\n  [kType] = 'ReadableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSource} [source]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(source = {}\x2C strategy = {}) {\n    if (source === null)\n      throw new ERR_INVALID_ARG_VALUE('source'\x2C 'Object'\x2C source);\n    this[kState] = {\n      disturbed: false\x2C\n      state: 'readable'\x2C\n      storedError: undefined\x2C\n      stream: undefined\x2C\n      transfer: {\n        writable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    // The spec requires handling of the strategy first\n    // here. Specifically\x2C if getting the size and\n    // highWaterMark from the strategy fail\x2C that has\n    // to trigger a throw before getting the details\n    // from the source. So be sure to keep these in\n    // this order.\n    const size = strategy?.size;\n    const highWaterMark = strategy?.highWaterMark;\n    const type = source.type;\n\n    if (`${type}` === 'bytes') {\n      if (size !== undefined)\n        throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.size'\x2C size);\n      setupReadableByteStreamControllerFromSource(\n        this\x2C\n        source\x2C\n        extractHighWaterMark(highWaterMark\x2C 0));\n      return;\n    }\n\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE('source.type'\x2C type);\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      source\x2C\n      extractHighWaterMark(highWaterMark\x2C 1)\x2C\n      extractSizeAlgorithm(size));\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  get [kIsDisturbed]() {\n    return this[kState].disturbed;\n  }\n\n  get [kIsErrored]() {\n    return this[kState].state === 'errored';\n  }\n\n  get [kIsReadable]() {\n    return this[kState].state === 'readable';\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return isReadableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} [reason]\n   * @returns { Promise<void> }\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStream'));\n    if (isReadableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('ReadableStream is locked'));\n    }\n    return readableStreamCancel(this\x2C reason);\n  }\n\n  /**\n   * @param {{\n   *   mode? : "byob"\n   * }} [options]\n   * @returns {ReadableStreamReader}\n   */\n  getReader(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options'\x2C { nullable: true\x2C allowFunction: true });\n    const mode = options?.mode;\n\n    if (mode === undefined)\n      return new ReadableStreamDefaultReader(this);\n\n    if (`${mode}` !== 'byob')\n      throw new ERR_INVALID_ARG_VALUE('options.mode'\x2C mode);\n    return new ReadableStreamBYOBReader(this);\n  }\n\n  /**\n   * @param {ReadableWritablePair} transform\n   * @param {StreamPipeOptions} [options]\n   * @returns {ReadableStream}\n   */\n  pipeThrough(transform\x2C options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    const readable = transform?.readable;\n    if (!isReadableStream(readable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.readable'\x2C\n        'ReadableStream'\x2C\n        readable);\n    }\n    const writable = transform?.writable;\n    if (!isWritableStream(writable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.writable'\x2C\n        'WritableStream'\x2C\n        writable);\n    }\n\n    // The web platform tests require that these be handled one at a\n    // time and in a specific order. options can be null or undefined.\n    const preventAbort = options?.preventAbort;\n    const preventCancel = options?.preventCancel;\n    const preventClose = options?.preventClose;\n    const signal = options?.signal;\n\n    if (signal !== undefined && signal?.[kAborted] === undefined)\n      throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n    if (isReadableStreamLocked(this))\n      throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n    if (isWritableStreamLocked(writable))\n      throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n    const promise = readableStreamPipeTo(\n      this\x2C\n      writable\x2C\n      !!preventClose\x2C\n      !!preventAbort\x2C\n      !!preventCancel\x2C\n      signal);\n    setPromiseHandled(promise);\n\n    return readable;\n  }\n\n  /**\n   * @param {WritableStream} destination\n   * @param {StreamPipeOptions} [options]\n   * @returns {Promise<void>}\n   */\n  pipeTo(destination\x2C options = {}) {\n    try {\n      if (!isReadableStream(this))\n        throw new ERR_INVALID_THIS('ReadableStream');\n      if (!isWritableStream(destination)) {\n        throw new ERR_INVALID_ARG_TYPE(\n          'transform.writable'\x2C\n          'WritableStream'\x2C\n          destination);\n      }\n\n      const preventAbort = options?.preventAbort;\n      const preventCancel = options?.preventCancel;\n      const preventClose = options?.preventClose;\n      const signal = options?.signal;\n\n      if (signal !== undefined && signal?.[kAborted] === undefined)\n        throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n      if (isReadableStreamLocked(this))\n        throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n      if (isWritableStreamLocked(destination))\n        throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n      return readableStreamPipeTo(\n        this\x2C\n        destination\x2C\n        !!preventClose\x2C\n        !!preventAbort\x2C\n        !!preventCancel\x2C\n        signal);\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  /**\n   * @returns {ReadableStream[]}\n   */\n  tee() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return readableStreamTee(this\x2C false);\n  }\n\n  /**\n   * @param {{\n   *   preventCancel? : boolean\x2C\n   * }} [options]\n   * @returns {AsyncIterable}\n   */\n  values(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options');\n    const {\n      preventCancel = false\x2C\n    } = options;\n\n    const reader = new ReadableStreamDefaultReader(this);\n    let done = false;\n    let started = false;\n    let current;\n\n    // The nextSteps function is not an async function in order\n    // to make it more efficient. Because nextSteps explicitly\n    // creates a Promise and returns it in the common case\x2C\n    // making it an async function just causes two additional\n    // unnecessary Promise allocations to occur\x2C which just add\n    // cost.\n    function nextSteps() {\n      if (done)\n        return PromiseResolve({ done: true\x2C value: undefined });\n\n      if (reader[kState].stream === undefined) {\n        return PromiseReject(\n          new ERR_INVALID_STATE.TypeError(\n            'The reader is not bound to a ReadableStream'));\n      }\n      const promise = createDeferredPromise();\n\n      readableStreamDefaultReaderRead(reader\x2C {\n        [kChunk](chunk) {\n          current = undefined;\n          promise.resolve({ value: chunk\x2C done: false });\n        }\x2C\n        [kClose]() {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.resolve({ done: true\x2C value: undefined });\n        }\x2C\n        [kError](error) {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.reject(error);\n        }\n      });\n      return promise.promise;\n    }\n\n    async function returnSteps(value) {\n      if (done)\n        return { done: true\x2C value };\n      done = true;\n\n      if (reader[kState].stream === undefined) {\n        throw new ERR_INVALID_STATE.TypeError(\n          'The reader is not bound to a ReadableStream');\n      }\n      assert(!reader[kState].readRequests.length);\n      if (!preventCancel) {\n        const result = readableStreamReaderGenericCancel(reader\x2C value);\n        readableStreamReaderGenericRelease(reader);\n        await result;\n        return { done: true\x2C value };\n      }\n\n      readableStreamReaderGenericRelease(reader);\n      return { done: true\x2C value };\n    }\n\n    // TODO(@jasnell): Explore whether an async generator\n    // can be used here instead of a custom iterator object.\n    return ObjectSetPrototypeOf({\n      // Changing either of these functions (next or return)\n      // to async functions causes a failure in the streams\n      // Web Platform Tests that check for use of a modified\n      // Promise.prototype.then. Since the await keyword\n      // uses Promise.prototype.then\x2C it is open to prototype\n      // pollution\x2C which causes the test to fail. The other\n      // await uses here do not trigger that failure because\n      // the test that fails does not trigger those code paths.\n      next() {\n        // If this is the first read\x2C delay by one microtask\n        // to ensure that the controller has had an opportunity\n        // to properly start and perform the initial pull.\n        // TODO(@jasnell): The spec doesn't call this out so\n        // need to investigate if it's a bug in our impl or\n        // the spec.\n        if (!started) {\n          current = PromiseResolve();\n          started = true;\n        }\n        current = current !== undefined ?\n          PromisePrototypeThen(current\x2C nextSteps\x2C nextSteps) :\n          nextSteps();\n        return current;\n      }\x2C\n\n      return(error) {\n        return current ?\n          PromisePrototypeThen(\n            current\x2C\n            () => returnSteps(error)\x2C\n            () => returnSteps(error)) :\n          returnSteps(error);\n      }\x2C\n\n      [SymbolAsyncIterator]() { return this; }\n    }\x2C AsyncIterator);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n      supportsBYOB:\n        this[kState].controller instanceof ReadableByteStreamController\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked ReadableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      writable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmWritableSink(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.writable = writable;\n    this[kState].transfer.promise = promise;\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/readablestream:TransferredReadableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      new transfer.CrossRealmTransformReadableSource(port)\x2C\n      0\x2C () => 1);\n  }\n}\n\nObjectDefineProperties(ReadableStream.prototype\x2C {\n  [SymbolAsyncIterator]: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    value: ReadableStream.prototype.values\x2C\n  }\x2C\n  locked: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n  getReader: kEnumerableProperty\x2C\n  pipeThrough: kEnumerableProperty\x2C\n  pipeTo: kEnumerableProperty\x2C\n  tee: kEnumerableProperty\x2C\n});\n\nfunction TransferredReadableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n    }\x2C\n    []\x2C ReadableStream));\n}\nTransferredReadableStream.prototype[kDeserialize] = () => {};\n\nclass ReadableStreamBYOBRequest {\n  [kType] = 'ReadableStreamBYOBRequest';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ArrayBufferView}\n   */\n  get view() {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    return this[kState].view;\n  }\n\n  /**\n   * @param {number} bytesWritten\n   */\n  respond(bytesWritten) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      view\x2C\n      controller\x2C\n    } = this[kState];\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'View ArrayBuffer is zero-length or detached');\n    }\n\n    readableByteStreamControllerRespond(controller\x2C bytesWritten);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   */\n  respondWithNewView(view) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      controller\x2C\n    } = this[kState];\n\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    readableByteStreamControllerRespondWithNewView(controller\x2C view);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      view: this.view\x2C\n      controller: this[kState].controller\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBRequest.prototype\x2C {\n  view: kEnumerableProperty\x2C\n  respond: kEnumerableProperty\x2C\n  respondWithNewView: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamBYOBRequest(controller\x2C view) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamBYOBRequest';\n      this[kState] = {\n        controller\x2C\n        view\x2C\n      };\n    }\x2C\n    []\x2C\n    ReadableStreamBYOBRequest\n  );\n}\n\nclass DefaultReadRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose]() {\n    this[kState].resolve?.({ value: undefined\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadIntoRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose](value) {\n    this[kState].resolve?.({ value\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadableStreamDefaultReader {\n  [kType] = 'ReadableStreamDefaultReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      readRequests: []\x2C\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamDefaultReader(this\x2C stream);\n  }\n\n  /**\n   * @returns {Promise<{\n   *   value : any\x2C\n   *   done : boolean\n   * }>}\n   */\n  read() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readRequest = new DefaultReadRequest();\n    readableStreamDefaultReaderRead(this\x2C readRequest);\n    return readRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamDefaultReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamDefaultReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      readRequests: this[kState].readRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamBYOBReader {\n  [kType] = 'ReadableStreamBYOBReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      requestIntoRequests: []\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamBYOBReader(this\x2C stream);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   * @returns {Promise<{\n   *   view : ArrayBufferView\x2C\n   *   done : boolean\x2C\n   * }>}\n   */\n  read(view) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (!isArrayBufferView(view)) {\n      return PromiseReject(\n        new ERR_INVALID_ARG_TYPE(\n          'view'\x2C\n          [\n            'Buffer'\x2C\n            'TypedArray'\x2C\n            'DataView'\x2C\n          ]\x2C\n          view));\n    }\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'View ArrayBuffer is zero-length or detached'));\n    }\n    // Supposed to assert here that the view's buffer is not\n    // detached\x2C but there's no API available to use to check that.\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readIntoRequest = new ReadIntoRequest();\n    readableStreamBYOBReaderRead(this\x2C view\x2C readIntoRequest);\n    return readIntoRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamBYOBReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readIntoRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      requestIntoRequests: this[kState].requestIntoRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamDefaultController {\n  [kType] = 'ReadableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    return readableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * @param {any} chunk\n   */\n  enqueue(chunk = undefined) {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerEnqueue(this\x2C chunk);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    readableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableStreamDefaultControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableStreamDefaultControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultController.prototype\x2C {\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamDefaultController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableStreamDefaultController\x2C\n  );\n}\n\nclass ReadableByteStreamController {\n  [kType] = 'ReadableByteStreamController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ReadableStreamBYOBRequest}\n   */\n  get byobRequest() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].byobRequest === null &&\n        this[kState].pendingPullIntos.length) {\n      const {\n        buffer\x2C\n        byteOffset\x2C\n        bytesFilled\x2C\n        byteLength\x2C\n      } = this[kState].pendingPullIntos[0];\n      const view =\n        new Uint8Array(\n          buffer\x2C\n          byteOffset + bytesFilled\x2C\n          byteLength - bytesFilled);\n      this[kState].byobRequest = createReadableStreamBYOBRequest(this\x2C view);\n    }\n    return this[kState].byobRequest;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    return readableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerClose(this);\n  }\n\n  /**\n   * @param {ArrayBufferView} chunk\n   */\n  enqueue(chunk) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (!isArrayBufferView(chunk)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C\n        [\n          'Buffer'\x2C\n          'TypedArray'\x2C\n          'DataView'\x2C\n        ]\x2C\n        chunk);\n    }\n    const chunkByteLength = ArrayBufferViewGetByteLength(chunk);\n    const chunkByteOffset = ArrayBufferViewGetByteOffset(chunk);\n    const chunkBuffer = ArrayBufferViewGetBuffer(chunk);\n    const chunkBufferByteLength = ArrayBufferGetByteLength(chunkBuffer);\n    if (chunkByteLength === 0 || chunkBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'chunk ArrayBuffer is zero-length or detached');\n    }\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerEnqueue(\n      this\x2C\n      chunkBuffer\x2C\n      chunkByteLength\x2C\n      chunkByteOffset);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    readableByteStreamControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableByteStreamControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableByteStreamControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableByteStreamController.prototype\x2C {\n  byobRequest: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableByteStreamController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableByteStreamController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableByteStreamController\x2C\n  );\n}\n\nfunction createTeeReadableStream(start\x2C pull\x2C cancel) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n      setupReadableStreamDefaultControllerFromSource(\n        this\x2C\n        ObjectCreate(null\x2C {\n          start: { value: start }\x2C\n          pull: { value: pull }\x2C\n          cancel: { value: cancel }\n        })\x2C\n        1\x2C\n        () => 1);\n      return makeTransferable(this);\n    }\x2C []\x2C ReadableStream\x2C\n  );\n}\n\nconst isReadableStream =\n  isBrandCheck('ReadableStream');\nconst isReadableByteStreamController =\n  isBrandCheck('ReadableByteStreamController');\nconst isReadableStreamBYOBRequest =\n  isBrandCheck('ReadableStreamBYOBRequest');\nconst isReadableStreamDefaultReader =\n  isBrandCheck('ReadableStreamDefaultReader');\nconst isReadableStreamBYOBReader =\n  isBrandCheck('ReadableStreamBYOBReader');\n\n// ---- ReadableStream Implementation\n\nfunction readableStreamPipeTo(\n  source\x2C\n  dest\x2C\n  preventClose\x2C\n  preventAbort\x2C\n  preventCancel\x2C\n  signal) {\n\n  let reader;\n  let writer;\n  // Both of these can throw synchronously. We want to capture\n  // the error and return a rejected promise instead.\n  try {\n    reader = new ReadableStreamDefaultReader(source);\n    writer = new WritableStreamDefaultWriter(dest);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n\n  source[kState].disturbed = true;\n\n  let shuttingDown = false;\n\n  if (signal !== undefined && signal?.[kAborted] === undefined) {\n    return PromiseReject(\n      new ERR_INVALID_ARG_TYPE(\n        'options.signal'\x2C\n        'AbortSignal'\x2C\n        signal));\n  }\n\n  const promise = createDeferredPromise();\n\n  let currentWrite = PromiseResolve();\n\n  // The error here can be undefined. The rejected arg\n  // tells us that the promise must be rejected even\n  // when error is undefine.\n  function finalize(rejected\x2C error) {\n    writableStreamDefaultWriterRelease(writer);\n    readableStreamReaderGenericRelease(reader);\n    if (signal !== undefined)\n      signal.removeEventListener('abort'\x2C abortAlgorithm);\n    if (rejected)\n      promise.reject(error);\n    else\n      promise.resolve();\n  }\n\n  async function waitForCurrentWrite() {\n    const write = currentWrite;\n    await write;\n    if (write !== currentWrite)\n      await waitForCurrentWrite();\n  }\n\n  function shutdownWithAnAction(action\x2C rejected\x2C originalError) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        complete\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    complete();\n\n    function complete() {\n      PromisePrototypeThen(\n        action()\x2C\n        () => finalize(rejected\x2C originalError)\x2C\n        (error) => finalize(true\x2C error));\n    }\n  }\n\n  function shutdown(rejected\x2C error) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        () => finalize(rejected\x2C error)\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    finalize(rejected\x2C error);\n  }\n\n  function abortAlgorithm() {\n    // Cannot use the AbortError class here. It must be a DOMException\n    const error = new DOMException('The operation was aborted'\x2C 'AbortError');\n    const actions = [];\n    if (!preventAbort) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (dest[kState].state === 'writable')\n            return writableStreamAbort(dest\x2C error);\n          return PromiseResolve();\n        });\n    }\n    if (!preventCancel) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (source[kState].state === 'readable')\n            return readableStreamCancel(source\x2C error);\n          return PromiseResolve();\n        });\n    }\n\n    shutdownWithAnAction(\n      async () => PromiseAll(actions.map((action) => action()))\x2C\n      true\x2C\n      error);\n  }\n\n  function watchErrored(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'errored')\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeCatch(promise\x2C action);\n  }\n\n  function watchClosed(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'closed')\n      action();\n    else\n      PromisePrototypeThen(promise\x2C action\x2C () => {});\n  }\n\n  async function step() {\n    if (shuttingDown)\n      return true;\n    await writer[kState].ready.promise;\n    return new Promise((resolve\x2C reject) => {\n      readableStreamDefaultReaderRead(\n        reader\x2C\n        {\n          [kChunk](chunk) {\n            currentWrite = writableStreamDefaultWriterWrite(writer\x2C chunk);\n            setPromiseHandled(currentWrite);\n            resolve(false);\n          }\x2C\n          [kClose]: () => resolve(true)\x2C\n          [kError]: reject\x2C\n        });\n    });\n  }\n\n  async function run() {\n    // Run until step resolves as true\n    while (!await step());\n  }\n\n  if (signal !== undefined) {\n    if (signal.aborted) {\n      abortAlgorithm();\n      return promise.promise;\n    }\n    signal.addEventListener('abort'\x2C abortAlgorithm\x2C { once: true });\n  }\n\n  setPromiseHandled(run());\n\n  watchErrored(source\x2C reader[kState].close.promise\x2C (error) => {\n    if (!preventAbort) {\n      return shutdownWithAnAction(\n        () => writableStreamAbort(dest\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchErrored(dest\x2C writer[kState].close.promise\x2C (error) => {\n    if (!preventCancel) {\n      return shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchClosed(source\x2C reader[kState].close.promise\x2C () => {\n    if (!preventClose) {\n      return shutdownWithAnAction(\n        () => writableStreamDefaultWriterCloseWithErrorPropagation(writer));\n    }\n    shutdown();\n  });\n\n  if (writableStreamCloseQueuedOrInFlight(dest) ||\n      dest[kState].state === 'closed') {\n    const error = new ERR_INVALID_STATE.TypeError(\n      'Destination WritableStream is closed');\n    if (!preventCancel) {\n      shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C true\x2C error);\n    } else {\n      shutdown(true\x2C error);\n    }\n  }\n\n  return promise.promise;\n}\n\nfunction readableStreamTee(stream\x2C cloneForBranch2) {\n  const reader = new ReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n  const cancelPromise = createDeferredPromise();\n\n  async function pullAlgorithm() {\n    if (reading) return;\n    reading = true;\n    const readRequest = {\n      [kChunk](value) {\n        queueMicrotask(() => {\n          reading = false;\n          const value1 = value;\n          let value2 = value;\n          if (!canceled2 && cloneForBranch2) {\n            // Structured Clone\n            value2 = deserialize(serialize(value2));\n          }\n          if (!canceled1) {\n            readableStreamDefaultControllerEnqueue(\n              branch1[kState].controller\x2C\n              value1);\n          }\n          if (!canceled2) {\n            readableStreamDefaultControllerEnqueue(\n              branch2[kState].controller\x2C\n              value2);\n          }\n        });\n      }\x2C\n      [kClose]() {\n        // The `process.nextTick()` is not part of the spec.\n        // This approach was needed to avoid a race condition working with esm\n        // Further information\x2C see: https://github.com/nodejs/node/issues/39758\n        process.nextTick(() => {\n          reading = false;\n          if (!canceled1)\n            readableStreamDefaultControllerClose(branch1[kState].controller);\n          if (!canceled2)\n            readableStreamDefaultControllerClose(branch2[kState].controller);\n          if (!canceled1 || !canceled2)\n            cancelPromise.resolve();\n        });\n      }\x2C\n      [kError]() {\n        reading = false;\n      }\x2C\n    };\n    readableStreamDefaultReaderRead(reader\x2C readRequest);\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  branch1 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel1Algorithm);\n  branch2 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel2Algorithm);\n\n  PromisePrototypeCatch(\n    reader[kState].close.promise\x2C\n    (error) => {\n      readableStreamDefaultControllerError(branch1[kState].controller\x2C error);\n      readableStreamDefaultControllerError(branch2[kState].controller\x2C error);\n      if (!canceled1 || !canceled2)\n        cancelPromise.resolve();\n    });\n\n  return [branch1\x2C branch2];\n}\n\nfunction readableByteStreamControllerConvertPullIntoDescriptor(desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    ctor\x2C\n    elementSize\x2C\n  } = desc;\n  if (bytesFilled > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n  assert(!(bytesFilled % elementSize));\n  const transferredBuffer = transferArrayBuffer(buffer);\n  return new ctor(transferredBuffer\x2C byteOffset\x2C bytesFilled / elementSize);\n}\n\nfunction isReadableStreamLocked(stream) {\n  return stream[kState].reader !== undefined;\n}\n\nfunction readableStreamCancel(stream\x2C reason) {\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      return PromiseResolve();\n    case 'errored':\n      return PromiseReject(stream[kState].storedError);\n  }\n  readableStreamClose(stream);\n  const {\n    reader\x2C\n  } = stream[kState];\n  if (reader !== undefined && readableStreamHasBYOBReader(stream)) {\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kClose]();\n    reader[kState].readIntoRequests = [];\n  }\n\n  return PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kCancel]\x2C\n      stream[kState].controller\x2C\n      reason)\x2C\n    () => {});\n}\n\nfunction readableStreamClose(stream) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'closed';\n\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.resolve();\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kClose]();\n    reader[kState].readRequests = [];\n  }\n}\n\nfunction readableStreamError(stream\x2C error) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'errored';\n  stream[kState].storedError = error;\n\n  const {\n    reader\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.reject(error);\n  setPromiseHandled(reader[kState].close.promise);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kError](error);\n    reader[kState].readRequests = [];\n  } else {\n    assert(readableStreamHasBYOBReader(stream));\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kError](error);\n    reader[kState].readIntoRequests = [];\n  }\n}\n\nfunction readableStreamHasDefaultReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamDefaultReader';\n}\n\nfunction readableStreamGetNumReadRequests(stream) {\n  assert(readableStreamHasDefaultReader(stream));\n  return stream[kState].reader[kState].readRequests.length;\n}\n\nfunction readableStreamHasBYOBReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamBYOBReader';\n}\n\nfunction readableStreamGetNumReadIntoRequests(stream) {\n  assert(readableStreamHasBYOBReader(stream));\n  return stream[kState].reader[kState].readIntoRequests.length;\n}\n\nfunction readableStreamFulfillReadRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasDefaultReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readRequests.length);\n  const readRequest = ArrayPrototypeShift(reader[kState].readRequests);\n\n  // TODO(@jasnell): It's not clear under what exact conditions done\n  // will be true here. The spec requires this check but none of the\n  // WPT's or other tests trigger it. Will need to investigate how to\n  // get coverage for this.\n  if (done)\n    readRequest[kClose]();\n  else\n    readRequest[kChunk](chunk);\n}\n\nfunction readableStreamFulfillReadIntoRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasBYOBReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readIntoRequests.length);\n  const readIntoRequest = ArrayPrototypeShift(reader[kState].readIntoRequests);\n  if (done)\n    readIntoRequest[kClose](chunk);\n  else\n    readIntoRequest[kChunk](chunk);\n}\n\nfunction readableStreamAddReadRequest(stream\x2C readRequest) {\n  assert(readableStreamHasDefaultReader(stream));\n  assert(stream[kState].state === 'readable');\n  ArrayPrototypePush(stream[kState].reader[kState].readRequests\x2C readRequest);\n}\n\nfunction readableStreamAddReadIntoRequest(stream\x2C readIntoRequest) {\n  assert(readableStreamHasBYOBReader(stream));\n  assert(stream[kState].state !== 'errored');\n  ArrayPrototypePush(\n    stream[kState].reader[kState].readIntoRequests\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamReaderGenericCancel(reader\x2C reason) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  return readableStreamCancel(stream\x2C reason);\n}\n\nfunction readableStreamReaderGenericInitialize(reader\x2C stream) {\n  reader[kState].stream = stream;\n  stream[kState].reader = reader;\n  switch (stream[kState].state) {\n    case 'readable':\n      reader[kState].close = createDeferredPromise();\n      break;\n    case 'closed':\n      reader[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    case 'errored':\n      reader[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(reader[kState].close.promise);\n      break;\n  }\n}\n\nfunction readableStreamReaderGenericRelease(reader) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].reader === reader);\n\n  if (stream[kState].state === 'readable') {\n    reader[kState].close.reject?.(\n      new ERR_INVALID_STATE.TypeError('Reader released'));\n  } else {\n    reader[kState].close = {\n      promise: PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Reader released'))\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(reader[kState].close.promise);\n  stream[kState].reader = undefined;\n  reader[kState].stream = undefined;\n}\n\nfunction readableStreamBYOBReaderRead(reader\x2C view\x2C readIntoRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  if (stream[kState].state === 'errored') {\n    readIntoRequest[kError](stream[kState].storedError);\n    return;\n  }\n  readableByteStreamControllerPullInto(\n    stream[kState].controller\x2C\n    view\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamDefaultReaderRead(reader\x2C readRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      readRequest[kClose]();\n      break;\n    case 'errored':\n      readRequest[kError](stream[kState].storedError);\n      break;\n    case 'readable':\n      stream[kState].controller[kPull](readRequest);\n  }\n}\n\nfunction setupReadableStreamBYOBReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  const {\n    controller\x2C\n  } = stream[kState];\n  if (!isReadableByteStreamController(controller))\n    throw new ERR_INVALID_ARG_VALUE('stream'\x2C stream\x2C 'must be a byte stream');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readIntoRequests = [];\n}\n\nfunction setupReadableStreamDefaultReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readRequests = [];\n}\n\nfunction readableStreamDefaultControllerClose(controller) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n  controller[kState].closeRequested = true;\n  if (!controller[kState].queue.length) {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamClose(controller[kState].stream);\n  }\n}\n\nfunction readableStreamDefaultControllerEnqueue(controller\x2C chunk) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n\n  const {\n    stream\x2C\n  } = controller[kState];\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    readableStreamFulfillReadRequest(stream\x2C chunk\x2C false);\n  } else {\n    try {\n      const chunkSize =\n        FunctionPrototypeCall(\n          controller[kState].sizeAlgorithm\x2C\n          undefined\x2C\n          chunk);\n      enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n    } catch (error) {\n      readableStreamDefaultControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction readableStreamDefaultControllerHasBackpressure(controller) {\n  return !readableStreamDefaultControllerShouldCallPull(controller);\n}\n\nfunction readableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  return !controller[kState].closeRequested &&\n         stream[kState].state === 'readable';\n}\n\nfunction readableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default:\n      return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableStreamDefaultControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller) ||\n      !controller[kState].started)\n    return false;\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    return true;\n  }\n\n  const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableStreamDefaultControllerCallPullIfNeeded(controller) {\n  if (!readableStreamDefaultControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction readableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction readableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'readable') {\n    resetQueue(controller);\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamError(stream\x2C error);\n  }\n}\n\nfunction readableStreamDefaultControllerCancelSteps(controller\x2C reason) {\n  resetQueue(controller);\n  try {\n    const result = controller[kState].cancelAlgorithm(reason);\n    return result;\n  } finally {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n  }\n}\n\nfunction readableStreamDefaultControllerPullSteps(controller\x2C readRequest) {\n  const {\n    stream\x2C\n    queue\x2C\n  } = controller[kState];\n  if (queue.length) {\n    const chunk = dequeueValue(controller);\n    if (controller[kState].closeRequested && !queue.length) {\n      readableStreamDefaultControllerClearAlgorithms(controller);\n      readableStreamClose(stream);\n    } else {\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    readRequest[kChunk](chunk);\n    return;\n  }\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    cancelAlgorithm\x2C\n    closeRequested: false\x2C\n    highWaterMark\x2C\n    pullAgain: false\x2C\n    pullAlgorithm\x2C\n    pulling: false\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    started: false\x2C\n    sizeAlgorithm\x2C\n    stream\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction setupReadableStreamDefaultControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createReadableStreamDefaultController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  setupReadableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction readableByteStreamControllerClose(controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  if (queueTotalSize) {\n    controller[kState].closeRequested = true;\n    return;\n  }\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const error = new ERR_INVALID_STATE.TypeError('Partial read');\n      readableByteStreamControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamClose(stream);\n}\n\nfunction readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc) {\n  assert(stream[kState].state !== 'errored');\n  let done = false;\n  if (stream[kState].state === 'closed') {\n    desc.bytesFilled = 0;\n    done = true;\n  }\n\n  const filledView =\n    readableByteStreamControllerConvertPullIntoDescriptor(desc);\n\n  if (desc.type === 'default') {\n    readableStreamFulfillReadRequest(stream\x2C filledView\x2C done);\n  } else {\n    assert(desc.type === 'byob');\n    readableStreamFulfillReadIntoRequest(stream\x2C filledView\x2C done);\n  }\n}\n\nfunction readableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller[kState].byobRequest === null)\n    return;\n  controller[kState].byobRequest[kState].controller = undefined;\n  controller[kState].byobRequest[kState].view = null;\n  controller[kState].byobRequest = null;\n}\n\nfunction readableByteStreamControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n}\n\nfunction readableByteStreamControllerClearPendingPullIntos(controller) {\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller[kState].pendingPullIntos = [];\n}\n\nfunction readableByteStreamControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default: return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableByteStreamControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable' ||\n      controller[kState].closeRequested ||\n      !controller[kState].started) {\n    return false;\n  }\n  if (readableStreamHasDefaultReader(stream) &&\n      readableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (readableStreamHasBYOBReader(stream) &&\n      readableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = readableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableByteStreamControllerHandleQueueDrain(controller) {\n  const {\n    closeRequested\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'readable');\n  if (!queueTotalSize && closeRequested) {\n    readableByteStreamControllerClearAlgorithms(controller);\n    readableStreamClose(stream);\n    return;\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerPullInto(\n  controller\x2C\n  view\x2C\n  readIntoRequest) {\n  const {\n    closeRequested\x2C\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  let elementSize = 1;\n  let ctor = DataView;\n  if (isArrayBufferView(view) && !isDataView(view)) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n    ctor = view.constructor;\n  }\n  const buffer = ArrayBufferViewGetBuffer(view);\n  const byteOffset = ArrayBufferViewGetByteOffset(view);\n  const byteLength = ArrayBufferViewGetByteLength(view);\n  const bufferByteLength = ArrayBufferGetByteLength(buffer);\n\n  let transferredBuffer;\n  try {\n    transferredBuffer = transferArrayBuffer(buffer);\n  } catch (error) {\n    readIntoRequest[kError](error);\n    return;\n  }\n  const desc = {\n    buffer: transferredBuffer\x2C\n    bufferByteLength\x2C\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled: 0\x2C\n    elementSize\x2C\n    ctor\x2C\n    type: 'byob'\x2C\n  };\n  if (pendingPullIntos.length) {\n    ArrayPrototypePush(pendingPullIntos\x2C desc);\n    readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n    return;\n  }\n  if (stream[kState].state === 'closed') {\n    const emptyView = new ctor(desc.buffer\x2C byteOffset\x2C 0);\n    readIntoRequest[kClose](emptyView);\n    return;\n  }\n  if (controller[kState].queueTotalSize) {\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      const filledView =\n        readableByteStreamControllerConvertPullIntoDescriptor(desc);\n      readableByteStreamControllerHandleQueueDrain(controller);\n      readIntoRequest[kChunk](filledView);\n      return;\n    }\n    if (closeRequested) {\n      const error = new ERR_INVALID_STATE.TypeError('ReadableStream closed');\n      readableByteStreamControllerError(controller\x2C error);\n      readIntoRequest[kError](error);\n      return;\n    }\n  }\n  ArrayPrototypePush(pendingPullIntos\x2C desc);\n  readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespondInternal(controller\x2C bytesWritten) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  const desc = pendingPullIntos[0];\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError(\n        'Controller is closed but view is not zero-length');\n    readableByteStreamControllerRespondInClosedState(controller\x2C desc);\n  } else {\n    assert(stream[kState].state === 'readable');\n    if (!bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError('View cannot be zero-length');\n    readableByteStreamControllerRespondInReadableState(\n      controller\x2C\n      bytesWritten\x2C\n      desc);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespond(controller\x2C bytesWritten) {\n  const {\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n  const desc = pendingPullIntos[0];\n\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten !== 0)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n  } else {\n    assert(stream[kState].state === 'readable');\n\n    if (!bytesWritten)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n\n    if ((desc.bytesFilled + bytesWritten) > desc.byteLength)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('bytesWritten'\x2C bytesWritten);\n  }\n\n  desc.buffer = transferArrayBuffer(desc.buffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C bytesWritten);\n}\n\nfunction readableByteStreamControllerRespondInClosedState(controller\x2C desc) {\n  assert(!desc.bytesFilled);\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (readableStreamHasBYOBReader(stream)) {\n    while (readableStreamGetNumReadIntoRequests(stream) > 0) {\n      readableByteStreamControllerCommitPullIntoDescriptor(\n        stream\x2C\n        readableByteStreamControllerShiftPendingPullInto(controller));\n    }\n  }\n}\n\nfunction readableByteStreamControllerFillHeadPullIntoDescriptor(\n  controller\x2C\n  size\x2C\n  desc) {\n  const {\n    pendingPullIntos\x2C\n    byobRequest\x2C\n  } = controller[kState];\n  assert(!pendingPullIntos.length || pendingPullIntos[0] === desc);\n  assert(byobRequest === null);\n  desc.bytesFilled += size;\n}\n\nfunction readableByteStreamControllerEnqueue(\n  controller\x2C\n  buffer\x2C\n  byteLength\x2C\n  byteOffset) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  const transferredBuffer = transferArrayBuffer(buffer);\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n\n    const pendingBufferByteLength =\n      ArrayBufferGetByteLength(firstPendingPullInto.buffer);\n    if (pendingBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Destination ArrayBuffer is zero-length or detached');\n    }\n\n    firstPendingPullInto.buffer =\n      transferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    if (!readableStreamGetNumReadRequests(stream)) {\n      readableByteStreamControllerEnqueueChunkToQueue(\n        controller\x2C\n        transferredBuffer\x2C\n        byteOffset\x2C\n        byteLength);\n    } else {\n      assert(!queue.length);\n      const transferredView =\n        new Uint8Array(transferredBuffer\x2C byteOffset\x2C byteLength);\n      readableStreamFulfillReadRequest(stream\x2C transferredView\x2C false);\n    }\n  } else if (readableStreamHasBYOBReader(stream)) {\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n      controller);\n  } else {\n    assert(!isReadableStreamLocked(stream));\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerEnqueueChunkToQueue(\n  controller\x2C\n  buffer\x2C\n  byteOffset\x2C\n  byteLength) {\n  ArrayPrototypePush(\n    controller[kState].queue\x2C\n    {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    });\n  controller[kState].queueTotalSize += byteLength;\n}\n\nfunction readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n  controller\x2C\n  desc) {\n  const {\n    buffer\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    bytesFilled\x2C\n    elementSize\x2C\n  } = desc;\n  const currentAlignedBytes = bytesFilled - (bytesFilled % elementSize);\n  const maxBytesToCopy = MathMin(\n    controller[kState].queueTotalSize\x2C\n    byteLength - bytesFilled);\n  const maxBytesFilled = bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - bytesFilled;\n    ready = true;\n  }\n  const {\n    queue\x2C\n  } = controller[kState];\n\n  while (totalBytesToCopyRemaining) {\n    const headOfQueue = queue[0];\n    const bytesToCopy = MathMin(\n      totalBytesToCopyRemaining\x2C\n      headOfQueue.byteLength);\n    const destStart = byteOffset + desc.bytesFilled;\n    const arrayBufferByteLength = ArrayBufferGetByteLength(buffer);\n    if (arrayBufferByteLength - destStart < bytesToCopy) {\n      throw new ERR_INVALID_STATE.RangeError(\n        'view ArrayBuffer size is invalid');\n    }\n    assert(arrayBufferByteLength - destStart >= bytesToCopy);\n    copyArrayBuffer(\n      buffer\x2C\n      destStart\x2C\n      headOfQueue.buffer\x2C\n      headOfQueue.byteOffset\x2C\n      bytesToCopy);\n    if (headOfQueue.byteLength === bytesToCopy) {\n      ArrayPrototypeShift(queue);\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller[kState].queueTotalSize -= bytesToCopy;\n    readableByteStreamControllerFillHeadPullIntoDescriptor(\n      controller\x2C\n      bytesToCopy\x2C\n      desc);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(!controller[kState].queueTotalSize);\n    assert(desc.bytesFilled > 0);\n    assert(desc.bytesFilled < elementSize);\n  }\n  return ready;\n}\n\nfunction readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n  controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(!closeRequested);\n  while (pendingPullIntos.length) {\n    if (!controller[kState].queueTotalSize)\n      return;\n    const desc = pendingPullIntos[0];\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      readableByteStreamControllerShiftPendingPullInto(controller);\n      readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc);\n    }\n  }\n}\n\nfunction readableByteStreamControllerRespondInReadableState(\n  controller\x2C\n  bytesWritten\x2C\n  desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n  } = desc;\n\n  if (bytesFilled + bytesWritten > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n\n  readableByteStreamControllerFillHeadPullIntoDescriptor(\n    controller\x2C\n    bytesWritten\x2C\n    desc);\n\n  if (desc.bytesFilled < desc.elementSize)\n    return;\n\n  readableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = desc.bytesFilled % desc.elementSize;\n\n  if (remainderSize) {\n    const end = desc.byteOffset + desc.bytesFilled;\n    const start = end - remainderSize;\n    const remainder =\n      ArrayBufferPrototypeSlice(\n        buffer\x2C\n        start\x2C\n        end);\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      remainder\x2C\n      0\x2C\n      ArrayBufferGetByteLength(remainder));\n  }\n  desc.bytesFilled -= remainderSize;\n  readableByteStreamControllerCommitPullIntoDescriptor(\n    controller[kState].stream\x2C\n    desc);\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction readableByteStreamControllerRespondWithNewView(controller\x2C view) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n\n  const desc = pendingPullIntos[0];\n  assert(stream[kState].state !== 'errored');\n\n  if (!isArrayBufferView(view)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'view'\x2C\n      [\n        'Buffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n      ]\x2C\n      view);\n  }\n  const viewByteLength = ArrayBufferViewGetByteLength(view);\n  const viewByteOffset = ArrayBufferViewGetByteOffset(view);\n  const viewBuffer = ArrayBufferViewGetBuffer(view);\n  const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n  const {\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled\x2C\n    bufferByteLength\x2C\n  } = desc;\n\n  if (byteOffset + bytesFilled !== viewByteOffset)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bytesFilled + viewByteOffset > byteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bufferByteLength !== viewBufferByteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  desc.buffer = transferArrayBuffer(viewBuffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C viewByteLength);\n}\n\nfunction readableByteStreamControllerShiftPendingPullInto(controller) {\n  assert(controller[kState].byobRequest === null);\n  return ArrayPrototypeShift(controller[kState].pendingPullIntos);\n}\n\nfunction readableByteStreamControllerCallPullIfNeeded(controller) {\n  if (!readableByteStreamControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction readableByteStreamControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable')\n    return;\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamError(stream\x2C error);\n}\n\nfunction readableByteStreamControllerCancelSteps(controller\x2C reason) {\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableByteStreamControllerClearAlgorithms(controller);\n  return result;\n}\n\nfunction readableByteStreamControllerPullSteps(controller\x2C readRequest) {\n  const {\n    pendingPullIntos\x2C\n    queue\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(readableStreamHasDefaultReader(stream));\n  if (queueTotalSize) {\n    assert(!readableStreamGetNumReadRequests(stream));\n    const {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    } = ArrayPrototypeShift(queue);\n    controller[kState].queueTotalSize -= byteLength;\n    readableByteStreamControllerHandleQueueDrain(controller);\n    const view = new Uint8Array(buffer\x2C byteOffset\x2C byteLength);\n    readRequest[kChunk](view);\n    return;\n  }\n  const {\n    autoAllocateChunkSize\x2C\n  } = controller[kState];\n  if (autoAllocateChunkSize !== undefined) {\n    try {\n      const buffer = new ArrayBuffer(autoAllocateChunkSize);\n      ArrayPrototypePush(\n        pendingPullIntos\x2C\n        {\n          buffer\x2C\n          bufferByteLength: autoAllocateChunkSize\x2C\n          byteOffset: 0\x2C\n          byteLength: autoAllocateChunkSize\x2C\n          bytesFilled: 0\x2C\n          elementSize: 1\x2C\n          ctor: Uint8Array\x2C\n          type: 'default'\x2C\n        });\n    } catch (error) {\n      readRequest[kError](error);\n      return;\n    }\n  }\n\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableByteStreamController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  autoAllocateChunkSize) {\n  assert(stream[kState].controller === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n  controller[kState] = {\n    byobRequest: null\x2C\n    closeRequested: false\x2C\n    pullAgain: false\x2C\n    pulling: false\x2C\n    started: false\x2C\n    stream\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    highWaterMark\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    autoAllocateChunkSize\x2C\n    pendingPullIntos: []\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableByteStreamControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction setupReadableByteStreamControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark) {\n  const controller = createReadableByteStreamController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const autoAllocateChunkSize = source?.autoAllocateChunkSize;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  if (autoAllocateChunkSize === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'source.autoAllocateChunkSize'\x2C\n      autoAllocateChunkSize);\n  }\n  setupReadableByteStreamController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    autoAllocateChunkSize);\n}\n\nmodule.exports = {\n  ReadableStream\x2C\n  ReadableStreamDefaultReader\x2C\n  ReadableStreamBYOBReader\x2C\n  ReadableStreamBYOBRequest\x2C\n  ReadableByteStreamController\x2C\n  ReadableStreamDefaultController\x2C\n  TransferredReadableStream\x2C\n\n  // Exported Brand Checks\n  isReadableStream\x2C\n  isReadableByteStreamController\x2C\n  isReadableStreamBYOBRequest\x2C\n  isReadableStreamDefaultReader\x2C\n  isReadableStreamBYOBReader\x2C\n  isWritableStreamDefaultWriter\x2C\n  isWritableStreamDefaultController\x2C\n\n  readableStreamPipeTo\x2C\n  readableStreamTee\x2C\n  readableByteStreamControllerConvertPullIntoDescriptor\x2C\n  isReadableStreamLocked\x2C\n  readableStreamCancel\x2C\n  readableStreamClose\x2C\n  readableStreamError\x2C\n  readableStreamHasDefaultReader\x2C\n  readableStreamGetNumReadRequests\x2C\n  readableStreamHasBYOBReader\x2C\n  readableStreamGetNumReadIntoRequests\x2C\n  readableStreamFulfillReadRequest\x2C\n  readableStreamFulfillReadIntoRequest\x2C\n  readableStreamAddReadRequest\x2C\n  readableStreamAddReadIntoRequest\x2C\n  readableStreamReaderGenericCancel\x2C\n  readableStreamReaderGenericInitialize\x2C\n  readableStreamReaderGenericRelease\x2C\n  readableStreamBYOBReaderRead\x2C\n  readableStreamDefaultReaderRead\x2C\n  setupReadableStreamBYOBReader\x2C\n  setupReadableStreamDefaultReader\x2C\n  readableStreamDefaultControllerClose\x2C\n  readableStreamDefaultControllerEnqueue\x2C\n  readableStreamDefaultControllerHasBackpressure\x2C\n  readableStreamDefaultControllerCanCloseOrEnqueue\x2C\n  readableStreamDefaultControllerGetDesiredSize\x2C\n  readableStreamDefaultControllerShouldCallPull\x2C\n  readableStreamDefaultControllerCallPullIfNeeded\x2C\n  readableStreamDefaultControllerClearAlgorithms\x2C\n  readableStreamDefaultControllerError\x2C\n  readableStreamDefaultControllerCancelSteps\x2C\n  readableStreamDefaultControllerPullSteps\x2C\n  setupReadableStreamDefaultController\x2C\n  setupReadableStreamDefaultControllerFromSource\x2C\n  readableByteStreamControllerClose\x2C\n  readableByteStreamControllerCommitPullIntoDescriptor\x2C\n  readableByteStreamControllerInvalidateBYOBRequest\x2C\n  readableByteStreamControllerClearAlgorithms\x2C\n  readableByteStreamControllerClearPendingPullIntos\x2C\n  readableByteStreamControllerGetDesiredSize\x2C\n  readableByteStreamControllerShouldCallPull\x2C\n  readableByteStreamControllerHandleQueueDrain\x2C\n  readableByteStreamControllerPullInto\x2C\n  readableByteStreamControllerRespondInternal\x2C\n  readableByteStreamControllerRespond\x2C\n  readableByteStreamControllerRespondInClosedState\x2C\n  readableByteStreamControllerFillHeadPullIntoDescriptor\x2C\n  readableByteStreamControllerEnqueue\x2C\n  readableByteStreamControllerEnqueueChunkToQueue\x2C\n  readableByteStreamControllerFillPullIntoDescriptorFromQueue\x2C\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\x2C\n  readableByteStreamControllerRespondInReadableState\x2C\n  readableByteStreamControllerRespondWithNewView\x2C\n  readableByteStreamControllerShiftPendingPullInto\x2C\n  readableByteStreamControllerCallPullIfNeeded\x2C\n  readableByteStreamControllerError\x2C\n  readableByteStreamControllerCancelSteps\x2C\n  readableByteStreamControllerPullSteps\x2C\n  setupReadableByteStreamController\x2C\n  setupReadableByteStreamControllerFromSource\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x25349b17000e,125,0,76621,C0O0C4O76621,,
code-creation,Function,10,81172,0x25349b175f76,3524, node:internal/webstreams/readablestream:1:1,0x25349b16ff88,~
code-source-info,0x25349b175f76,125,0,76621,C0O0C655O68C661O83C667O112C673O134C679O157C685O169C691O194C697O219C703O230C709O249C715O265C720O291C726O315C732O326C738O351C744O375C750O393C756O410C762O424C768O444C773O454C779O477C784O498C790O683C794O683C800O683C806O551C812O580C818O607C824O633C830O656C836O740C840O740C846O722C852O818C856O818C862O781C868O802C874O944C878O944C884O861C890O907C895O919C900O1011C904O1011C910O981C916O994C922O1057C926O1057C932O1037C938O1114C942O1114C948O1100C954O1183C958O1183C964O1163C970O1293C974O1293C980O1225C985O1241C990O1254C995O1271C1001O1368C1005O1368C1011O1348C1017O1467C1021O1467C1027O1420C1032O1436C1037O1450C1042O1946C1046O1946C1052O1513C1058O1541C1064O1573C1070O1605C1076O1633C1082O1650C1088O1669C1094O1686C1100O1702C1106O1721C1112O1745C1118O1769C1124O1793C1130O1809C1135O1825C1141O1839C1147O1860C1153O1883C1159O1898C1165O1911C1171O1925C1177O1934C1183O2337C1187O2337C1193O1994C1199O2026C1205O2046C1211O2072C1216O2109C1221O2143C1227O2166C1233O2205C1239O2261C1245O2299C1251O2400C1255O2400C1259O2400C1261O2445C1265O2445C1269O2445C1271O2479C1275O2479C1279O2479C1281O2512C1285O2512C1289O2512C1291O2545C1295O2545C1299O2545C1301O2577C1305O2577C1309O2577C1331O4043C1341O4078C1349O5659C1359O5724C1369O5797C1421O13922C1431O14175C1441O14959C1451O15141C1487O4017C1489O15354C1493O15392C1507O15408C1509O15430C1519O15525C1525O15535C1546O15558C1557O15589C1568O15623C1579O15659C1590O15690C1601O15718C1606O15354C1611O16205C1617O16215C1621O16229C1645O16279C1655O16325C1681O17915C1717O16242C1719O18080C1723O18129C1737O18150C1743O18182C1749O18225C1753O18080C1771O18621C1781O18698C1791O18780C1819O18524C1834O18982C1844O19059C1854O19135C1882O18888C1904O19282C1914O19330C1946O21425C1982O19243C1984O21654C1988O21705C2002O21728C2008O21757C2014O21793C2020O21824C2024O21654C2049O21886C2059O21931C2091O24825C2131O21850C2133O25068C2137O25116C2158O25139C2168O25168C2178O25204C2188O25235C2196O25068C2226O25304C2236O25356C2270O26210C2285O26306C2298O26401C2344O25261C2346O26496C2350O26551C2371O26579C2381O26609C2391O26641C2401O26671C2409O26496C2446O26972C2456O27021C2514O29924C2529O30017C2542O30109C2588O26932C2590O30204C2594O30256C2615O30284C2625O30320C2635O30350C2645O30382C2655O30412C2663O30204C2673O31405C2679O31405C2687O31405C2689O31478C2695O31478C2703O31478C2705O31562C2711O31562C2719O31562C2721O31645C2727O31645C2735O31645C2737O31727C2743O31727C2751O31727C2753O73518C2764O73539C2774O73557C2784O73588C2794O73616C2804O73645C2814O73677C2824O73712C2834O73769C2844O73789C2854O73823C2864O73854C2874O73887C2884O73917C2894O73950C2904O73988C2914O74012C2924O74033C2934O74090C2944O74116C2954O74140C2964O74163C2974O74186C2984O74220C2994O74256C3004O74287C3014O74327C3024O74363C3034O74403C3044O74435C3054O74471C3064O74508C3074O74549C3084O74587C3094O74619C3104O74654C3114O74687C3124O74723C3134O74763C3144O74805C3154O74855C3164O74907C3174O74956C3184O75005C3194O75056C3204O75106C3214O75146C3224O75192C3234O75236C3244O75276C3254O75326C3264O75363C3274O75419C3284O75472C3294O75519C3304O75572C3314O75618C3324O75664C3334O75712C3344O75752C3354O75799C3364O75838C3374O75890C3384O75948C3394O75987C3404O76038C3414O76101C3424O76169C3434O76223C3444O76273C3454O76325C3464O76373C3474O76410C3484O76453C3494O76494C3504O76531C3514O73533C3523O76620,,
code-creation,Function,10,81256,0x25349b17720e,16,<instance_members_initializer> node:internal/webstreams/readablestream:1035:3,0x25349b172e70,~
code-source-info,0x25349b17720e,125,26971,27011,C3O26981C15O27011,,
code-creation,Function,10,81267,0x25349b177286,16,<instance_members_initializer> node:internal/webstreams/readablestream:965:3,0x25349b172ad8,~
code-source-info,0x25349b177286,125,25303,25346,C3O25313C15O25346,,
code-creation,Function,10,81278,0x25349b177306,16,<instance_members_initializer> node:internal/webstreams/readablestream:848:3,0x25349b1727b0,~
code-source-info,0x25349b177306,125,21885,21921,C3O21895C15O21921,,
code-creation,Function,10,81289,0x25349b17737e,16,<instance_members_initializer> node:internal/webstreams/readablestream:754:3,0x25349b172528,~
code-source-info,0x25349b17737e,125,19281,19320,C3O19291C15O19320,,
code-creation,Function,10,81303,0x25349b1773f6,16,<instance_members_initializer> node:internal/webstreams/readablestream:622:3,0x25349b171f40,~
code-source-info,0x25349b1773f6,125,16278,16315,C3O16288C15O16315,,
code-creation,Function,10,81315,0x25349b17746e,16,<instance_members_initializer> node:internal/webstreams/readablestream:201:3,0x25349b171c80,~
code-source-info,0x25349b17746e,125,4042,4068,C3O4052C15O4068,,
tick,0x7f0810b8449c,81334,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810fb382c,81354,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810b8449c,81361,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x129bea1,81489,1,0xb83830,6,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,81844,0x25349b17e23e,5, node:internal/webstreams/util:1:1,0x25349b17df88,~
script-source,126,node:internal/webstreams/util,'use strict';\n\nconst {\n  ArrayBufferPrototype\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  AsyncIteratorPrototype\x2C\n  FunctionPrototypeCall\x2C\n  MathMax\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectGet\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OPERATION_FAILED\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  copyArrayBuffer\x2C\n  detachArrayBuffer\n} = internalBinding('buffer');\n\nconst {\n  isPromise\x2C\n} = require('internal/util/types');\n\nconst {\n  inspect\x2C\n} = require('util');\n\nconst {\n  getPromiseDetails\x2C\n  kPending\x2C\n} = internalBinding('util');\n\nconst assert = require('internal/assert');\n\nconst kState = Symbol('kState');\nconst kType = Symbol('kType');\n\nconst AsyncIterator = ObjectCreate(AsyncIteratorPrototype\x2C {\n  next: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n  return: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n});\n\nfunction extractHighWaterMark(value\x2C defaultHWM) {\n  if (value === undefined) return defaultHWM;\n  value = +value;\n  if (typeof value !== 'number' ||\n      NumberIsNaN(value) ||\n      value < 0)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.highWaterMark'\x2C value);\n  return value;\n}\n\nfunction extractSizeAlgorithm(size) {\n  if (size === undefined) return () => 1;\n  if (typeof size !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('strategy.size'\x2C 'Function'\x2C size);\n  return size;\n}\n\nfunction customInspect(depth\x2C options\x2C name\x2C data) {\n  if (depth < 0)\n    return this;\n\n  const opts = {\n    ...options\x2C\n    depth: options.depth == null ? null : options.depth - 1\n  };\n\n  return `${name} ${inspect(data\x2C opts)}`;\n}\n\n// These are defensive to work around the possibility that\n// the buffer\x2C byteLength\x2C and byteOffset properties on\n// ArrayBuffer and ArrayBufferView's may have been tampered with.\n\nfunction ArrayBufferViewGetBuffer(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'buffer'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteLength(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteLength'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteOffset(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteOffset'\x2C view);\n}\n\nfunction ArrayBufferGetByteLength(view) {\n  return ReflectGet(ArrayBufferPrototype\x2C 'byteLength'\x2C view);\n}\n\nfunction isBrandCheck(brand) {\n  return (value) => {\n    return value != null &&\n           value[kState] !== undefined &&\n           value[kType] === brand;\n  };\n}\n\nfunction transferArrayBuffer(buffer) {\n  const res = detachArrayBuffer(buffer);\n  if (res === undefined) {\n    throw new ERR_OPERATION_FAILED.TypeError(\n      'The ArrayBuffer could not be transferred');\n  }\n  return res;\n}\n\nfunction dequeueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  const {\n    value\x2C\n    size\x2C\n  } = ArrayPrototypeShift(controller[kState].queue);\n  controller[kState].queueTotalSize =\n    MathMax(0\x2C controller[kState].queueTotalSize - size);\n  return value;\n}\n\nfunction resetQueue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  controller[kState].queue = [];\n  controller[kState].queueTotalSize = 0;\n}\n\nfunction peekQueueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  return controller[kState].queue[0].value;\n}\n\nfunction enqueueValueWithSize(controller\x2C value\x2C size) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  size = +size;\n  if (typeof size !== 'number' ||\n      size < 0 ||\n      NumberIsNaN(size) ||\n      size === Infinity) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n  ArrayPrototypePush(controller[kState].queue\x2C { value\x2C size });\n  controller[kState].queueTotalSize += size;\n}\n\nfunction ensureIsPromise(fn\x2C thisArg\x2C ...args) {\n  try {\n    const value = FunctionPrototypeCall(fn\x2C thisArg\x2C ...args);\n    return isPromise(value) ? value : PromiseResolve(value);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n}\n\nfunction isPromisePending(promise) {\n  if (promise === undefined) return false;\n  const details = getPromiseDetails(promise);\n  return details?.[0] === kPending;\n}\n\nfunction setPromiseHandled(promise) {\n  // Alternatively\x2C we could use the native API\n  // MarkAsHandled\x2C but this avoids the extra boundary cross\n  // and is hopefully faster at the cost of an extra Promise\n  // allocation.\n  PromisePrototypeThen(promise\x2C () => {}\x2C () => {});\n}\n\nasync function nonOpFlush() {}\n\nfunction nonOpStart() {}\n\nasync function nonOpPull() {}\n\nasync function nonOpCancel() {}\n\nasync function nonOpWrite() {}\n\nlet transfer;\nfunction lazyTransfer() {\n  if (transfer === undefined)\n    transfer = require('internal/webstreams/transfer');\n  return transfer;\n}\n\nmodule.exports = {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpFlush\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n};\n
code-source-info,0x25349b17e23e,126,0,5587,C0O0C4O5587,,
code-creation,Function,10,82135,0x25349b17ee8e,611, node:internal/webstreams/util:1:1,0x25349b17e1b8,~
code-source-info,0x25349b17ee8e,126,0,5587,C0O0C196O25C202O49C208O71C214O94C219O120C225O145C231O156C237O171C242O187C248O211C254O229C260O246C266O260C271O393C279O393C285O393C291O309C297O335C303O362C309O473C313O473C319O432C324O451C330O526C338O526C344O511C350O582C358O582C364O569C370O645C374O645C380O610C386O631C392O686C400O686C404O686C406O730C410O730C414O730C416O762C420O762C424O762C426O815C432O802C438O4924C439O4924C441O5068C449O5089C455O5117C461O5149C467O5181C473O5209C479O5226C485O5245C491O5262C497O5278C503O5297C509O5321C515O5345C521O5369C527O5385C533O5401C539O5421C545O5439C551O5453C557O5474C563O5497C569O5512C575O5526C581O5539C587O5553C593O5567C599O5576C605O5083C610O5586,,
tick,0x11b4cc8,82562,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b176419,0x7f07fc043395,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
new,MemoryChunk,0x3b5adb580000,262144
code-creation,Eval,10,83113,0x3b5adb58207e,5, node:internal/webstreams/writablestream:1:1,0x3b5adb581870,~
script-source,127,node:internal/webstreams/writablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperties\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  nonOpCancel\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  AbortController\x2C\n} = require('internal/abort_controller');\n\nconst assert = require('internal/assert');\n\nconst kAbort = Symbol('kAbort');\nconst kCloseSentinel = Symbol('kCloseSentinel');\nconst kError = Symbol('kError');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy\n * } QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n */\n\n/**\n * @callback UnderlyingSinkStartCallback\n * @param {WritableStreamDefaultController} controller\n */\n\n/**\n * @callback UnderlyingSinkWriteCallback\n * @param {any} chunk\n * @param {WritableStreamDefaultController} controller\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnderlyingSinkCloseCallback\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnderlyingSinkAbortCallback\n * @param {any} reason\n * @returns {Promise<void>}\n */\n\n/**\n * @typedef {{\n *   start? : UnderlyingSinkStartCallback\x2C\n *   write? : UnderlyingSinkWriteCallback\x2C\n *   close? : UnderlyingSinkCloseCallback\x2C\n *   abort? : UnderlyingSinkAbortCallback\x2C\n *   type? : any\x2C\n * }} UnderlyingSink\n */\n\nclass WritableStream {\n  [kType] = 'WritableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSink} [sink]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(sink = null\x2C strategy = {}) {\n    const type = sink?.type;\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('type'\x2C type);\n\n    this[kState] = {\n      close: createDeferredPromise()\x2C\n      closeRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightWriteRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightCloseRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      pendingAbortRequest: {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      }\x2C\n      backpressure: false\x2C\n      controller: undefined\x2C\n      state: 'writable'\x2C\n      storedError: undefined\x2C\n      writeRequests: []\x2C\n      writer: undefined\x2C\n      transfer: {\n        readable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    const size = extractSizeAlgorithm(strategy?.size);\n    const highWaterMark = extractHighWaterMark(strategy?.highWaterMark\x2C 1);\n\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      sink\x2C\n      highWaterMark\x2C\n      size);\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return isWritableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<vois>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    return writableStreamAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure closing WritableStream'));\n    }\n    return writableStreamClose(this);\n  }\n\n  /**\n   * @returns {WritableStreamDefaultWriter}\n   */\n  getWriter() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return new WritableStreamDefaultWriter(this);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked WritableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      readable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmReadableStream(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.readable = readable;\n    this[kState].transfer.promise = promise;\n\n    setPromiseHandled(this[kState].transfer.promise);\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/writablestream:TransferredWritableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      new transfer.CrossRealmTransformWritableSink(port)\x2C\n      1\x2C\n      () => 1);\n  }\n}\n\nObjectDefineProperties(WritableStream.prototype\x2C {\n  locked: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  getWriter: kEnumerableProperty\x2C\n});\n\nfunction TransferredWritableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStream';\n      this[kState] = {\n        close: createDeferredPromise()\x2C\n        closeRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightWriteRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightCloseRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        pendingAbortRequest: {\n          abort: {\n            promise: undefined\x2C\n            resolve: undefined\x2C\n            reject: undefined\x2C\n          }\x2C\n          reason: undefined\x2C\n          wasAlreadyErroring: false\x2C\n        }\x2C\n        backpressure: false\x2C\n        controller: undefined\x2C\n        state: 'writable'\x2C\n        storedError: undefined\x2C\n        writeRequests: []\x2C\n        writer: undefined\x2C\n        transfer: {\n          promise: undefined\x2C\n          port1: undefined\x2C\n          port2: undefined\x2C\n          readable: undefined\x2C\n        }\x2C\n      };\n    }\x2C\n    []\x2C WritableStream));\n}\nTransferredWritableStream.prototype[kDeserialize] = () => {};\n\nclass WritableStreamDefaultWriter {\n  [kType] = 'WritableStreamDefaultWriter';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {WritableStream} stream\n   */\n  constructor(stream) {\n    if (!isWritableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'WritableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      ready: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\n    };\n    setupWritableStreamDefaultWriter(this\x2C stream);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    if (this[kState].stream === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Writer is not bound to a WritableStream');\n    }\n    return writableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get ready() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].ready.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(stream)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure to close WritableStream'));\n    }\n    return writableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined)\n      return;\n    assert(stream[kState].writer !== undefined);\n    writableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * @param {any} chunk\n   * @returns {Promise<void>}\n   */\n  write(chunk = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterWrite(this\x2C chunk);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      close: this[kState].close.promise\x2C\n      ready: this[kState].ready.promise\x2C\n      desiredSize: this.desiredSize\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultWriter.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  ready: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  write: kEnumerableProperty\x2C\n});\n\nclass WritableStreamDefaultController {\n  [kType] = 'WritableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kAbort](reason) {\n    const result = this[kState].abortAlgorithm(reason);\n    writableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [kError]() {\n    resetQueue(this);\n  }\n\n  /**\n   * @type {any}\n   */\n  get abortReason() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortReason;\n  }\n\n  /**\n   * @type {AbortSignal}\n   */\n  get signal() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortController.signal;\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    if (this[kState].stream[kState].state !== 'writable')\n      return;\n    writableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultController.prototype\x2C {\n  abortReason: kEnumerableProperty\x2C\n  signal: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createWritableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStreamDefaultController';\n    }\x2C\n    []\x2C WritableStreamDefaultController);\n}\n\nconst isWritableStream =\n  isBrandCheck('WritableStream');\nconst isWritableStreamDefaultWriter =\n  isBrandCheck('WritableStreamDefaultWriter');\nconst isWritableStreamDefaultController =\n  isBrandCheck('WritableStreamDefaultController');\n\nfunction isWritableStreamLocked(stream) {\n  return stream[kState].writer !== undefined;\n}\n\nfunction setupWritableStreamDefaultWriter(writer\x2C stream) {\n  if (isWritableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('WritableStream is locked');\n  writer[kState].stream = stream;\n  stream[kState].writer = writer;\n  switch (stream[kState].state) {\n    case 'writable':\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          stream[kState].backpressure) {\n        writer[kState].ready = createDeferredPromise();\n      } else {\n        writer[kState].ready = {\n          promise: PromiseResolve()\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        };\n      }\n      setClosedPromiseToNewPromise();\n      break;\n    case 'erroring':\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setClosedPromiseToNewPromise();\n      break;\n    case 'closed':\n      writer[kState].ready = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    default:\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setPromiseHandled(writer[kState].close.promise);\n  }\n\n  function setClosedPromiseToNewPromise() {\n    writer[kState].close = createDeferredPromise();\n  }\n}\n\nfunction writableStreamAbort(stream\x2C reason) {\n  const {\n    state\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored')\n    return PromiseResolve();\n\n  controller[kState].abortReason = reason;\n  controller[kState].abortController.abort();\n\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined)\n    return stream[kState].pendingAbortRequest.abort.promise;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    reason = undefined;\n  }\n\n  const abort = createDeferredPromise();\n\n  stream[kState].pendingAbortRequest = {\n    abort\x2C\n    reason\x2C\n    wasAlreadyErroring\x2C\n  };\n\n  if (!wasAlreadyErroring)\n    writableStreamStartErroring(stream\x2C reason);\n\n  return abort.promise;\n}\n\nfunction writableStreamClose(stream) {\n  const {\n    state\x2C\n    writer\x2C\n    backpressure\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n  assert(state === 'writable' || state === 'erroring');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  stream[kState].closeRequest = createDeferredPromise();\n  const { promise } = stream[kState].closeRequest;\n  if (writer !== undefined && backpressure && state === 'writable')\n    writer[kState].ready.resolve?.();\n  writableStreamDefaultControllerClose(controller);\n  return promise;\n}\n\nfunction writableStreamUpdateBackpressure(stream\x2C backpressure) {\n  assert(stream[kState].state === 'writable');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined && stream[kState].backpressure !== backpressure) {\n    if (backpressure) {\n      writer[kState].ready = createDeferredPromise();\n    } else {\n      writer[kState].ready.resolve?.();\n    }\n  }\n  stream[kState].backpressure = backpressure;\n}\n\nfunction writableStreamStartErroring(stream\x2C reason) {\n  assert(stream[kState].storedError === undefined);\n  assert(stream[kState].state === 'writable');\n  const {\n    controller\x2C\n    writer\x2C\n  } = stream[kState];\n  assert(controller !== undefined);\n  stream[kState].state = 'erroring';\n  stream[kState].storedError = reason;\n  if (writer !== undefined) {\n    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C reason);\n  }\n  if (!writableStreamHasOperationMarkedInFlight(stream) &&\n      controller[kState].started) {\n    writableStreamFinishErroring(stream);\n  }\n}\n\nfunction writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  assert(stream[kState].state === 'errored');\n  if (stream[kState].closeRequest.promise !== undefined) {\n    assert(stream[kState].inFlightCloseRequest.promise === undefined);\n    stream[kState].closeRequest.reject?.(stream[kState].storedError);\n    stream[kState].closeRequest = {\n      promise: undefined\x2C\n      reject: undefined\x2C\n      resolve: undefined\x2C\n    };\n  }\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined) {\n    writer[kState].close.reject?.(stream[kState].storedError);\n    setPromiseHandled(writer[kState].close.promise);\n  }\n}\n\nfunction writableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].writeRequests.length);\n  const writeRequest = ArrayPrototypeShift(stream[kState].writeRequests);\n  stream[kState].inFlightWriteRequest = writeRequest;\n}\n\nfunction writableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].closeRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest = stream[kState].closeRequest;\n  stream[kState].closeRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamHasOperationMarkedInFlight(stream) {\n  const {\n    inFlightWriteRequest\x2C\n    inFlightCloseRequest\x2C\n  } = stream[kState];\n  if (inFlightWriteRequest.promise === undefined &&\n      inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamFinishInFlightWriteWithError(stream\x2C error) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.reject?.(error);\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightWrite(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.resolve?.();\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamFinishInFlightCloseWithError(stream\x2C error) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.reject?.(error);\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n    stream[kState].pendingAbortRequest.abort.reject?.(error);\n    stream[kState].pendingAbortRequest = {\n      abort: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      reason: undefined\x2C\n      wasAlreadyErroring: false\x2C\n    };\n  }\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightClose(stream) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.resolve?.();\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  if (stream[kState].state === 'erroring') {\n    stream[kState].storedError = undefined;\n    if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n      stream[kState].pendingAbortRequest.abort.resolve?.();\n      stream[kState].pendingAbortRequest = {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      };\n    }\n  }\n  stream[kState].state = 'closed';\n  if (stream[kState].writer !== undefined)\n    stream[kState].writer[kState].close.resolve?.();\n  assert(stream[kState].pendingAbortRequest.abort.promise === undefined);\n  assert(stream[kState].storedError === undefined);\n}\n\nfunction writableStreamFinishErroring(stream) {\n  assert(stream[kState].state === 'erroring');\n  assert(!writableStreamHasOperationMarkedInFlight(stream));\n  stream[kState].state = 'errored';\n  stream[kState].controller[kError]();\n  const storedError = stream[kState].storedError;\n  for (let n = 0; n < stream[kState].writeRequests.length; n++)\n    stream[kState].writeRequests[n].reject?.(storedError);\n  stream[kState].writeRequests = [];\n\n  if (stream[kState].pendingAbortRequest.abort.promise === undefined) {\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream[kState].pendingAbortRequest;\n  stream[kState].pendingAbortRequest = {\n    abort: {\n      promise: undefined\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    }\x2C\n    reason: undefined\x2C\n    wasAlreadyErroring: false\x2C\n  };\n  if (abortRequest.wasAlreadyErroring) {\n    abortRequest.abort.reject?.(storedError);\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kAbort]\x2C\n      stream[kState].controller\x2C\n      abortRequest.reason)\x2C\n    () => {\n      abortRequest.abort.resolve?.();\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }\x2C\n    (error) => {\n      abortRequest.abort.reject?.(error);\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction writableStreamDealWithRejection(stream\x2C error) {\n  const {\n    state\x2C\n  } = stream[kState];\n  if (state === 'writable') {\n    writableStreamStartErroring(stream\x2C error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  writableStreamFinishErroring(stream);\n}\n\nfunction writableStreamCloseQueuedOrInFlight(stream) {\n  if (stream[kState].closeRequest.promise === undefined &&\n      stream[kState].inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamAddWriteRequest(stream) {\n  assert(isWritableStreamLocked(stream));\n  assert(stream[kState].state === 'writable');\n  const {\n    promise\x2C\n    resolve\x2C\n    reject\x2C\n  } = createDeferredPromise();\n  ArrayPrototypePush(\n    stream[kState].writeRequests\x2C\n    {\n      promise\x2C\n      resolve\x2C\n      reject\x2C\n    });\n  return promise;\n}\n\nfunction writableStreamDefaultWriterWrite(writer\x2C chunk) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    controller\x2C\n  } = stream[kState];\n  const chunkSize = writableStreamDefaultControllerGetChunkSize(\n    controller\x2C\n    chunk);\n  if (stream !== writer[kState].stream) {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('Mismatched WritableStreams'));\n  }\n  const {\n    state\x2C\n  } = stream[kState];\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n\n  if (state === 'erroring')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable');\n\n  const promise = writableStreamAddWriteRequest(stream);\n  writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize);\n  return promise;\n}\n\nfunction writableStreamDefaultWriterRelease(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].writer === writer);\n  const releasedError =\n    new ERR_INVALID_STATE.TypeError('Writer has been released');\n  writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C releasedError);\n  writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C releasedError);\n  stream[kState].writer = undefined;\n  writer[kState].stream = undefined;\n}\n\nfunction writableStreamDefaultWriterGetDesiredSize(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  switch (stream[kState].state) {\n    case 'errored':\n      // Fall through\n    case 'erroring':\n      return null;\n    case 'closed':\n      return 0;\n  }\n  return writableStreamDefaultControllerGetDesiredSize(\n    stream[kState].controller);\n}\n\nfunction writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].ready.promise)) {\n    writer[kState].ready.reject?.(error);\n  } else {\n    writer[kState].ready = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].ready.promise);\n}\n\nfunction writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].close.promise)) {\n    writer[kState].close.reject?.(error);\n  } else {\n    writer[kState].close = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].close.promise);\n}\n\nfunction writableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    state\x2C\n  } = stream[kState];\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed')\n    return PromiseResolve();\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return writableStreamDefaultWriterClose(writer);\n}\n\nfunction writableStreamDefaultWriterClose(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamClose(stream);\n}\n\nfunction writableStreamDefaultWriterAbort(writer\x2C reason) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamAbort(stream\x2C reason);\n}\n\nfunction writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize) {\n  try {\n    enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return;\n  }\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!writableStreamCloseQueuedOrInFlight(stream) &&\n      stream[kState].state === 'writable') {\n    writableStreamUpdateBackpressure(\n      stream\x2C\n      writableStreamDefaultControllerGetBackpressure(controller));\n  }\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerProcessWrite(controller\x2C chunk) {\n  const {\n    stream\x2C\n    writeAlgorithm\x2C\n  } = controller[kState];\n  writableStreamMarkFirstWriteRequestInFlight(stream);\n\n  PromisePrototypeThen(\n    ensureIsPromise(writeAlgorithm\x2C controller\x2C chunk\x2C controller)\x2C\n    () => {\n      writableStreamFinishInFlightWrite(stream);\n      const {\n        state\x2C\n      } = stream[kState];\n      assert(state === 'writable' || state === 'erroring');\n      dequeueValue(controller);\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          state === 'writable') {\n        writableStreamUpdateBackpressure(\n          stream\x2C\n          writableStreamDefaultControllerGetBackpressure(controller));\n      }\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      if (stream[kState].state === 'writable')\n        writableStreamDefaultControllerClearAlgorithms(controller);\n      writableStreamFinishInFlightWriteWithError(stream\x2C error);\n    });\n\n}\n\nfunction writableStreamDefaultControllerProcessClose(controller) {\n  const {\n    closeAlgorithm\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n  writableStreamMarkCloseRequestInFlight(stream);\n  dequeueValue(controller);\n  assert(!queue.length);\n  const sinkClosePromise = ensureIsPromise(closeAlgorithm\x2C controller);\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  PromisePrototypeThen(\n    sinkClosePromise\x2C\n    () => writableStreamFinishInFlightClose(stream)\x2C\n    (error) => writableStreamFinishInFlightCloseWithError(stream\x2C error));\n}\n\nfunction writableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  return highWaterMark - queueTotalSize;\n}\n\nfunction writableStreamDefaultControllerGetChunkSize(controller\x2C chunk) {\n  try {\n    return FunctionPrototypeCall(\n      controller[kState].sizeAlgorithm\x2C\n      undefined\x2C\n      chunk);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return 1;\n  }\n}\n\nfunction writableStreamDefaultControllerErrorIfNeeded(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'writable')\n    writableStreamDefaultControllerError(controller\x2C error);\n}\n\nfunction writableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'writable');\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  writableStreamStartErroring(stream\x2C error);\n}\n\nfunction writableStreamDefaultControllerClose(controller) {\n  enqueueValueWithSize(controller\x2C kCloseSentinel\x2C 0);\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].writeAlgorithm = undefined;\n  controller[kState].closeAlgorithm = undefined;\n  controller[kState].abortAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction writableStreamDefaultControllerGetBackpressure(controller) {\n  return writableStreamDefaultControllerGetDesiredSize(controller) <= 0;\n}\n\nfunction writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  const {\n    queue\x2C\n    started\x2C\n    stream\x2C\n  } = controller[kState];\n  if (!started || stream[kState].inFlightWriteRequest.promise !== undefined)\n    return;\n\n  if (stream[kState].state === 'erroring') {\n    writableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (!queue.length)\n    return;\n\n  const value = peekQueueValue(controller);\n  if (value === kCloseSentinel)\n    writableStreamDefaultControllerProcessClose(controller);\n  else\n    writableStreamDefaultControllerProcessWrite(controller\x2C value);\n}\n\nfunction setupWritableStreamDefaultControllerFromSink(\n  stream\x2C\n  sink\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createWritableStreamDefaultController();\n  const start = sink?.start;\n  const write = sink?.write;\n  const close = sink?.close;\n  const abort = sink?.abort;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C sink\x2C controller) :\n    nonOpStart;\n  const writeAlgorithm = write ?\n    FunctionPrototypeBind(write\x2C sink) :\n    nonOpWrite;\n  const closeAlgorithm = close ?\n    FunctionPrototypeBind(close\x2C sink) : nonOpCancel;\n  const abortAlgorithm = abort ?\n    FunctionPrototypeBind(abort\x2C sink) : nonOpCancel;\n  setupWritableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    writeAlgorithm\x2C\n    closeAlgorithm\x2C\n    abortAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction setupWritableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  writeAlgorithm\x2C\n  closeAlgorithm\x2C\n  abortAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(isWritableStream(stream));\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    abortAlgorithm\x2C\n    abortReason: undefined\x2C\n    closeAlgorithm\x2C\n    highWaterMark\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    abortController: new AbortController()\x2C\n    sizeAlgorithm\x2C\n    started: false\x2C\n    stream\x2C\n    writeAlgorithm\x2C\n  };\n  stream[kState].controller = controller;\n\n  writableStreamUpdateBackpressure(\n    stream\x2C\n    writableStreamDefaultControllerGetBackpressure(controller));\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDealWithRejection(stream\x2C error);\n    });\n}\n\nmodule.exports = {\n  WritableStream\x2C\n  WritableStreamDefaultWriter\x2C\n  WritableStreamDefaultController\x2C\n  TransferredWritableStream\x2C\n\n  // Exported Brand Checks\n  isWritableStream\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  isWritableStreamLocked\x2C\n  setupWritableStreamDefaultWriter\x2C\n  writableStreamAbort\x2C\n  writableStreamClose\x2C\n  writableStreamUpdateBackpressure\x2C\n  writableStreamStartErroring\x2C\n  writableStreamRejectCloseAndClosedPromiseIfNeeded\x2C\n  writableStreamMarkFirstWriteRequestInFlight\x2C\n  writableStreamMarkCloseRequestInFlight\x2C\n  writableStreamHasOperationMarkedInFlight\x2C\n  writableStreamFinishInFlightWriteWithError\x2C\n  writableStreamFinishInFlightWrite\x2C\n  writableStreamFinishInFlightCloseWithError\x2C\n  writableStreamFinishInFlightClose\x2C\n  writableStreamFinishErroring\x2C\n  writableStreamDealWithRejection\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamAddWriteRequest\x2C\n  writableStreamDefaultWriterWrite\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterGetDesiredSize\x2C\n  writableStreamDefaultWriterEnsureReadyPromiseRejected\x2C\n  writableStreamDefaultWriterEnsureClosedPromiseRejected\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterClose\x2C\n  writableStreamDefaultWriterAbort\x2C\n  writableStreamDefaultControllerWrite\x2C\n  writableStreamDefaultControllerProcessWrite\x2C\n  writableStreamDefaultControllerProcessClose\x2C\n  writableStreamDefaultControllerGetDesiredSize\x2C\n  writableStreamDefaultControllerGetChunkSize\x2C\n  writableStreamDefaultControllerErrorIfNeeded\x2C\n  writableStreamDefaultControllerError\x2C\n  writableStreamDefaultControllerClose\x2C\n  writableStreamDefaultControllerClearAlgorithms\x2C\n  writableStreamDefaultControllerGetBackpressure\x2C\n  writableStreamDefaultControllerAdvanceQueueIfNeeded\x2C\n  setupWritableStreamDefaultControllerFromSink\x2C\n  setupWritableStreamDefaultController\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x3b5adb58207e,127,0,36611,C0O0C4O36611,,
code-creation,Function,10,85067,0x3b5adb584f1e,1564, node:internal/webstreams/writablestream:1:1,0x3b5adb581ff8,~
code-source-info,0x3b5adb584f1e,127,0,36611,C0O0C381O68C387O90C393O113C399O138C405O163C410O189C416O213C422O231C428O248C434O268C439O278C444O470C447O470C452O470C457O338C463O367C469O394C475O420C481O443C487O527C490O527C495O509C501O651C504O651C509O568C515O614C520O626C525O708C528O708C533O688C539O818C542O818C547O750C552O766C557O779C562O796C568O1166C571O1166C576O873C582O890C588O906C594O925C600O949C606O973C612O997C618O1013C623O1029C629O1049C635O1067C641O1081C647O1102C653O1117C659O1131C665O1145C671O1154C677O1235C680O1235C685O1214C691O1289C694O1289C698O1289C700O1333C703O1333C707O1333C709O1374C712O1374C716O1374C718O1415C721O1415C725O1415C745O2379C755O2414C787O5297C797O5457C807O6298C817O6480C851O2353C853O6695C856O6733C868O6756C874O6786C880O6816C886O6850C890O6695C895O8091C900O8101C904O8115C926O8167C936O8215C986O11501C1020O8128C1022O11754C1025O11805C1037O11828C1043O11858C1049O11894C1055O11924C1061O11954C1067O11990C1073O12020C1077O11754C1100O12089C1110O12141C1120O12254C1132O12413C1160O13209C1194O12046C1196O13343C1199O13398C1211O13426C1217O13457C1223O13487C1227O13343C1232O13742C1235O13742C1239O13742C1241O13814C1244O13814C1248O13814C1250O13903C1253O13903C1257O13903C1259O34686C1266O34707C1272O34725C1278O34756C1284O34791C1290O34848C1296O34868C1302O34905C1308O34939C1314O34965C1320O35001C1326O35024C1332O35047C1338O35083C1344O35114C1350O35167C1356O35214C1362O35256C1368O35300C1374O35346C1380O35383C1386O35429C1392O35466C1398O35498C1404O35533C1410O35572C1416O35605C1422O35641C1428O35679C1434O35724C1440O35781C1446O35839C1452O35895C1458O35931C1464O35967C1470O36007C1476O36054C1482O36101C1488O36150C1494O36197C1500O36245C1506O36285C1512O36325C1518O36375C1524O36425C1534O36480C1544O36528C1554O34701C1563O36610,,
code-creation,Function,10,85121,0x3b5adb58581e,16,<instance_members_initializer> node:internal/webstreams/writablestream:493:3,0x3b5adb583878,~
code-source-info,0x3b5adb58581e,127,12088,12131,C3O12098C15O12131,,
code-creation,Function,10,85132,0x3b5adb58589e,16,<instance_members_initializer> node:internal/webstreams/writablestream:349:3,0x3b5adb583580,~
code-source-info,0x3b5adb58589e,127,8166,8205,C3O8176C15O8205,,
code-creation,Function,10,85143,0x3b5adb585916,16,<instance_members_initializer> node:internal/webstreams/writablestream:122:3,0x3b5adb583138,~
code-source-info,0x3b5adb585916,127,2378,2404,C3O2388C15O2404,,
tick,0x7f0810b84300,85162,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b176419,0x7f07fc043395,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x7f0810fb379d,85177,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x25349b176419,0x7f07fc043395,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,LazyCompile,10,85437,0x3b5adb588f6e,14,isBrandCheck node:internal/webstreams/util:112:22,0x25349b17e4a0,~
code-source-info,0x3b5adb588f6e,126,2398,2541,C0O2398C9O2410C13O2539,,
tick,0x110784e,85754,0,0x0,0,0x1238300,0x25349b176a37,0x7f07fc043395,0x7f07fc0439d1,0x25349b16a92f,0x7f07fc043395,0x7f07fc0439d1,0x25349b1619ea,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,85959,0x3b5adb58a11e,5, node:internal/webstreams/queuingstrategies:1:1,0x3b5adb589e28,~
script-source,128,node:internal/webstreams/queuingstrategies,'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_THIS\x2C\n    ERR_MISSING_OPTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  customInspect\x2C\n  isBrandCheck\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst isByteLengthQueuingStrategy =\n  isBrandCheck('ByteLengthQueuingStrategy');\n\nconst isCountQueuingStrategy =\n  isBrandCheck('CountQueuingStrategy');\n\n/**\n * @callback QueuingStrategySize\n * @param {any} chunk\n * @returns {number}\n */\n\n/**\n * @typedef {{\n *   highWaterMark : number\x2C\n *   size? : QueuingStrategySize\x2C\n * }} QueuingStrategy\n */\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst byteSizeFunction = function size(chunk) { return chunk.byteLength; };\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst countSizeFunction = function size() { return 1; };\n\n/**\n * @type {QueuingStrategy}\n */\nclass ByteLengthQueuingStrategy {\n  [kType] = 'ByteLengthQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return byteSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ByteLengthQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\n/**\n * @type {QueuingStrategy}\n */\nclass CountQueuingStrategy {\n  [kType] = 'CountQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return countSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(CountQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\nmodule.exports = {\n  ByteLengthQueuingStrategy\x2C\n  CountQueuingStrategy\x2C\n};\n
code-source-info,0x3b5adb58a11e,128,0,3637,C0O0C4O3637,,
code-creation,Function,10,86156,0x3b5adb58ae16,404, node:internal/webstreams/queuingstrategies:1:1,0x3b5adb58a098,~
code-source-info,0x3b5adb58ae16,128,0,3637,C0O0C35O25C40O51C45O162C48O162C53O162C58O111C64O133C70O259C73O259C78O222C83O234C88O350C91O350C96O296C102O313C107O329C113O338C119O418C122O418C127O398C133O489C136O489C140O489C142O566C145O566C149O566C151O882C155O882C157O1018C161O1018C180O1122C190O1168C209O2049C244O2238C256O2268C262O2297C266O2189C288O2390C298O2431C317O3293C352O3477C364O3507C370O3536C374O3433C379O3562C386O3583C392O3612C398O3577C403O3636,,
code-creation,Function,10,86181,0x3b5adb58b0ce,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:116:3,0x3b5adb58a5c8,~
code-source-info,0x3b5adb58b0ce,128,2389,2421,C3O2399C15O2421,,
code-creation,Function,10,86192,0x3b5adb58b146,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:60:3,0x3b5adb58a3c0,~
code-source-info,0x3b5adb58b146,128,1121,1158,C3O1131C15O1158,,
code-creation,LazyCompile,10,86438,0x3b5adb58bcfe,251,promisify node:internal/util:324:19,0x136fed702318,~
script-source,16,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEnumerableProperty\x2C\n};\n
code-source-info,0x3b5adb58bcfe,16,8845,10349,C0O8845C17O8907C25O8947C33O8971C38O8950C55O9007C68O9007C73O9050C80O9063C82O9062C87O9107C94O9116C96O9115C100O9148C110O9148C115O9200C126O9232C136O9273C143O9207C148O9339C149O9502C156O9511C158O9510C161O9502C163O10066C174O10091C180O10091C185O10066C190O10127C201O10152C211O10191C218O10127C223O10258C234O10301C240O10301C245O10265C250O10347,,
tick,0x7f0810b84306,87174,0,0x0,3,0x1229670,0x25349b161a0a,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,LazyCompile,10,87314,0x3b5adb58d316,65,EventEmitterMixin node:internal/event_target:962:27,0x39a167d8cf28,~
script-source,44,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol\x2C kEnumerableProperty } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kDefaultPrevented] = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTimestamp];\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kBubbles];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kComposed];\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kPropagationStopped];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler ?? null;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x3b5adb58d316,44,25717,26139,C0O25769C23O25953C30O25985C33O25998C38O25953C43O26012C47O26045C52O26086C57O26045C62O26112C64O26137,,
tick,0x7f0810fb3696,88598,0,0x0,3,0x1229670,0x25349b161a1c,0x7f07fc043395,0x7f07fc0439d1,0x25349b15d70d,0x7f07fc043395,0x7f07fc0439d1,0x25349b15cf12,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4601,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
tick,0x1192a47,88955,1,0xb83830,2,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b4612,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,89088,0x3b5adb590086,5, node:internal/modules/esm/translators:1:1,0x3b5adb58fc20,~
script-source,129,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }\x2C assertions) {\n  return asyncESM.esmLoader.import(specifier\x2C\n                                   asyncESM.esmLoader.getBaseURL(url)\x2C\n                                   assertions);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C {\n      url: wrap.url\n    })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x3b5adb590086,129,0,10778,C0O0C4O10778,,
code-creation,Function,10,89613,0x3b5adb590826,715, node:internal/modules/esm/translators:1:1,0x3b5adb590000,~
code-source-info,0x3b5adb590826,129,0,10778,C0O0C180O25C186O50C192O71C198O82C204O95C210O119C216O152C222O166C228O187C233O198C239O209C245O235C251O259C257O288C268O326C274O372C275O372C277O517C283O517C288O500C294O564C300O564C305O540C311O549C317O641C323O641C328O591C334O607C340O627C346O731C352O731C357O700C363O713C369O797C375O797C379O797C381O850C387O850C391O850C393O939C399O939C404O916C410O931C416O967C422O967C427O1000C440O1001C446O967C448O1081C454O1081C459O1053C465O1185C471O1185C476O1211C481O1117C487O1147C493O1251C499O1251C504O1227C510O1319C513O1319C517O1319C519O1374C522O1359C528O1403C534O1403C538O1403C540O1471C546O1471C551O1451C557O1532C563O1532C568O1516C574O1567C575O1567C577O1891C579O1891C585O1906C587O1926C591O1941C593O1964C597O1997C598O1997C600O3099C613O3099C619O4367C626O4376C629O4359C631O4409C635O4409C637O4428C650O4428C656O7520C669O7520C675O7969C688O7969C694O9917C707O9917C714O10777,,
code-creation,Eval,10,89821,0x3b5adb591d2e,5, node:internal/modules/esm/create_dynamic_module:1:1,0x3b5adb591b58,~
script-source,130,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x3b5adb591d2e,130,0,1756,C0O0C4O1756,,
code-creation,Function,10,89926,0x3b5adb591f56,111, node:internal/modules/esm/create_dynamic_module:1:1,0x3b5adb591ca8,~
code-source-info,0x3b5adb591f56,130,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
tick,0x1286c68,90023,1,0xb83830,6,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x3b5adb5909a9,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b4612,0x7f07fc043395,0x7f07fc0439d1,0x109acf0b282c,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,90390,0x3b5adb592ece,5, node:internal/vm/module:1:1,0x3b5adb592988,~
script-source,131,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x3b5adb592ece,131,0,12310,C0O0C4O12310,,
code-creation,Function,10,90966,0x3b5adb59412e,872, node:internal/vm/module:1:1,0x3b5adb592e48,~
code-source-info,0x3b5adb59412e,131,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,91001,0x3b5adb59466e,30,<instance_members_initializer> node:internal/vm/module:256:3,0x3b5adb5934b8,~
code-source-info,0x3b5adb59466e,131,6796,6832,C3O6805C29O6832,,
tick,0x111a6fb,91089,1,0xb83830,6,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x109acf0b285f,0x7f07fc043395,0x7f07fc0439d1,0x109acf0add59,0x109acf086aa5,0x109acf085d75,0x109acf0a9b4c,0x109acf08a24c,0x109acf085afd
code-creation,LazyCompile,10,91243,0x3b5adb595bae,156,ESMLoader node:internal/modules/esm/loader:118:14,0x109acf0b3bf0,~
code-source-info,0x3b5adb595bae,106,2925,3502,C9O2925C28O2934C38O2938C44O2987C54O2987C58O3044C68O3048C74O3106C84O3106C88O3160C98O3164C105O3218C114O3233C118O3276C123O3284C134O3284C140O3451C146O3485C155O3501,,
code-creation,LazyCompile,10,91298,0x3b5adb5971de,27,ModuleMap node:internal/modules/esm/module_map:17:14,0x109acf0b6430,~
code-source-info,0x3b5adb5971de,107,518,535,C3O524C7O530C11O524C26O534,,
code-creation,LazyCompile,10,91348,0x3b5adb597486,13,desc.value node:internal/per_context/primordials:334:32,0x2842ea089e68,~
code-source-info,0x3b5adb597486,6,9631,9690,C0O9648C7O9655C12O9678,,
code-creation,LazyCompile,10,91376,0x3b5adb59758e,13,SafeIterator node:internal/per_context/primordials:279:16,0x2842ea0898b8,~
code-source-info,0x3b5adb59758e,6,7920,7980,C0O7939C3O7956C7O7954C12O7979,,
code-creation,LazyCompile,10,91412,0x3b5adb5976c6,13,next node:internal/per_context/primordials:282:9,0x2842ea089980,~
code-source-info,0x3b5adb5976c6,6,7989,8034,C0O8000C3O8017C8O8007C12O8028,,
code-creation,LazyCompile,10,91601,0x3b5adb597946,152,deprecate node:internal/util:96:19,0x136fed701bc8,~
code-source-info,0x3b5adb597946,16,2408,3584,C0O2408C26O2428C31O2440C37O2454C42O2470C44O2480C45O2535C53O2573C61O2595C66O2576C83O2631C87O2659C100O2659C105O2705C106O2705C108O3280C121O3280C126O3320C129O3327C135O3520C141O3546C145O3541C149O3564C151O3582,,
code-creation,LazyCompile,10,91685,0x3b5adb597f06,28,getEmbedderOptions node:internal/options:32:28,0x2989f3599808,~
code-source-info,0x3b5adb597f06,92,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,91852,0x3b5adb5981ae,315,Module._initPaths node:internal/modules/cjs/loader:1227:29,0x109acf0acd90,~
code-source-info,0x3b5adb5981ae,103,38405,39361,C0O38428C9O38448C14O38452C22O38466C28O38466C33O38505C42O38525C47O38529C55O38541C61O38541C66O38736C74O38752C77O38757C85O38773C93O38757C103O38795C106O38800C114O38816C125O38800C131O38856C140O38857C143O38862C157O38862C169O38901C173O38920C180O38949C183O38954C191O38954C198O38920C203O38996C210O39025C213O39030C221O39030C228O38996C233O39073C237O39093C244O39127C249O39155C254O39186C257O39191C262O39155C270O39209C273O39127C279O39093C284O39232C286O39244C292O39305C297O39326C302O39346C305O39326C309O39324C314O39360,,
code-creation,Function,11,91976,0x7f07fc043fc0,3184,normalizeString node:path:66:25,0x273b979ba7c0,^
code-source-info,0x7f07fc043fc0,41,2161,4085,,,
code-creation,Function,11,92001,0x7f07fc044cc0,572,internalBinding node:internal/bootstrap/loaders:164:45,0x2842ea08f838,^
code-source-info,0x7f07fc044cc0,9,5115,5353,,,
code-creation,Function,11,92019,0x7f07fc044f80,180,isBrandCheck node:internal/webstreams/util:112:22,0x25349b17e4a0,^
code-source-info,0x7f07fc044f80,126,2398,2541,,,
code-creation,Function,11,92037,0x7f07fc0450c0,252,SafeMap node:internal/per_context/primordials:360:16,0x2842ea089f10,^
code-source-info,0x7f07fc0450c0,6,10335,10352,,,
code-creation,Function,11,92051,0x7f07fc045240,108,next node:internal/per_context/primordials:282:9,0x2842ea089980,^
code-source-info,0x7f07fc045240,6,7989,8034,,,
tick,0x15cd2d5,92156,0,0x0,0,0x109acf08fd74,0x3b5adb59826d,0x109acf0a9b6a,0x109acf08a24c,0x109acf085afd
code-creation,Eval,10,92241,0x3b5adb59b60e,5, node:internal/modules/run_main:1:1,0x3b5adb59b3e8,~
script-source,132,node:internal/modules/run_main,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return esmLoader.import(main\x2C undefined\x2C ObjectCreate(null));\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  process.on('exit'\x2C handleProcessExit);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handleProcessExit);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x3b5adb59b60e,132,0,2537,C0O0C4O2537,,
code-creation,Function,10,92385,0x3b5adb59b8f6,178, node:internal/modules/run_main:1:1,0x3b5adb59b588,~
code-source-info,0x3b5adb59b8f6,132,0,2537,C0O0C66O25C72O41C78O101C84O101C89O149C95O157C101O169C107O228C113O228C118O209C124O270C130O270C134O270C136O320C142O320C147O297C153O2469C160O2490C166O2515C172O2484C177O2536,,
code-creation,LazyCompile,10,92522,0x3b5adb59c126,163,initializeESMLoader node:internal/bootstrap/pre_execution:533:29,0x109acf088228,~
code-source-info,0x3b5adb59c126,97,16507,17595,C0O16589C6O16589C13O16638C16O16634C21O16632C25O16656C30O16660C34O16680C40O16709C41O16716C42O16816C48O16816C53O16732C58O16772C63O16862C69O16862C74O17063C79O17021C83O17133C88O17094C92O17299C100O17303C106O17419C112O17419C117O17368C122O17376C127O17394C132O17465C138O17465C143O17484C145O17494C149O17508C151O17528C155O17552C157O17571C162O17594,,
code-creation,LazyCompile,10,92571,0x3b5adb59c33e,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x109acf0ac280,~
code-source-info,0x3b5adb59c33e,103,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,92603,0x3b5adb59c3e6,21,assert node:internal/assert:11:16,0x136fed71bfe8,~
script-source,21,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x3b5adb59c3e6,21,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,92665,0x3b5adb59c5e6,53,loadPreloadModules node:internal/bootstrap/pre_execution:576:28,0x109acf088318,~
code-source-info,0x3b5adb59c5e6,97,18071,18391,C0O18158C8O18158C13O18189C15O18226C21O18233C26O18309C32O18309C37O18309C42O18276C47O18353C52O18390,,
code-creation,LazyCompile,10,92698,0x3b5adb59c7ce,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:568:36,0x109acf0882c8,~
code-source-info,0x3b5adb59c7ce,97,17820,18042,C0O17827C8O17831C14O17876C17O17884C28O17884C34O17996C40O17996C45O18033C49O18041,,
code-creation,LazyCompile,10,92748,0x3b5adb59c8f6,80,executeUserEntryPoint node:internal/modules/run_main:70:31,0x3b5adb59b780,~
code-source-info,0x3b5adb59c8f6,132,2162,2467,C7O2178C14O2182C22O2212C25O2212C30O2258C33O2258C38O2294C40O2318C45O2329C50O2318C56O2430C61O2437C73O2437C79O2466,,
code-creation,LazyCompile,10,92786,0x3b5adb59cd26,68,resolveMainPath node:internal/modules/run_main:15:25,0x3b5adb59b640,~
code-source-info,0x3b5adb59cd26,132,398,812,C0O570C5O577C12O587C15O592C20O592C30O577C36O622C38O641C39O648C40O681C48O681C53O727C55O758C60O769C65O794C67O810,,
code-creation,LazyCompile,10,92922,0x3b5adb59cf26,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x109acf0ac5a0,~
code-source-info,0x3b5adb59cf26,103,14309,16913,C0O14362C5O14367C10O14367C16O14390C18O14417C26O14440C30O14460C36O14467C41O14480C42O14493C43O14518C45O14526C51O14537C57O14537C62O14535C66O14588C69O14595C76O14605C80O14619C82O14634C84O14647C85O14655C87O14691C93O14698C100O14709C103O14752C107O14759C111O14709C119O14772C121O14764C125O14794C127O14820C134O14856C137O14836C143O14925C145O14938C149O14930C154O15023C156O15028C160O15037C165O15052C172O15066C177O15071C179O15086C183O15140C186O15140C192O15180C194O15209C196O15232C197O15261C202O15266C207O15266C214O15301C216O15327C219O15327C224O15347C228O15375C229O15382C234O15409C238O15434C244O15470C249O15486C254O15486C262O15536C265O15547C272O15596C278O16210C283O16226C288O16226C296O16272C299O16283C304O16330C308O16401C312O16435C320O16460C325O16442C330O16482C342O16493C348O16551C354O16571C359O16656C363O16688C371O16713C376O16695C381O16733C396O16744C402O16800C406O16822C409O16829C416O16850C420O16868C422O16884C423O14947C428O14912C434O16898C435O16911,,
code-creation,LazyCompile,10,92983,0x3b5adb59d2d6,45,isAbsolute node:path:1156:13,0x273b979bad48,~
code-source-info,0x3b5adb59d2d6,41,35447,35593,C0O35460C8O35460C13O35506C19O35513C26O35531C31O35531C39O35570C41O35566C44O35589,,
code-creation,LazyCompile,10,93112,0x3b5adb59d4e6,85,stat node:internal/modules/cjs/loader:151:14,0x109acf0abb40,~
code-source-info,0x3b5adb59d4e6,103,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,93141,0x3b5adb59d626,3,toNamespacedPath node:path:1266:19,0x273b979bae38,~
code-source-info,0x3b5adb59d626,41,38608,38668,C0O38652C2O38664,,
code-creation,LazyCompile,10,93201,0x3b5adb59d716,42,toRealPath node:internal/modules/cjs/loader:393:20,0x109acf0abe10,~
code-source-info,0x3b5adb59d716,103,11292,11404,C0O11310C5O11320C10O11333C17O11353C20O11364C28O11383C35O11320C41O11402,,
tick,0x7f0810c1973d,93225,1,0xb34a60,6,0xd81050,0x3b5adb59d517,0x3b5adb59d001,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
code-creation,LazyCompile,10,93565,0x3b5adb59db2e,1042,realpathSync node:fs:2426:22,0x2b4a88fb6d08,~
script-source,81,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateCallback(cb);\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number | bigint} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C options\x2C callback)\n    let options = ObjectCreate(null);\n    if (arguments.length < 3) {\n      // This is fs.read(fd\x2C callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd\x2C {}\x2C callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.readSync(fd\x2C buffer\x2C options)\n    const options = offset || ObjectCreate(null);\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options\x2C {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\nconst emptyObj = ObjectCreate(null);\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options\x2C emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options\x2C {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null\x2C seenLinks[id]);\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 kb.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0x3b5adb59db2e,81,64450,68351,C0O64467C8O64497C12O64477C19O64510C25O64514C31O64536C35O64569C45O64584C51O64584C55O64603C61O64618C67O64618C74O64647C76O64655C78O64654C82O64702C86O64707C92O64709C101O64719C103O64748C105O64773C106O64799C115O64799C120O64839C129O64839C134O64878C137O64925C139O65000C141O65095C143O65171C145O65205C151O65222C157O65252C162O65334C168O65367C176O65375C183O65387C189O65395C197O65401C201O65412C207O65412C223O65395C228O65464C234O65464C238O65497C239O65513C243O65653C247O65649C252O65708C258O65708C264O65730C267O65754C269O65765C274O65794C280O65794C287O65830C289O65841C296O65853C298O65869C302O65891C309O65918C311O65929C317O65965C328O65929C340O65977C342O65995C355O65995C360O65993C364O66039C366O66052C370O66125C372O66138C384O66153C390O66155C402O66165C407O66183C413O66198C417O66206C425O66218C429O66187C442O66251C446O66259C454O66271C458O66240C465O66292C467O66313C469O66338C471O66384C478O66389C484O66391C493O66406C495O66439C502O66621C508O66632C514O66632C520O66674C528O66682C535O66710C541O66718C559O66718C565O66763C571O66763C575O66799C581O66822C585O66804C592O66842C593O66858C597O66874C604O66879C610O66881C619O66906C621O67060C624O67076C627O67086C633O67124C640O67153C649O67124C656O67183C664O67212C673O67183C680O67230C694O67245C700O67260C702O67273C707O67291C709O67313C714O67343C718O67390C726O67398C733O67414C739O67422C757O67422C762O67469C768O67469C772O67506C778O67527C796O67527C803O67582C809O67582C813O67625C819O67651C825O67651C832O67689C839O67694C845O67696C854O67727C860O67743C862O67757C866O67823C872O67838C880O67860C884O67860C891O67838C899O67919C905O67936C911O67968C916O68054C924O68081C929O68109C937O68117C944O68131C950O68139C958O68145C962O68156C968O68156C984O68139C989O68210C995O68210C999O68245C1000O68261C1004O65638C1010O68282C1017O68287C1023O68289C1032O68309C1036O68316C1041O68349,,
tick,0x7f0810b84300,97511,0,0x0,3,0x1229670,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
tick,0x7f0810fb382c,97522,0,0x0,3,0x1229670,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
tick,0x7f0810b9064f,97526,0,0x0,3,0x1229670,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
tick,0x7f0810c896e9,97531,0,0x0,3,0x1229670,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
code-creation,LazyCompile,10,97603,0x3b5adb5a4256,123,getOptions node:internal/fs/utils:315:20,0x2b4a88fbf330,~
script-source,82,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isDate\x2C\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigUint64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePrimitiveStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      buffer\n    );\n  }\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
code-source-info,0x3b5adb5a4256,82,7252,7875,C0O7282C14O7374C16O7396C17O7404C23O7443C29O7487C31O7511C35O7526C42O7561C48O7600C66O7606C71O7600C72O7693C79O7702C84O7720C87O7743C92O7720C96O7769C102O7797C107O7825C115O7797C120O7858C122O7873,,
tick,0x7f0810b84300,99010,0,0x0,3,0x1229670,0x3b5adb59db3a,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
code-creation,LazyCompile,10,99029,0x3b5adb5a6236,48,assertEncoding node:internal/fs/utils:152:24,0x2b4a88fbed38,~
code-source-info,0x3b5adb5a6236,82,3561,3738,C0O3576C6O3593C9O3600C14O3600C21O3643C24O3670C40O3676C45O3670C47O3737,,
code-creation,LazyCompile,10,99164,0x3b5adb5a634e,20,toPathIfFileURL node:internal/url:1561:25,0x273b979ad980,~
script-source,39,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateCallback\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = {};\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different key may result same after `toUSVString()`\x2C we only\n            // leave the later one. Refers to WPT.\n            if (visited[typedKey] !== undefined) {\n              this[searchParams][visited[typedKey]] = typedValue;\n            } else {\n              visited[typedKey] = ArrayPrototypePush(this[searchParams]\x2C\n                                                     typedKey\x2C\n                                                     typedValue) - 1;\n            }\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateCallback(callback);\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(input\x2C flags) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nfunction isURLThis(self) {\n  return (self !== undefined && self !== null && self[context] !== undefined);\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C\n          FunctionPrototypeBind(onParseError\x2C this\x2C input));\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  get href() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C\n          FunctionPrototypeBind(onParseError\x2C this\x2C input));\n  }\n\n  // readonly\n  get origin() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].username;\n  }\n\n  set username(username) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].password;\n  }\n\n  set password(password) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[searchParams];\n  }\n\n  get hash() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    // Yes\x2C lazy loading is annoying but because of circular\n    // references between the url\x2C internal/blob\x2C and buffer\n    // modules\x2C lazy loading here makes sure that things work.\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
code-source-info,0x3b5adb5a634e,39,43726,43847,C0O43746C3O43751C9O43785C11O43806C12O43809C15O43816C19O43845,,
tick,0x7f0810b84473,101432,0,0x0,3,0x1229670,0x3b5adb59db47,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
tick,0x7f0810b84300,101445,0,0x0,3,0x1229670,0x3b5adb59db47,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
code-creation,LazyCompile,10,101453,0x3b5adb5a9686,17,isURLInstance node:internal/url:1557:23,0x273b979ad930,~
code-source-info,0x3b5adb5a9686,39,43603,43700,C0O43623C3O43644C6O43669C12O43691C16O43698,,
code-creation,LazyCompile,10,101521,0x3b5adb5a97e6,81, node:internal/fs/utils:669:38,0x2b4a88fbfd58,~
code-source-info,0x3b5adb5a97e6,82,18197,18467,C14O18230C22O18263C25O18263C31O18289C36O18320C49O18295C54O18289C55O18385C68O18385C74O18422C76O18451C78O18451C80O18466,,
code-creation,LazyCompile,10,101570,0x3b5adb5a99f6,110, node:internal/fs/utils:358:35,0x2b4a88fbf3d0,~
code-source-info,0x3b5adb5a99f6,82,8603,9192,C16O8667C21O8720C26O8720C31O8814C37O8837C41O8865C45O8882C51O8882C60O8933C64O8954C69O8954C76O8999C77O9006C78O9026C94O9026C100O9140C104O9162C106O9162C107O9179C109O9190,,
code-creation,LazyCompile,10,101603,0x3b5adb5a9b6e,16,isUint8Array node:internal/util/types:13:22,0x136fed7033f0,~
script-source,17,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0x3b5adb5a9b6e,17,257,342,C0O269C5O276C12O323C15O340,,
tick,0x7f0810b9064b,101825,0,0x0,3,0x1229670,0x3b5adb5a9a10,0x3b5adb5a982a,0x3b5adb59db61,0x3b5adb59d739,0x3b5adb59d051,0x3b5adb59cd44,0x3b5adb59c90f,0x109acf085b21
code-creation,LazyCompile,10,101871,0x3b5adb5a9fe6,61,splitRoot node:fs:2380:33,0x2b4a88fb6c18,~
code-source-info,0x3b5adb5a9fe6,81,63252,63444,C0O63277C2O63288C6O63282C11O63309C16O63313C24O63351C26O63347C31O63379C44O63386C49O63418C50O63298C55O63264C58O63429C60O63440,,
code-creation,LazyCompile,10,101906,0x3b5adb5aa11e,20,nextPart node:fs:2413:31,0x2b4a88fb6cb8,~
code-source-info,0x3b5adb5aa11e,81,64159,64217,C0O64172C14O64179C19O64213,,
code-creation,LazyCompile,10,101969,0x3b5adb5aa37e,63,handleErrorFromBinding node:internal/fs/utils:341:32,0x2b4a88fbf380,~
code-source-info,0x3b5adb5aa37e,82,7964,8462,C0O7982C6O8045C11O8045C16O8067C24O8067C29O8124C31O8124C32O8149C38O8377C43O8404C51O8377C56O8450C60O8440C62O8461,,
code-creation,LazyCompile,10,102007,0x3b5adb5aa4ce,34,isFileType node:fs:206:20,0x2b4a88fb4980,~
code-source-info,0x3b5adb5aa4ce,81,5332,5573,C0O5466C2O5471C6O5478C10O5512C15O5519C20O5535C22O5550C24O5548C30O5558C33O5571,,
code-creation,LazyCompile,10,102107,0x3b5adb5aa736,72,encodeRealpathResult node:fs:2389:30,0x2b4a88fb6c68,~
code-source-info,0x3b5adb5aa736,81,63478,63736,C0O63500C4O63525C10O63545C17O63554C22O63570C24O63584C25O63604C30O63611C35O63611C41O63639C48O63648C53O63668C55O63684C56O63707C61O63724C66O63707C71O63734,,
code-creation,LazyCompile,10,102182,0x3b5adb5aa8be,109,shouldUseESMLoader node:internal/modules/run_main:30:28,0x3b5adb59b690,~
code-source-info,0x3b5adb5aa8be,132,841,1401,C0O875C8O875C13O918C15O938C16O950C17O993C25O993C30O1050C32O1082C37O1098C38O1110C39O1158C45O1174C51O1174C58O1221C59O1233C60O1236C66O1253C72O1253C79O1300C80O1313C81O1328C86O1328C91O1358C93O1376C98O1381C105O1386C108O1399,,
code-creation,LazyCompile,10,102240,0x3b5adb5aaade,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x109acf0abd20,~
code-source-info,0x3b5adb5aaade,103,8919,9437,C0O8962C7O8996C10O8962C16O9008C18O9035C25O9090C28O9052C34O9100C47O9112C54O9168C61O9207C66O9211C70O9172C77O9236C78O9249C79O9268C84O9292C86O9290C90O9268C95O9302C97O9313C104O9334C110O9353C116O9370C117O9397C119O9397C124O9026C127O9422C128O9435,,
code-creation,LazyCompile,10,102315,0x3b5adb5aae3e,234,readPackage node:internal/modules/cjs/loader:290:21,0x109acf0abcd0,~
code-source-info,0x3b5adb5aae3e,103,8102,8892,C0O8137C5O8142C13O8142C20O8200C25O8217C30O8217C36O8234C38O8262C40O8278C41O8297C46O8315C51O8315C57O8353C63O8366C72O8392C77O8402C79O8432C84O8449C91O8449C97O8475C98O8488C102O8521C107O8521C112O8559C117O8580C125O8605C133O8633C141O8664C149O8692C160O8708C165O8725C170O8725C176O8754C178O8770C190O8791C195O8798C199O8814C207O8843C213O8854C220O8865C224O8861C227O8824C231O8878C233O8878,,
code-creation,LazyCompile,10,102405,0x3b5adb5ab146,199,read node:internal/modules/package_json_reader:16:14,0x109acf0b1940,~
code-source-info,0x3b5adb5ab146,104,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,102651,0x3b5adb5ab67e,619,Module._load node:internal/modules/cjs/loader:757:24,0x109acf0ac880,~
code-source-info,0x3b5adb5ab67e,103,23190,26108,C0O23224C2O23253C6O23271C14O23331C23O23271C28O23561C42O23572C47O23604C54O23624C58O23657C60O23714C63O23721C70O23727C74O23745C76O23787C88O23787C93O23857C99O23875C102O23882C106O23925C107O23954C111O23962C112O23977C119O24005C121O24063C124O24070C138O24070C144O24115C152O24119C159O24210C167O24210C173O24265C178O24265C184O24300C189O24311C198O24343C205O24349C210O24343C211O24416C215O24424C216O24453C219O24460C226O24466C230O24480C232O24518C244O24518C249O24584C255O24626C260O24640C265O24640C271O24665C273O24709C279O24725C282O24732C286O24775C287O24782C288O24807C294O24854C298O24862C299O24888C304O24888C310O24927C315O24934C324O24969C328O24977C329O25063C344O25079C350O25112C354O25130C359O25149C363O25163C365O25173C369O25187C372O25194C379O25211C383O25223C387O25255C394O25303C398O25334C403O25359C409O25359C414O25379C426O25385C427O25412C432O25431C436O25445C444O25452C446O25469C450O25505C458O25533C460O25586C467O25592C475O25612C481O25616C487O25666C493O25666C499O25717C501O25727C506O25749C522O25749C529O25843C537O25870C541O25885C547O25870C555O25912C559O25940C565O25912C573O25970C575O25949C580O26016C586O26044C594O26053C598O26016C614O26098C618O26106,,
tick,0x11b4edb,102794,0,0x0,2,0x1229670,0x3b5adb5ab708,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,102898,0x3b5adb5abde6,809,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x109acf0ac908,~
code-source-info,0x3b5adb5abde6,103,26145,29133,C0O26184C10O26188C19O26241C23O26254C29O26254C36O26291C38O26306C39O26318C41O26328C51O26387C57O26412C63O26391C69O26447C79O26447C88O26501C96O26501C105O26558C111O26571C119O26571C128O26627C136O26627C142O26679C144O26721C151O26770C164O26770C170O26801C173O26835C175O26850C181O26856C185O26840C190O26902C198O26907C202O26922C206O26948C212O26948C217O26939C221O27002C225O27009C231O27009C238O27075C240O27094C244O27080C249O27121C257O27167C262O27126C269O27187C277O27224C282O27187C287O27103C292O27062C295O26865C300O26822C305O27283C311O27312C315O27327C321O27327C330O27384C340O27441C348O27390C353O27384C356O27470C360O27485C366O27485C373O27530C380O27540C389O27558C390O27569C397O27573C402O27602C406O27626C412O27602C420O27657C428O27661C441O27706C447O27748C453O27779C457O27800C463O27779C471O27845C478O27748C485O27868C491O27894C497O27713C502O27900C516O27933C520O27939C528O27944C533O27984C539O27990C543O27984C544O28031C546O28031C547O28128C551O28128C556O28178C560O28178C566O28210C568O28251C570O28259C575O28286C583O28293C589O28306C596O28312C604O28312C609O28268C613O28352C617O28359C625O28380C629O28400C631O28420C632O28506C636O28513C654O28513C660O28557C662O28571C664O28587C665O28611C668O28635C673O28647C677O28705C683O28745C692O28764C698O28705C703O28666C709O28686C715O28686C721O28617C724O28789C730O28812C742O28843C749O28850C754O28861C756O28879C763O28920C771O28920C776O28904C780O29031C788O29031C794O29053C796O29062C800O29086C802O29103C806O29121C808O29121,,
code-creation,LazyCompile,10,102966,0x3b5adb5ac39e,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x2842ea08fb18,~
code-source-info,0x3b5adb5ac39e,9,7354,7450,C0O7377C5O7390C10O7394C15O7394C21O7407C23O7425C27O7446,,
code-creation,LazyCompile,10,103040,0x3b5adb5ac656,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x109acf0ac750,~
code-source-info,0x3b5adb5ac656,103,19946,21123,C0O19968C5O19985C10O19985C17O20022C25O20022C30O20066C31O20078C32O20121C39O20125C47O20159C52O20185C59O20192C66O20205C72O20205C80O20239C87O20256C93O20256C101O20290C108O20309C114O20322C120O20322C128O20356C133O20387C138O20404C145O20414C152O20421C161O20439C166O20475C171O20447C177O20501C191O20501C196O20565C202O20572C212O20591C213O20638C217O20661C223O20675C229O20846C234O20858C248O20858C253O20913C255O20930C256O20938C264O21005C272O20938C277O21031C286O21032C289O21037C294O21052C299O21037C311O21066C319O21066C324O21104C326O21121,,
code-creation,LazyCompile,10,103093,0x3b5adb5ac91e,89,logger node:internal/util/debuglog:95:18,0x136fed71d540,~
code-source-info,0x3b5adb5ac91e,22,2869,3064,C0O2869C3O2901C24O2925C30O2942C34O2932C38O2947C39O2962C45O2979C51O2988C55O2969C60O2993C61O3009C65O3016C72O3029C77O3025C83O3016C88O3054,,
code-creation,LazyCompile,10,103126,0x3b5adb5aca5e,3, node:internal/per_context/primordials:285:21,0x2842ea089a28,~
code-source-info,0x3b5adb5aca5e,6,8055,8084,C0O8066C2O8078,,
code-creation,LazyCompile,10,103172,0x3b5adb5acb36,140,debug node:internal/util/debuglog:76:15,0x136fed71d4a0,~
code-source-info,0x3b5adb5acb36,22,2357,2751,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C75O2612C81O2629C85O2619C89O2634C90O2649C96O2666C102O2675C106O2656C111O2680C112O2696C116O2703C123O2716C128O2712C134O2703C139O2741,,
code-creation,LazyCompile,10,103209,0x3b5adb5acce6,41,init node:internal/util/debuglog:72:16,0x136fed71d450,~
code-source-info,0x3b5adb5acce6,22,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,103238,0x3b5adb5acdd6,2,testEnabled node:internal/util/debuglog:32:19,0x109acf09ef08,~
code-source-info,0x3b5adb5acdd6,22,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,103297,0x3b5adb5acf6e,116,debuglogImpl node:internal/util/debuglog:49:22,0x136fed71d2a0,~
code-source-info,0x3b5adb5acf6e,22,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,103328,0x3b5adb5ad126,10, node:internal/modules/cjs/loader:272:66,0x109acf0ac550,~
code-source-info,0x3b5adb5ad126,103,7709,7734,C0O7721C2O7727C9O7733,,
code-creation,LazyCompile,10,103350,0x3b5adb5ad1d6,2,noop node:internal/util/debuglog:47:14,0x136fed71d250,~
code-source-info,0x3b5adb5ad1d6,22,1419,1427,C1O1426,,
code-creation,LazyCompile,10,103385,0x3b5adb5ad316,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x109acf0abf00,~
code-source-info,0x3b5adb5ad316,103,12270,12533,C0O12283C4O12296C5O12309C6O12324C12O12354C16O12363C17O12384C24O12387C29O12410C36O12413C44O12455C47O12470C52O12470C59O12478C62O12483C66O12476C69O12487C72O12508C73O12521C75O12532,,
code-creation,LazyCompile,10,103452,0x3b5adb5ad556,232,trySelf node:internal/modules/cjs/loader:441:17,0x109acf0abf50,~
code-source-info,0x3b5adb5ad556,103,12551,13375,C0O12577C4O12594C5O12607C6O12648C9O12648C17O12625C22O12636C27O12686C31O12702C37O12725C38O12738C39O12756C47O12775C48O12788C49O12796C51O12829C55O12821C60O12841C65O12867C70O12913C82O12871C89O12929C94O12947C97O12981C102O12986C107O12947C112O12945C118O13010C119O13023C123O13041C128O13070C133O13099C138O13121C142O13099C149O13163C152O13163C159O13190C168O13070C180O13048C185O13227C197O13248C200O13254C207O13259C212O13293C219O13337C223O13299C228O13293C229O13361C231O13361,,
code-creation,LazyCompile,10,103518,0x3b5adb5ad7e6,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x109acf0a7428,~
code-source-info,0x3b5adb5ad7e6,102,1151,1431,C0O1187C5O1200C10O1204C15O1204C21O1221C26O1228C35O1258C43O1258C48O1384C53O1384C57O1414C59O1425C61O1430,,
code-creation,LazyCompile,10,103565,0x3b5adb5ae0ce,94,Module node:internal/modules/cjs/loader:172:16,0x109acf0abbe0,~
code-source-info,0x3b5adb5ae0ce,103,5284,5521,C14O5306C16O5314C20O5322C22O5334C25O5339C30O5339C35O5332C39O5354C40O5367C44O5375C49O5393C54O5393C60O5414C71O5414C76O5453C77O5467C81O5477C82O5489C86O5500C88O5514C93O5520,,
code-creation,LazyCompile,10,103633,0x3b5adb5ae306,162,dirname node:path:1275:10,0x273b979bae88,~
code-source-info,0x3b5adb5ae306,41,38741,39410,C0O38754C8O38754C13O38797C19O38804C24O38817C26O38828C27O38849C34O38849C42O38888C44O38884C48O38922C51O38949C53O38977C57O38984C61O38991C63O38991C68O39010C73O39014C81O39053C83O39049C88O39083C92O39114C97O39133C101O39220C103O38999C108O38959C111O39261C113O39269C118O39283C128O39310C129O39315C135O39334C140O39347C142O39359C143O39364C156O39371C161O39406,,
code-creation,LazyCompile,10,103683,0x3b5adb5ae4de,45,updateChildren node:internal/modules/cjs/loader:165:24,0x109acf0abb90,~
code-source-info,0x3b5adb5ae4de,103,5049,5222,C0O5092C7O5098C15O5112C19O5130C23O5138C26O5138C33O5184C38O5184C44O5221,,
code-creation,LazyCompile,10,103753,0x3b5adb5ae6d6,246,Module.load node:internal/modules/cjs/loader:963:33,0x109acf0ac998,~
code-source-info,0x3b5adb5ae6d6,103,30014,30827,C0O30029C8O30075C16O30029C21O30083C26O30096C32O30083C36O30107C38O30121C42O30135C45O30155C52O30172C55O30177C60O30177C66O30155C71O30146C75O30218C78O30218C83O30295C91O30299C101O30352C106O30363C112O30377C124O30383C129O30377C130O30423C133O30430C140O30441C144O30452C150O30472C151O30484C155O30513C160O30522C165O30624C170O30659C175O30670C187O30710C192O30717C197O30717C204O30731C206O30729C211O30763C216O30772C221O30772C228O30797C233O30806C238O30806C245O30826,,
tick,0x11a9757,103868,0,0x0,2,0x1229670,0x3b5adb5ae718,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,103895,0x3b5adb5ae9ce,183,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x109acf0ac6c0,~
code-source-info,0x3b5adb5ae9ce,103,18773,19904,C0O18828C5O18840C10O18840C17O19019C19O19028C24O19043C28O19068C29O19283C32O19309C36O19316C40O19325C42O19340C47O19350C48O19350C53O19382C58O19382C64O19424C66O19437C68O19433C73O19467C75O19477C77O19473C82O19494C89O19545C100O19545C108O19581C112O19494C117O19620C120O19638C124O19658C126O19664C131O19682C138O19693C144O19697C149O19719C156O19751C159O19358C164O19291C167O19838C175O19838C180O19887C182O19900,,
code-creation,LazyCompile,10,103999,0x3b5adb5aed06,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x109acf0abeb0,~
code-source-info,0x3b5adb5aed06,103,11813,12242,C0O11841C5O11846C10O11846C16O11872C18O11896C20O11922C22O11990C36O11943C44O11990C49O12004C51O12023C55O12032C56O12042C61O12049C63O12096C68O12115C74O12154C77O12165C84O12176C89O12196C91O12220C92O11927C95O12227C97O12240,,
code-creation,LazyCompile,10,104101,0x3b5adb5aeee6,353,basename node:path:1306:11,0x273b979baed8,~
code-source-info,0x3b5adb5aeee6,41,39511,41903,C0O39529C4O39558C12O39558C17O39590C25O39590C30O39637C32O39654C35O39681C37O39692C41O39721C47O39728C52O39739C57O39754C61O39746C66O39770C68O39778C73O39796C75O39806C76O39830C80O39837C84O39871C87O39899C91O39906C95O39913C96O39913C101O39947C106O39947C112O39991C114O40004C116O40000C121O40174C125O40207C127O40217C131O40234C135O40280C137O40301C142O40467C144O40501C146O40522C150O40549C151O40560C156O40631C158O40644C161O40644C166O40640C171O40700C178O40713C183O40849C190O41012C193O41039C198O39921C203O39881C206O41114C208O41124C213O41141C220O41176C222O41184C227O41211C232O41225C246O41232C251O41271C252O41300C256O41307C260O41314C261O41314C266O41333C271O41337C279O41376C281O41372C286O41540C290O41571C292O41581C296O41596C300O41626C302O41634C307O41754C309O41784C311O41792C315O41322C320O41282C323O41816C325O41824C330O41838C332O41848C333O41853C347O41860C352O41899,,
code-creation,LazyCompile,10,104237,0x3b5adb5af386,485,Module._extensions..js node:internal/modules/cjs/loader:1108:37,0x109acf0acb38,~
code-source-info,0x3b5adb5af386,103,34649,36401,C0O34748C5O34762C10O34762C16O34781C18O34792C25O34802C34O34835C39O34847C40O34861C46O34889C51O34902C60O34902C67O34940C76O34944C83O35004C86O35004C91O35093C96O35100C103O35106C113O35113C118O35150C123O35168C128O35168C134O35206C139O35212C147O35254C152O35259C157O35271C167O35259C174O35316C179O35316C184O35357C203O35357C209O35528C212O35539C219O35545C224O35573C229O35611C235O35629C244O35629C254O35624C257O35742C261O35788C268O35822C271O35847C279O35854C283O35896C293O35854C300O35822C314O35788C321O35924C325O35981C335O35981C345O35950C352O35959C359O36044C365O36056C367O36091C376O36091C384O36137C387O36131C391O36169C403O36186C416O36195C429O36222C438O36253C443O36222C459O36276C464O36276C469O36341C471O36341C472O36371C477O36371C484O36400,,
code-creation,LazyCompile,10,104343,0x3b5adb5af7e6,376,readFileSync node:fs:451:22,0x2b4a88fb4e38,~
code-source-info,0x3b5adb5af7e6,81,11430,12807,C0O11450C5O11471C10O11460C17O11515C22O11515C27O11569C35O11587C38O11590C43O11613C56O11590C62O11644C65O11644C71O11686C76O11704C79O11686C88O11720C95O11741C97O11750C99O11796C101O11841C102O11850C107O11863C112O11892C124O11901C130O11949C132O11963C133O11972C138O11996C143O12052C159O12008C165O12066C167O12073C174O12113C175O12107C182O12120C187O11985C192O12244C197O12260C207O12260C213O12285C232O12297C238O12347C239O12361C244O12378C249O12413C256O12413C263O12378C268O12449C270O12456C277O12490C278O12490C283O12144C286O12505C290O12524C295O12527C300O12527C305O12545C306O12554C311O12616C316O12632C321O12632C330O12663C332O12671C337O12701C344O12701C351O12735C357O12761C362O12778C367O12761C373O12791C375O12805,,
code-creation,LazyCompile,10,104399,0x3b5adb5afb06,30,isEncoding node:buffer:532:40,0x136fed732560,~
code-source-info,0x3b5adb5afb06,24,14847,14979,C0O14862C6O14910C12O14917C20O14935C23O14935C28O14963C29O14977,,
code-creation,LazyCompile,10,104462,0x3b5adb5afc0e,30,normalizeEncoding node:internal/util:160:27,0x136fed701e78,~
code-source-info,0x3b5adb5afc0e,16,4206,4311,C0O4216C7O4239C14O4257C19O4270C21O4284C22O4287C25O4294C29O4309,,
code-creation,LazyCompile,10,104533,0x3b5adb5afd86,113,openSync node:fs:577:18,0x2b4a88fb5020,~
code-source-info,0x3b5adb5afd86,81,14501,14880,C0O14525C5O14532C11O14578C16O14578C21O14602C37O14609C44O14660C51O14662C58O14687C63O14695C70O14700C73O14711C78O14711C95O14695C101O14833C106O14833C110O14864C112O14878,,
code-creation,LazyCompile,10,104566,0x3b5adb5aff06,37, node:internal/fs/utils:681:42,0x2b4a88fbfda8,~
code-source-info,0x3b5adb5aff06,82,18512,18647,C14O18567C19O18567C24O18601C29O18601C34O18633C36O18645,,
code-creation,LazyCompile,10,104643,0x3b5adb5b02de,515,stringToFlags node:internal/fs/utils:556:23,0x2b4a88fbfbc8,~
code-source-info,0x3b5adb5b02de,82,15103,16337,C14O15131C20O15168C25O15168C30O15200C32O15213C33O15221C38O15246C42O15262C43O15270C202O15302C206O15318C207O15368C214O15386C216O15384C219O15393C220O15410C224O15424C225O15476C232O15492C234O15490C237O15499C238O15516C245O15533C247O15531C253O15543C255O15541C258O15552C259O15602C266O15619C268O15617C274O15629C276O15627C282O15640C284O15638C287O15647C288O15665C295O15682C297O15680C303O15692C305O15690C308O15699C309O15749C316O15766C318O15764C324O15776C326O15774C332O15785C334O15783C337O15792C338O15809C345O15827C347O15825C353O15837C355O15835C358O15846C359O15896C366O15914C368O15912C374O15924C376O15922C382O15935C384O15933C387O15942C388O15992C395O16010C397O16008C403O16020C405O16018C411O16031C413O16029C416O16038C417O16056C424O16074C426O16072C432O16084C434O16082C437O16091C438O16141C445O16159C447O16157C453O16169C455O16167C461O16178C463O16176C466O16185C467O16235C474O16253C476O16251C482O16263C484O16261C490O16272C492O16270C495O16279C496O16287C509O16293C514O16287,,
code-creation,LazyCompile,10,104703,0x3b5adb5b06ce,97,parseFileMode node:internal/validators:59:23,0x2842ea0bbf08,~
code-source-info,0x3b5adb5b06ce,15,1487,1783,C0O1510C11O1527C17O1564C24O1589C27O1569C34O1615C41O1660C52O1621C57O1615C58O1681C66O1689C73O1722C89O1722C94O1768C96O1781,,
code-creation,LazyCompile,10,104754,0x3b5adb5b0866,206, node:internal/validators:84:3,0x2842ea0bbfc8,~
code-source-info,0x3b5adb5b0866,15,2255,2830,C36O2396C42O2435C58O2441C63O2435C64O2500C67O2505C73O2529C78O2534C84O2568C100O2574C105O2568C106O2637C116O2676C129O2689C142O2643C147O2637C148O2714C150O2724C157O2739C162O2754C172O2793C185O2806C198O2760C203O2754C205O2829,,
code-creation,LazyCompile,10,104782,0x3b5adb5b0a2e,9,isInt32 node:internal/validators:36:17,0x2842ea0bb9a8,~
code-source-info,0x3b5adb5b0a2e,15,734,777,C0O746C2O770C5O759C8O775,,
code-creation,LazyCompile,10,104835,0x3b5adb5b0b36,66,tryStatSync node:fs:405:21,0x2b4a88fb4d48,~
code-source-info,0x3b5adb5b0b36,81,10405,10615,C0O10436C2O10456C7O10464C22O10464C28O10508C36O10532C38O10548C43O10551C48O10551C53O10570C58O10576C62O10570C63O10600C65O10613,,
code-creation,LazyCompile,10,104924,0x3b5adb5b0cae,96,tryCreateBuffer node:fs:415:25,0x2b4a88fb4d98,~
code-source-info,0x3b5adb5b0cae,81,10641,10928,C0O10678C2O10690C7O10710C9O10721C11O10719C16O10743C23O10749C28O10743C29O10792C34O10808C39O10808C45O10831C57O10837C58O10864C65O10878C67O10888C72O10891C77O10891C93O10912C95O10926,,
tick,0x7f0810b9b6d0,104969,0,0x0,2,0x1229670,0x3b5adb5af862,0x3b5adb5af3c2,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,104985,0x3b5adb5b0e06,17,allocUnsafe node:buffer:375:42,0x136fed7320d8,~
code-source-info,0x3b5adb5b0e06,24,10944,10999,C0O10955C5O10955C9O10975C12O10982C16O10997,,
code-creation,LazyCompile,10,105020,0x3b5adb5b0f0e,54, node:buffer:351:36,0x136fed732020,~
code-source-info,0x3b5adb5b0f0e,24,10242,10397,C0O10256C8O10256C13O10288C14O10299C21O10315C23O10312C28O10334C33O10366C46O10340C51O10334C53O10396,,
code-creation,LazyCompile,10,105051,0x3b5adb5b1036,30,validateNumber node:internal/validators:123:24,0x2842ea0bc108,~
code-source-info,0x3b5adb5b1036,15,3539,3648,C0O3557C6O3592C22O3598C27O3592C29O3647,,
code-creation,LazyCompile,10,105106,0x3b5adb5b114e,119,allocate node:buffer:400:18,0x136fed732228,~
code-source-info,0x3b5adb5b114e,24,11646,11961,C0O11657C1O11666C6O11678C11O11685C16O11702C17O11709C20O11728C24O11737C27O11718C32O11751C34O11763C39O11774C41O11772C44O11760C49O11793C52O11793C55O11821C62O11836C67O11847C75O11821C81O11870C88O11884C94O11881C100O11894C103O11894C106O11911C108O11920C109O11927C114O11934C118O11959,,
code-creation,LazyCompile,10,105148,0x3b5adb5b1316,71,createUnsafeBuffer node:internal/buffer:1059:28,0x136fed73f0c0,~
code-source-info,0x3b5adb5b1316,25,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
code-creation,LazyCompile,10,105204,0x3b5adb5b146e,86,tryReadSync node:fs:430:21,0x2b4a88fb4de8,~
code-source-info,0x3b5adb5b146e,81,10950,11185,C0O10999C2O11011C7O11034C12O11049C29O11049C35O11085C47O11091C48O11118C55O11132C57O11142C62O11145C67O11145C83O11166C85O11183,,
code-creation,LazyCompile,10,105274,0x3b5adb5b165e,258,readSync node:fs:685:18,0x2b4a88fb50f0,~
code-source-info,0x3b5adb5b165e,81,17235,18224,C0O17235C2O17278C7O17283C13O17306C18O17306C22O17347C29O17354C34O17429C40O17439C45O17439C50O17473C62O17491C68O17507C75O17518C80O17534C89O17575C94O17601C99O17628C112O17628C117O17673C124O17689C125O17700C130O17713C131O17722C132O17741C138O17752C143O17765C159O17771C164O17765C165O17893C170O17941C181O17893C186O17957C191O17983C195O18001C203O18001C208O18056C210O18077C215O18085C240O18085C246O18177C251O18177C255O18208C257O18222,,
code-creation,LazyCompile,10,105314,0x3b5adb5b18c6,52, node:internal/fs/utils:687:40,0x2b4a88fbfdf8,~
code-source-info,0x3b5adb5b18c6,82,18690,18811,C14O18719C22O18723C29O18747C30O18756C31O18764C44O18764C49O18799C51O18809,,
code-creation,LazyCompile,10,105348,0x3b5adb5b1a36,51, node:internal/validators:191:40,0x2842ea0bc330,~
code-source-info,0x3b5adb5b1a36,15,5669,5899,C14O5702C19O5707C25O5740C30O5771C43O5746C48O5740C50O5898,,
code-creation,LazyCompile,10,105388,0x3b5adb5b1b8e,151, node:internal/validators:73:3,0x2842ea0bbf78,~
code-source-info,0x3b5adb5b1b8e,15,1828,2209,C12O1848C25O1878C32O1911C38O1948C54O1954C59O1948C60O2007C65O2012C71O2042C87O2048C92O2042C93O2101C95O2111C102O2126C107O2139C117O2178C130O2191C143O2145C148O2139C150O2208,,
code-creation,LazyCompile,10,105434,0x3b5adb5b1d96,103, node:internal/fs/utils:637:3,0x2b4a88fbfcb8,~
code-source-info,0x3b5adb5b1d96,82,17314,17693,C0O17354C1O17365C6O17378C22O17384C27O17378C28O17442C29O17453C34O17466C50O17472C55O17466C56O17530C58O17541C64O17550C69O17574C82O17663C95O17580C100O17574C102O17692,,
code-creation,LazyCompile,10,105488,0x3b5adb5b209e,151, node:internal/fs/utils:902:42,0x273b979bf438,~
code-source-info,0x3b5adb5b209e,82,24534,25092,C0O24558C6O24598C14O24598C21O24646C27O24686C32O24709C35O24704C37O24701C47O24735C53O24742C56O24729C61O24757C77O24840C80O24835C98O24860C104O24867C117O24763C122O24757C125O24940C143O24946C148O24940C150O25091,,
code-creation,LazyCompile,10,105536,0x3b5adb5b2256,47,closeSync node:fs:527:19,0x2b4a88fb4f48,~
code-source-info,0x3b5adb5b2256,81,13370,13492,C0O13379C5O13384C11O13419C13O13425C18O13433C31O13433C36O13462C41O13462C46O13491,,
code-creation,LazyCompile,10,105597,0x3b5adb5b238e,162,toString node:buffer:785:46,0x136fed733f60,~
code-source-info,0x3b5adb5b238e,24,23337,23899,C0O23337C2O23378C8O23385C13O23410C20O23428C25O23410C31O23436C32O23461C37O23472C38O23482C43O23492C48O23510C50O23520C55O23532C57O23542C58O23554C65O23569C71O23598C76O23609C83O23631C90O23644C92O23652C97O23666C99O23676C100O23680C104O23724C109O23724C115O23746C116O23762C119O23762C124O23790C126O23817C133O23823C138O23817C139O23873C156O23873C161O23897,,
code-creation,LazyCompile,10,105686,0x3b5adb5b264e,499,getEncodingOps node:buffer:681:24,0x136fed733db8,~
code-source-info,0x3b5adb5b264e,24,20004,21805,C0O20019C10O20054C62O20082C64O20095C69O20107C74O20126C78O20131C79O20138C81O20151C86O20163C91O20182C95O20187C96O20194C101O20205C107O20249C109O20262C114O20274C119O20293C123O20298C124O20305C126O20318C131O20330C136O20349C140O20354C141O20361C143O20386C145O20399C150O20412C155O20431C159O20436C160O20443C162O20456C167O20469C172O20488C176O20494C177O20501C179O20514C184O20527C189O20546C193O20551C194O20558C199O20569C205O20613C207O20626C212O20639C217O20658C221O20663C222O20670C224O20683C229O20696C234O20715C238O20721C239O20728C241O20741C246O20754C251O20773C255O20778C256O20785C258O20810C260O20823C267O20850C270O20850C277O20887C282O20910C287O20929C291O20937C292O20944C294O20969C296O20982C303O21010C306O21010C313O21047C318O21071C323O21090C327O21098C328O21105C330O21130C332O21143C339O21168C344O21190C349O21209C353O21216C354O21223C356O21236C361O21250C366O21269C370O21276C371O21283C376O21294C382O21338C384O21351C391O21376C396O21398C401O21417C405O21424C406O21431C408O21444C413O21458C418O21477C422O21484C423O21491C425O21516C427O21529C434O21542C437O21542C444O21579C449O21598C454O21617C458O21621C459O21628C461O21653C463O21666C470O21695C473O21695C480O21732C485O21757C490O21776C494O21786C495O21793C498O21804,,
code-creation,LazyCompile,10,105744,0x3b5adb5b2a36,12,slice node:buffer:596:12,0x136fed732780,~
code-source-info,0x3b5adb5b2a36,24,16675,16721,C0O16700C5O16700C11O16721,,
code-creation,Function,11,105848,0x7f07fc045340,1196,readPackageScope node:internal/modules/cjs/loader:321:26,0x109acf0abd20,^
code-source-info,0x7f07fc045340,103,8919,9437,,,
code-creation,Function,11,105878,0x7f07fc045880,1324,resolve node:path:1091:10,0x273b979baca8,^
code-source-info,0x7f07fc045880,41,33781,34691,,,
code-creation,Function,11,105890,0x7f07fc045e40,44,toNamespacedPath node:path:1266:19,0x273b979bae38,^
code-source-info,0x7f07fc045e40,41,38608,38668,,,
code-creation,Function,11,105907,0x7f07fc045f00,284,validateString node:internal/validators:118:24,0x2842ea0bc068,^
code-source-info,0x7f07fc045f00,15,3405,3514,,,
code-creation,Function,11,105935,0x7f07fc0460c0,1500,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x109acf0ac6c0,^
code-source-info,0x7f07fc0460c0,103,18773,19904,,,
tick,0xfef398,105995,0,0x0,0,0x1232ab0,0x3b5adb5aab5a,0x3b5adb5af3dc,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,106116,0x3b5adb5b3016,499,Module._compile node:internal/modules/cjs/loader:1053:37,0x109acf0acaa8,~
code-source-info,0x3b5adb5b3016,103,32741,34582,C0O32769C2O32786C4O32799C11O32809C20O32827C25O32839C30O32868C35O32887C40O32896C45O32896C51O32932C56O32939C61O32948C66O32948C72O32992C86O32992C91O33064C103O33064C109O33125C111O33133C119O33137C128O33180C135O33201C141O33295C144O33307C151O33311C159O33342C162O33364C170O33389C177O33393C185O33364C193O33355C203O33586C210O33593C215O33606C221O33606C226O33593C231O33586C237O33670C242O33683C248O33750C256O33771C262O33802C264O33798C269O33824C273O33839C279O33853C285O33872C290O33900C295O33950C300O33955C305O33955C311O33992C316O33992C322O34036C324O34067C329O34096C330O34122C333O34130C339O34147C344O34154C349O34166C357O34164C363O34183C367O34211C388O34220C396O34356C401O34395C410O34433C419O34442C428O34451C437O34459C446O34469C459O34365C465O34486C469O34512C475O34522C481O34539C486O34546C490O34556C496O34566C498O34580,,
code-creation,LazyCompile,10,106222,0x3b5adb5b3536,224,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x109acf0a4550,~
code-source-info,0x3b5adb5b3536,100,2239,3267,C0O2308C3O2308C7O2334C10O2348C15O2352C23O2372C25O2392C26O2399C30O2412C35O2423C44O2421C54O2564C64O2564C68O2580C69O2587C70O2608C75O2634C80O2608C86O2711C88O2741C91O2769C96O2776C101O2741C107O2811C112O2831C117O2838C122O2860C126O2891C131O2909C136O2913C143O2942C150O2973C160O3003C166O3017C170O2909C178O3143C183O3161C188O3165C196O3198C206O3228C212O3242C216O3161C223O3266,,
code-creation,LazyCompile,10,106261,0x3b5adb5b3f8e,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x109acf0a44b0,~
code-source-info,0x3b5adb5b3f8e,100,1418,1563,C0O1425C6O1468C11O1489C17O1489C22O1468C26O1536C30O1561,,
code-creation,LazyCompile,10,106309,0x3b5adb5b4106,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x109acf0a4500,~
code-source-info,0x3b5adb5b4106,100,1594,2209,C0O1604C8O1604C13O1709C19O1709C24O1648C29O1674C34O1738C38O1767C42O1822C48O1822C53O1796C58O1878C64O1936C70O2095C76O2095C81O2068C86O2127C90O2183C92O2201C99O2208,,
code-creation,LazyCompile,10,106341,0x3b5adb5b427e,30,validateBoolean node:internal/validators:139:25,0x2842ea0bc1a8,~
code-source-info,0x3b5adb5b427e,15,4049,4160,C0O4067C6O4103C22O4109C27O4103C29O4159,,
code-creation,LazyCompile,10,106421,0x3b5adb5b4676,165,wrapSafe node:internal/modules/cjs/loader:1011:18,0x109acf0ac130,~
code-source-info,0x3b5adb5b4676,103,31441,32533,C0O31441C9O31484C17O31519C22O31526C27O31526C33O31545C40O31555C45O31572C52O31589C56O31678C64O31555C70O31949C74O31966C81O31976C86O31992C98O32107C102O32123C113O31976C118O32408C130O32431C135O32443C142O32454C147O32483C157O32483C162O32517C164O32517,,
code-creation,LazyCompile,10,106587,0x3b5adb5b4e4e,472,compileFunction node:vm:308:25,0x2989f3590070,~
script-source,89,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeUnshift\x2C\n  Symbol\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  MicrotaskQueue\x2C\n  makeContext\x2C\n  isContext: _isContext\x2C\n  constants\x2C\n  compileFunction: _compileFunction\x2C\n  measureMemory: _measureMemory\x2C\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  kVmBreakFirstLineSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code\x2C options = {}) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else {\n      validateObject(options\x2C 'options');\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>'\x2C\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      cachedData\x2C\n      produceCachedData = false\x2C\n      importModuleDynamically\x2C\n      [kParsingContext]: parsingContext\x2C\n    } = options;\n\n    validateString(filename\x2C 'options.filename');\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code\x2C\n            filename\x2C\n            lineOffset\x2C\n            columnOffset\x2C\n            cachedData\x2C\n            produceCachedData\x2C\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C\n                       'options.importModuleDynamically');\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this\x2C {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInThisContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInThisContext\x2C this\x2C args);\n  }\n\n  runInContext(contextifiedObject\x2C options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    ArrayPrototypeUnshift(args\x2C contextifiedObject);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInNewContext(contextObject\x2C options) {\n    const context = createContext(contextObject\x2C getContextOptions(options));\n    return this.runInContext(context\x2C options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options\x2C 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\n  }\n\n  const {\n    displayErrors = true\x2C\n    breakOnSigint = false\x2C\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\n  } = options;\n\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n\n  return {\n    breakOnSigint\x2C\n    args: [timeout\x2C displayErrors\x2C breakOnSigint\x2C breakFirstLine]\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName\x2C\n    origin: options.contextOrigin\x2C\n    codeGeneration: undefined\x2C\n    microtaskMode: options.microtaskMode\x2C\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name\x2C 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration\x2C\n                   'options.contextCodeGeneration');\n    const { strings\x2C wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings\x2C wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\n\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}\x2C options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options\x2C 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\n    origin\x2C\n    codeGeneration\x2C\n    microtaskMode\n  } = options;\n\n  validateString(name\x2C 'options.name');\n  if (origin !== undefined)\n    validateString(origin\x2C 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true\x2C wasm = true } = codeGeneration);\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\n                  ['afterEvaluate'\x2C undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code\x2C options) {\n  return new Script(code\x2C options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\n      process.addListener('SIGINT'\x2C listener);\n    });\n  }\n}\n\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options\x2C\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code\x2C options)\n    .runInContext(contextifiedObject\x2C options);\n}\n\nfunction runInNewContext(code\x2C contextObject\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\n  options = { ...options\x2C [kParsingContext]: contextObject };\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\n}\n\nfunction runInThisContext(code\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code\x2C options).runInThisContext(options);\n}\n\nfunction compileFunction(code\x2C params\x2C options = {}) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateArray(params\x2C 'params');\n    ArrayPrototypeForEach(params\x2C\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY\x2C\n  detailed: constants.measureMemory.mode.DETAILED\x2C\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT\x2C\n  eager: constants.measureMemory.execution.EAGER\x2C\n};\n\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options\x2C 'options');\n  const { mode = 'summary'\x2C execution = 'default' } = options;\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script\x2C\n  createContext\x2C\n  createScript\x2C\n  runInContext\x2C\n  runInNewContext\x2C\n  runInThisContext\x2C\n  isContext\x2C\n  compileFunction\x2C\n  measureMemory\x2C\n};\n\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\n// and vm.SyntheticModule in the pre-execution phase when\n// --experimental-vm-modules is on.\n
code-source-info,0x3b5adb5b4e4e,89,9562,11817,C10O9562C16O9595C25O9595C30O9627C34O9659C43O9659C48O9696C53O9718C59O9696C64O9825C76O9844C84O9866C92O9886C100O9914C108O9945C116O9977C125O10005C130O10048C139O10048C144O10096C153O10096C158O10152C167O10152C172O10204C176O10238C185O10238C190O10290C199O10290C204O10357C208O10397C221O10486C227O10526C244O10532C249O10526C250O10655C259O10655C264O10720C269O10742C275O10720C280O10914C312O10914C318O11091C322O11127C327O11164C331O11155C335O11202C341O11227C346O11256C350O11247C354O11275C358O11303C368O11324C379O11324C384O11473C393O11473C398O11435C403O11532C412O11532C417O11516C422O11584C426O11584C428O11662C432O11655C434O11688C439O11699C451O11742C459O11688C467O11806C471O11815,,
tick,0x7f0810fb3696,107277,0,0x0,3,0x1229670,0x3b5adb5b46e7,0x3b5adb5b307d,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,107329,0x3b5adb5b6016,95, node:internal/validators:168:39,0x2842ea0bc268,~
code-source-info,0x3b5adb5b6016,15,4973,5251,C16O5009C21O5014C27O5041C43O5047C48O5041C49O5111C56O5118C61O5152C66O5175C71O5192C87O5198C92O5192C94O5250,,
code-creation,LazyCompile,10,107360,0x3b5adb5b6176,27, node:vm:313:27,0x3b5adb5b4b20,~
code-source-info,0x3b5adb5b6176,89,9752,9803,C0O9766C10O9798C21O9766C26O9803,,
code-creation,Eval,10,107606,0x3b5adb5b8c06,5, /home/liam/dev/advent-of-code/2022/day8/index.js:1:1,0x3b5adb5b8ac0,~
script-source,133,/home/liam/dev/advent-of-code/2022/day8/index.js,const input = `202002313322443443333413205214140320025450316364504141264123114304203303114001123204003420102030300\n212313000221124342025540453251212255520310035503014622512241404324240404402541331004400300331322110\n332010030224230340301531501004040246520352260460326354116252046344244524210334140401240030314221201\n221301221024131121450340303252214260131364111213343344405130626304123155314054543541311324344211033\n001134433000214135052445324455546624654355260523323125133253553045204251430400315121003433044422220\n110024340203302220432202030041005313231555605566115533505425534600532263042244310025013301002122432\n202142343241025110345415445624446445344113355202423663433331226040240361512310234150014422014312341\n120231221014040554044220640131325544631255541041127752253252103362402320335611055442052140412241043\n304101021100233012133444436554401661205535772414667667451754115102616366431662351045410402233002402\n230331042045503255333014364102251313262666434422256626256566764614412322001313140132320342244311432\n301141102400324512330561535320415044526674414642717654456164545365745044506116261040015244323140033\n231132220241110100324130130545143322166173563556616563372125554727356021654340613261035251251413332\n203320424451202552446214505356253135265527113533231423523554524551155161163143626222334550222001114\n024231523321503230631342521245372255435215736461556537371121121751317427505314306502002123010412034\n040145510232550020202124627124455516526155425234552673277347264467144563753114463520045522011145324\n240244304425550155132364624615433274255211852862645772235364532654142113137206602450504451232422342\n424334205511552415565560671715111772112734875278832283468554433426522451521742450535105641322532120\n133100401525326032650034477716317357844566548887884636586578835685745454237757622666646610535221104\n242223305304135213415343353725345243424627362843632335577356738268866222511635745254444064454403022\n331241503204144326221625132445526654437248248754447372872277553375762277344562444520505011503314140\n222451434543300006524657732724686755826462744865327773328272774372386881361277646413144100602223020\n414454544234262543464462244368365765473624458443347748378276353357284728521731472310150061145432122\n431102216135016433434413645583863866258756823459689676856722332224673767726144732654216036601312045\n110042056021302336337562427723268467778543586356696798849484555383634828423561624661541545036033040\n233130533366340424442262664763637476353997734438457636478474458384564333326465264262124602145421015\n241204063143034137555565335625773883567883575869635693564466395342787853372316311463254316554250312\n204021106434203474532574577732644238364483977987654549695578595965788345665673122334133343010255050\n545511454122526751271377583327826879494576898565775448864596738363442346635565474635455064243232543\n124015635625434375317238826384863483959359789986783666664869677434837343823842652356111546364644132\n354241210264473276647664584326653653647946783946785857466783387358894383428654661215717710324561130\n244056226450134737153283634386947648667343795757554497954898635566776763644735545173126352624425020\n501324141203722175363238762648494967439479987887696675878464444733446494872553246567237465053516212\n124454612231317724443537666649848658354577798467554676466685998895664436347585644634216747461605663\n444220351051321723632583255595773459868897594678655845666879757469695495456426765727653232001214613\n543415566433561456232786335548987337775874478855474645667479645683933635533375645234665367636633651\n530466162316434373545644848445489775499587455748589658584498988576664989538548655685716224502165333\n235553430155252418662326494855584476654765446847698998974986756847936484493638765583146163725434525\n310360654533722362728523488436493558969996756767575985755767774769466767793646674763166562576015621\n325614303744164255433237739477846644568969987655575799855985845775957857639672455744841244170500440\n503515002355336284762634697976487678966879556557679889675955589869487648536567234728851425445561434\n543324643653742448624433599753598966565767666598867958799856754678485656376459464724213745353256500\n424103217216134323283434554946357547857767597585675689859575974787896473853787835228441512611606640\n250304641276277558773624439786746445898556998895887655878685889784588785835399278825226257656316456\n345463264572334567387256787858445544645556959975787756996857575877564946576444487536853156173434515\n161602652143411253367838475869799955968676977879766978885597865889664759447954958773226534633601264\n425255315411463546634735936474878586798978997677669676798889865697568457553348834768551317414265641\n234033463437423662763283959368645469455555866987776986698877578774866488666969955245374145544441623\n263636217315313825577865757479668665967695777867766779768668996864488656989883458726646674514525511\n414022642352612738772698548548946555775959857777688888669975865965945954569559444566834371561235240\n626645264156227353287767567366856886676578966679977979667696756679988685477675656584254614315521534\n141252624567664677828886434838768857955979876666969698786698969754567989787396562527238135476552660\n561116074375644526333736555595544896786968966976977997766676677666986777499545768822354754143466332\n640134335336664367747687845787987597685679698978788978879896585767488999869854847362476731511356241\n122566575557672854685858389735665896958579588778989888987596889896554676975794558735663243216725024\n622222555471614528744598736564486874589976996698777696679756695597854959586596528866486767125750425\n420556462341434263425678855644549848459689687977998667968775668946499845947638767286571573445302316\n153401561272311464882769939493697496869895765798867978898769959646765788757935955564662266664350020\n013313231114626266432864594633565767798995787676787879588887569996649773766959635454884663212340545\n532215627116623645744769753668949665878576988558956966987866657689789897574757843566561641651164202\n450601415622125355356368488837847498867787786799888699666587767988546989739799625367647376766514525\n132355556713615268557775868585955849749679856695885666656767667454658976438866274426545173713503424\n140363023176115776535475859453935445956676569686687689879769756896678849374653357232443563250603624\n555455453332353643328265463674488487677659785966787969895954479496764396934557558828651662273322156\n126055665555676465455653358794473489784867699566988677887774657674865436594725534325162527364425454\n424236562661632716477544757996995899646765977676757796446899758789936969594733554244341314246106356\n135664342046737243753657865736877354784767579696499494585854598586968344888482585764775221150460432\n344344143357321137635487849484434336494875487675577984647444795955996398565666287683142755200412361\n414412353051761177373387236955658343565579456876599987585868476443368777592334237632432165500034134\n344222350343246157155255424535673748655865864986555696699778567479637584386522672344234517610314264\n303525035340142365235266633256899897484946659875878967575986439538577438532348255423232624315603544\n510360601501172132135462465243343789945984697644794559468647896656775633328382288156772775241356112\n244355065300035434315633638622366843368655487769664895769979663363655675357453742377443633663346142\n543050131342642155264665386866379467794949993697734675839557966585757563732683714633526145166334412\n251422612632162765477554485862386899688967865977755368655846774644737246723864225342434523316423234\n535030453166161574317736827787562575357946899856345696768476976499427585553774225613174414155545203\n451512340514125213652261633852837673947556656599369877579547445535876827567436531662350302444041243\n033335530105503441451253564883648443326876639459998839433543553388842558572361376415226141134602541\n304432111501100651754116177585225473385738444645866989935538477775342885231334255374502153460230350\n532031530144611101611317655656232366528772853465566773976378637453482452343331275146210626455403524\n012504432204304640225665641317778444385425328864724366378324622327743456125442217372022160305110234\n423330153504112303542265616531228643228676746426328835672356636538675673621573612560004436420330151\n323321500212164213037737677445413688473546378425227262668778538578545546734311666243650663254002451\n040305323234252401530453457637172235782628463783548274258737388837337454577642612225610462012021013\n014421203421445064446506474465661471783776826638336854777768476773252621522666325565433244545553213\n203353533234533642651045661415434436734475362377466258588352323543664136375224260403562354030401203\n430143224545323216313162327161435122244647775242765557228261267335671742531564542126211410421135434\n311115413443044633036265137463752661235223746112744444721551372635624713663424662444323552052513344\n134313534132001040304122015236726566356671331522244364434524166341154325353311501362040351444450020\n411143423205141252652033316260315365572263763132742674322315253667543711643300545065310242032324020\n144341145402305205020640440563232327377646232274132447222637451213446334050331022204312235341032244\n100112332452301131334340450350201034154563646746333747731225537677742552525011500010314510431132014\n221320130310004120220446050664152326055763773453162437516516576134605322403126405442152350241130304\n241101113220305530315466104556331100306117166126725673116524503062565103142063320533420154322010431\n300413413431025050053455545511501350201353245414366717162612025321566536123553051412314441133131101\n330231204004004415320523326541625211601352531640552445135123515524650251203003153345052023224223041\n323031413443333543540440514335332454342430446605433036305445612534333404345522552510512242414121433\n201012341123333315224534110123345050436205551211152343641503546320233130510552230421204123134014033\n030231013300430225134314421310156226302452500603162133325435662050366331135501505435404110101401101\n301302243133113000115553304435551505352615146115031661551161050412521420141400134222424010304012133`\n\nlet visible = 0;\nconst firstNumIsHighest = arr => {\n\x09if (arr.length === 1) {\n\x09\x09return true;\n\x09}\n\x09const firstNum = Number(arr[0]);\n\x09return arr.slice(1).every(n => firstNum > Number(n));\n}\n\nlet lines = input.split('\\n');\nfor (let rowIndex = 0; rowIndex < lines.length;rowIndex++) {\n\n\x09const line = lines[rowIndex];\n\n\x09for (let colIndex = 0; colIndex < lines[rowIndex].length;colIndex++) {\n\x09\x09const left = line.substring(0\x2C colIndex + 1).split('').map(x => Number(x));\n\n\x09\x09const leftVisible = firstNumIsHighest(left.reverse());\n\x09\n\x09\x09const right = line.substring(colIndex\x2C line.length).split('').map(x => Number(x));\n\x09\x09const rightVisible = firstNumIsHighest(right);\n\n\x09\x09let down = [];\n\x09\x09for (let i = rowIndex; i < lines.length;i++) {\n\x09\x09\x09down.push(Number(lines[i][colIndex]));\n\x09\x09}\n\x09\x09const downVisible = firstNumIsHighest(down);\n\n\x09\x09let up = [];\n\x09\x09for (let i = rowIndex; i >= 0;i--) {\n\x09\x09\x09up.push(Number(lines[i][colIndex]));\n\x09\x09}\n\x09\x09const upVisible = firstNumIsHighest(up);\n\n\n\x09\x09if (leftVisible || rightVisible || downVisible || upVisible) {\n\x09\x09\x09visible += 1;\n\x09\x09}\n\x09}\n}\n\nconsole.log('Visible: '\x2C visible);\n// 1669\n
code-source-info,0x3b5adb5b8c06,133,0,11012,C0O0C4O11012,,
code-creation,Function,10,108127,0x3b5adb5b8e0e,510, /home/liam/dev/advent-of-code/2022/day8/index.js:1:1,0x3b5adb5b8b80,~
code-source-info,0x3b5adb5b8e0e,133,0,11012,C0O14C3O9931C5O9960C10O10122C20O10122C26O10155C37O10966C46O10190C54O10175C58O10167C74O10211C76O10216C80O10250C91O10964C100O10295C108O10262C110O10269C115O10280C119O10262C135O10321C146O10343C151O10321C159O10347C169O10348C176O10357C188O10358C194O10425C200O10425C206O10402C212O10460C218O10485C224O10460C232O10492C242O10493C249O10502C261O10503C268O10547C274O10587C278O10606C283O10626C287O10618C292O10648C305O10665C312O10668C317O10653C323O10648C328O10634C334O10593C337O10708C343O10745C347O10764C352O10776C353O10776C358O10794C371O10811C378O10814C383O10799C389O10794C394O10782C400O10751C403O10852C409O10879C415O10898C419O10914C423O10929C425O10945C438O10230C466O10135C487O10969C492O10977C502O10977C509O11011,,
tick,0x7f0810c8c751,108243,1,0xb22480,3,0xd81050,0x3b5adb5b4f86,0x3b5adb5b46e7,0x3b5adb5b307d,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,108332,0x3b5adb5b97ce,19,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x3b5adb592f00,~
code-source-info,0x3b5adb5b97ce,131,11705,12148,C0O11705C13O11774C18O12146,,
code-creation,LazyCompile,10,108418,0x3b5adb5ba9a6,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0x109acf0a7478,~
code-source-info,0x3b5adb5ba9a6,102,1708,3678,C0O1708C22O1744C25O1748C29O1744C31O1768C33O1779C53O1811C58O1815C69O1831C73O1811C75O1858C81O1858C83O1885C89O1894C95O1922C104O3082C109O3313C111O3329C115O3469C117O3483C121O3495C126O3518C130O3508C134O3583C137O3611C141O3602C145O3627C148O3650C152O3641C156O3661C158O3676,,
code-creation,LazyCompile,10,108547,0x3b5adb5bda56,9, /home/liam/dev/advent-of-code/2022/day8/index.js:116:62,0x3b5adb5b8c88,~
code-source-info,0x3b5adb5bda56,133,10362,10376,C0O10367C4O10367C8O10376,,
code-creation,LazyCompile,10,108590,0x3b5adb5bdbb6,67,firstNumIsHighest /home/liam/dev/advent-of-code/2022/day8/index.js:102:27,0x3b5adb5b8c38,~
code-source-info,0x3b5adb5bdbb6,133,9960,10102,C0O9960C8O9978C15O9985C20O9996C21O10008C22O10030C27O10040C31O10030C35O10030C37O10058C45O10058C51O10066C61O10067C66O10100,,
code-creation,LazyCompile,10,108623,0x3b5adb5bdd1e,9, /home/liam/dev/advent-of-code/2022/day8/index.js:120:69,0x3b5adb5b8cd8,~
code-source-info,0x3b5adb5bdd1e,133,10507,10521,C0O10512C4O10512C8O10521,,
code-creation,LazyCompile,10,108661,0x3b5adb5bde56,17, /home/liam/dev/advent-of-code/2022/day8/index.js:107:28,0x3b5adb5bdaf0,~
code-source-info,0x3b5adb5bde56,133,10073,10098,C0O10087C9O10089C13O10087C16O10098,,
code-creation,Function,11,108744,0x7f07fc046740,3420, /home/liam/dev/advent-of-code/2022/day8/index.js:1:1,0x3b5adb5b8b80,^
code-source-info,0x7f07fc046740,133,0,11012,,,
code-creation,Function,11,108763,0x7f07fc047540,92, /home/liam/dev/advent-of-code/2022/day8/index.js:120:69,0x3b5adb5b8cd8,^
code-source-info,0x7f07fc047540,133,10507,10521,,,
tick,0x162a133,109165,0,0x0,0,0x7f07fc046d1b,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x15bb3ff,110226,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
new,MemoryChunk,0x27cefa740000,262144
new,MemoryChunk,0x1a66eb300000,262144
new,MemoryChunk,0x20812a600000,262144
new,MemoryChunk,0x2a49abc80000,262144
scavenge,begin,0,128734,1670591252457
scavenge,end,0,129419,1670591252457
tick,0x15f90c4,111336,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x16536ad,112366,0,0x0,0,0x7f07fc046be4,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,131683,1670591252459
new,MemoryChunk,0x192646340000,262144
new,MemoryChunk,0x1bda378c0000,262144
tick,0x7f0810d030bd,113513,0,0x0,1
scavenge,end,0,132436,1670591252460
tick,0x15fe8c4,114546,0,0x0,0,0x7f07fc046eab,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x15bb3ff,115580,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,13,115931,0x7f07fc047640,168, /home/liam/dev/advent-of-code/2022/day8/index.js:116:62,0x3b5adb5b8c88,*
code-source-info,0x7f07fc047640,133,10362,10376,C0O10362C52O10367C79O10376C106O10362,,
code-creation,LazyCompile,13,115966,0x7f07fc0477c0,168, /home/liam/dev/advent-of-code/2022/day8/index.js:120:69,0x3b5adb5b8cd8,*
code-source-info,0x7f07fc0477c0,133,10507,10521,C0O10507C52O10512C79O10521C106O10507,,
tick,0x1d7e08e,116646,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1dd14e0,117711,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1f1c851,118777,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1dd1503,119845,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1faed64,120910,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1de75d3,121976,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1fa4a40,123042,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1f0e004,124107,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x7f0810f28d70,125171,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1f1e2f2,126238,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1f1f02e,127302,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d7e014,128368,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1dd0be6,129433,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1dccd34,130497,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1ebeba1,131561,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d2e361,132627,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1df2086,133692,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1df68d7,134756,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d69248,135825,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eae50f,136888,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eb7513,137954,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eabe45,139020,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1ea7774,140084,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eb9995,141149,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d58729,142216,0,0x0,4,0x122a520,0x7f07fc0472ca,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,13,142811,0x7f07fc047940,19564, /home/liam/dev/advent-of-code/2022/day8/index.js:1:1,0x3b5adb5b8b80,*
code-source-info,0x7f07fc047940,133,0,11012,C0O0C86O10269C102O10402C127O10269C277O10964C305O10295C371O10269C440O10280C464O10262C675O10321C700O10343C712O10321C783O10348C832O10357C860O10358C1161O10367I0C1180O10358C1349O10367I0C1367O10358C1403O10230C1550O10966C1569O10190C1637O10175C1647O10167C1759O10216C1867O10964C1880O10295C1923O10269C1952O10280C1978O10262C2157O10321C2187O10343C2197O10321C2252O10348C2298O10357C2326O10358C2633O10367I4C2652O10358C2821O10367I4C2840O10358C2881O10230C2896O10135C2926O10969C2964O10977C2969O10358C2973O0C3028O10269C3452O10367I0C3599O10358C3744O10367I0C3915O10358C4070O10460C4182O10425C4247O10402C4309O10460C4349O10493C4395O10502C4423O10503C4818O10512I1C4896O10503C5117O10512I1C5191O10503C5356O10547C5478O10587C5515O10626C5545O10618C5581O10665C5611O10668C6269O10653C6287O10648C6394O10634C6404O10593C6474O10618C6526O10665C6544O10668C7173O10653C7188O10648C7329O10634C7346O10593C7471O9985I16C7485O10040I16C7503O10058I16C7559O10066I16C7579O10067I16C7639O10087I17C7670O10067I16C7795O10745C7822O10776C7843O10794C7853O10811C7906O10814C8225O10634C8231O10814C8553O10799C8568O10794C8665O10782C8682O10751C8749O10776C8798O10811C8820O10814C9449O10799C9464O10794C9605O10782C9622O10751C9724O9978I14C9743O9985I14C9757O10040I14C9775O10058I14C9829O10066I14C9849O10067I14C9909O10087I15C9940O10067I14C10000O10879C10143O10898C10286O10914C10296O10929C10318O10945C10358O10230C10674O10367I4C10818O10358C10960O10367I4C11131O10358C11286O10425C11341O10402C11354O9978I20C11374O9985I20C11395O10040I20C11413O10058I20C11466O10066I20C11486O10067I20C11546O10087I21C11577O10067I20C11617O10460C11741O10493C11787O10502C11815O10503C12216O10512I5C12290O10503C12511O10512I5C12585O10503C12781O9978I18C12801O9985I18C12815O10040I18C12833O10058I18C12886O10066I18C12906O10067I18C12966O10087I19C12997O10067I18C13122O10587C13149O10626C13177O10618C13200O10648C13210O10665C13235O10668C13565O10216C13572O10668C13894O10653C13909O10648C14013O10634C14023O10593C14090O10618C14142O10665C14160O10668C14787O10653C14802O10648C14943O10634C14960O10593C15085O9978I8C15104O9985I8C15117O10040I8C15134O10058I8C15187O10066I8C15207O10067I8C15267O10087I9C15298O10067I8C15423O10745C15450O10776C15471O10794C15481O10811C15538O10814C15867O10634C15874O10814C16195O10799C16207O10794C16304O10782C16321O10751C16388O10776C16437O10811C16459O10814C17086O10799C17101O10794C17242O10782C17259O10751C17361O9978I6C17380O9985I6C17394O10040I6C17412O10058I6C17466O10066I6C17486O10067I6C17546O10087I7C17577O10067I6C17637O10879C17650O10898C17663O10914C17673O10929C17695O10945C17735O10230C17922O10135C18129O10087I21C18176O10503C18177O10087I19C18221O10087I9C18265O10087I7C18309O10503C18311O10087I17C18355O10087I15C18399O10503,F0O10358F1O10503F0O10358F1O10503F0O10358F1O10503F2O10852F3O10067I6F2O10708F3O10067I8F2O10852F3O10067I10F2O10708F3O10067I12F2O10852F3O10067I14F2O10708F3O10067I16F2O10547F3O10067I18F2O10402F3O10067I20F2O10547F3O10067I22F2O10402F3O10067I24,S0x3b5adb5b8c88S0x3b5adb5b8cd8S0x3b5adb5b8c38S0x3b5adb5bdaf0
scavenge,begin,0,163893,1670591252489
tick,0x7f0810c8c6c0,143299,0,0x0,1
scavenge,end,0,164146,1670591252490
tick,0x1619e40,144347,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1667d26,145411,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,166141,1670591252491
scavenge,end,0,166244,1670591252492
tick,0x7f07fc046f1a,146481,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0xfcc681,147549,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1ebc81f,148616,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1e4bdb7,149679,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d84256,150745,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1df1eea,151812,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1ebc818,152880,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1f1ef28,153944,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1de84d8,155009,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1d6888b,156076,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eab010,157141,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x7f0810f42a28,158205,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x1eb9e45,159272,0,0x0,4,0x122a520,0x7f07fc0473d1,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,13,160162,0x7f07fc04ce40,12184, /home/liam/dev/advent-of-code/2022/day8/index.js:1:1,0x3b5adb5b8b80,*
code-source-info,0x7f07fc04ce40,133,0,11012,C0O0C86O10175C202O10966C221O10190C288O10175C311O10167C398O10216C526O10964C535O10295C585O10269C614O10280C639O10262C780O10321C811O10343C820O10321C879O10348C928O10357C956O10358C1224O10367I0C1243O10358C1414O10367I0C1433O10358C1475O10230C1490O10135C1520O10969C1558O10977C1563O10358C1565O0C1755O10367I0C1881O10358C2008O10367I0C2145O10358C2283O10425C2364O10402C2449O9960I5C2516O9978I5C2572O9985I5C2593O10040I5C2759O10030I5C2794O10040I5C2800O10030I5C2960O10058I5C3014O10066I5C3210O10067I5C3278O10460C3410O10493C3456O10502C3484O10503C3852O10512I1C3926O10503C4137O10512I1C4211O10503C4438O9960I4C4502O9978I4C4558O9985I4C4579O10040I4C4745O10030I4C4780O10040I4C4786O10030I4C4943O10058I4C4994O10066I4C5190O10067I4C5327O10587C5364O10626C5392O10618C5415O10665C5440O10668C5779O10216C5786O10668C6112O10653C6130O10648C6237O10634C6247O10593C6317O10618C6348O10665C6366O10668C6980O10653C6995O10648C7136O10634C7153O10593C7336O9960I3C7400O9985I3C7435O10040I3C7611O10030I3C7646O10040I3C7652O10030I3C7809O10058I3C7860O10066I3C8056O10067I3C8193O10745C8230O10776C8251O10794C8261O10811C8321O10814C8653O10634C8660O10814C8980O10799C8995O10794C9092O10782C9109O10751C9176O10776C9204O10811C9226O10814C9840O10799C9855O10794C9996O10782C10013O10751C10192O9960I2C10261O9978I2C10300O9985I2C10321O10040I2C10466O10030I2C10501O10040I2C10507O10030I2C10665O10058I2C10716O10066I2C10912O10067I2C10987O10879C11000O10898C11013O10914C11023O10929C11045O10945C11086O10230C11223O10135C11357O10503,F0O10358F1O10503F2O10852F2O10708F2O10547F2O10402,S0x3b5adb5b8c88S0x3b5adb5b8cd8S0x3b5adb5b8c38
code-creation,LazyCompile,13,160253,0x7f07fc050400,1092,firstNumIsHighest /home/liam/dev/advent-of-code/2022/day8/index.js:102:27,0x3b5adb5b8c38,*
code-source-info,0x7f07fc050400,133,9960,10102,C0O9960C140O9978C200O9985C214O10040C271O10030C424O10058C478O10066C638O10067C679O10100C706O10008C715O9960C815O10040C907O10030,,
tick,0x15bb5bc,160338,0,0x0,0,0x1643cdf,0x7f07fc04f907,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,183223,1670591252507
scavenge,end,0,183345,1670591252507
tick,0x162a0d2,161403,0,0x0,0,0x7f07fc04dbc0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,184381,1670591252508
scavenge,end,0,184454,1670591252508
tick,0x7f07fc04de51,162468,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,185755,1670591252509
scavenge,end,0,185838,1670591252509
tick,0x7f07fc04d1e0,163535,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,13,163642,0x7f07fc050940,352, /home/liam/dev/advent-of-code/2022/day8/index.js:107:28,0x3b5adb5bdaf0,*
code-source-info,0x7f07fc050940,133,10073,10098,C0O10073C52O10087C77O10089C104O10087C173O10098C226O10073C280O10087,,
scavenge,begin,0,187257,1670591252510
scavenge,end,0,187337,1670591252510
tick,0x1024170,164610,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,188392,1670591252511
scavenge,end,0,188460,1670591252511
tick,0x7f07fc04d664,165674,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,189428,1670591252512
scavenge,end,0,189494,1670591252512
tick,0x7f07fc04ea7f,166738,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,190469,1670591252513
scavenge,end,0,190535,1670591252513
tick,0x123d954,167803,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,191530,1670591252514
scavenge,end,0,191653,1670591252515
tick,0x15c7c8b,168867,0,0x0,0,0x7f07fc04de8c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,192643,1670591252516
scavenge,end,0,192708,1670591252516
tick,0x102eb0a,169932,0,0x0,0,0x1222af0,0x7f07fc04eb87,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,193668,1670591252516
scavenge,end,0,193730,1670591252517
tick,0x7f07fc04e9aa,170997,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,194730,1670591252518
scavenge,end,0,194800,1670591252518
tick,0x1657d47,172060,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,195983,1670591252519
scavenge,end,0,196048,1670591252519
tick,0x15c7c86,173125,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,197160,1670591252520
scavenge,end,0,197239,1670591252520
tick,0x10e6071,174189,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,198370,1670591252521
scavenge,end,0,198434,1670591252521
tick,0x1659196,175253,0,0x0,0,0x7f07fc04ecf4,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,199564,1670591252522
scavenge,end,0,199635,1670591252522
tick,0x1657d47,176318,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,200790,1670591252523
tick,0xf63d18,177375,0,0x0,1
scavenge,end,0,200902,1670591252523
scavenge,begin,0,201887,1670591252524
tick,0xf63d05,178439,0,0x0,1
scavenge,end,0,202008,1670591252525
tick,0x10e8814,179508,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,203086,1670591252526
scavenge,end,0,203151,1670591252526
tick,0x15c7c80,180571,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,204326,1670591252527
scavenge,end,0,204391,1670591252527
tick,0xd3c39b,181636,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,205454,1670591252528
scavenge,end,0,205517,1670591252528
tick,0x10e8e08,182700,0,0x0,0,0x123d7f0,0x1629e1f,0x7f07fc04dbc0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,206645,1670591252529
scavenge,end,0,206723,1670591252529
tick,0x1657d9f,183764,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,207776,1670591252530
scavenge,end,0,207842,1670591252530
tick,0x102eb6c,184829,0,0x0,0,0x1222af0,0x7f07fc04d5e2,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,208924,1670591252531
scavenge,end,0,208989,1670591252531
tick,0x7f07fc0509fe,185893,0,0x0,0,0x1643cdf,0x7f07fc04eddf,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,210097,1670591252532
scavenge,end,0,210161,1670591252532
tick,0x7f07fc04f24a,186957,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,211257,1670591252533
scavenge,end,0,211334,1670591252534
tick,0x123a68e,188020,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,212373,1670591252535
scavenge,end,0,212439,1670591252535
tick,0x123d92c,189086,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,213547,1670591252536
scavenge,end,0,213610,1670591252536
tick,0x7f07fc04de9e,190150,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,214725,1670591252537
scavenge,end,0,214791,1670591252537
tick,0xd3c3a3,191215,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,215875,1670591252538
scavenge,end,0,215953,1670591252538
tick,0x15bb4ca,192278,0,0x0,0,0x7f07fc04f907,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,217064,1670591252539
scavenge,end,0,217129,1670591252539
tick,0x1103282,193344,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,218146,1670591252540
scavenge,end,0,218210,1670591252540
tick,0x15c7c86,194408,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,219221,1670591252541
scavenge,end,0,219284,1670591252541
tick,0x165761d,195473,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,220228,1670591252542
scavenge,end,0,220298,1670591252542
tick,0x106e091,196536,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,221322,1670591252543
scavenge,end,0,221386,1670591252543
tick,0x1657e49,197601,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,222374,1670591252544
scavenge,end,0,222439,1670591252544
tick,0x7f07fc0509dd,198666,0,0x0,0,0x1643cdf,0x7f07fc04eddf,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,223443,1670591252545
scavenge,end,0,223506,1670591252545
tick,0x16364e5,199729,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,224528,1670591252546
scavenge,end,0,224611,1670591252546
tick,0x123a570,200793,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,225615,1670591252547
scavenge,end,0,225679,1670591252547
tick,0x15e7b12,201858,0,0x0,0,0x1657d0a,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,226635,1670591252548
scavenge,end,0,226701,1670591252548
tick,0x163c271,202922,0,0x0,0,0x1657e45,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,227673,1670591252549
scavenge,end,0,227737,1670591252549
tick,0x1659140,203993,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,228820,1670591252550
scavenge,end,0,228904,1670591252550
tick,0x7f07fc04f25e,205054,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,229982,1670591252551
scavenge,end,0,230047,1670591252552
tick,0x1643c58,206119,0,0x0,0,0x7f07fc04e2ad,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,231088,1670591252553
scavenge,end,0,231151,1670591252553
tick,0x1050fd0,207183,0,0x0,0,0x1222af0,0x7f07fc04dde9,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,232261,1670591252554
scavenge,end,0,232325,1670591252554
tick,0x7f07fc0509ac,208248,0,0x0,0,0x1643cdf,0x7f07fc04daf4,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,233529,1670591252555
scavenge,end,0,233615,1670591252555
tick,0x102e9b4,209311,0,0x0,0,0x1222af0,0x7f07fc04d5e2,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,234616,1670591252556
scavenge,end,0,234681,1670591252556
tick,0x16388b7,210375,0,0x0,0,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,235812,1670591252557
scavenge,end,0,235876,1670591252557
tick,0x7f07fc04f218,211440,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,236951,1670591252558
scavenge,end,0,237014,1670591252558
tick,0x7f07fc04f22a,212519,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,238135,1670591252559
scavenge,end,0,238221,1670591252559
tick,0x7f07fc04d66c,213582,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,239379,1670591252561
scavenge,end,0,239445,1670591252561
tick,0x10e7fdb,214654,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,240541,1670591252562
scavenge,end,0,240605,1670591252562
tick,0x7f0810c8c7b9,215748,0,0x0,0,0x15efcbd,0x1659877,0x7f07fc04ecf4,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,241733,1670591252563
tick,0x1272d20,216805,0,0x0,1
scavenge,end,0,241841,1670591252563
tick,0x15c7c80,217875,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,242953,1670591252564
scavenge,end,0,243029,1670591252564
tick,0x7f07fc04ea0d,218939,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,244061,1670591252565
scavenge,end,0,244124,1670591252565
tick,0x123a69f,220004,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,245166,1670591252566
scavenge,end,0,245229,1670591252566
tick,0x15c7c86,221068,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,246391,1670591252567
scavenge,end,0,246456,1670591252567
tick,0x123a5d4,222132,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,247526,1670591252568
scavenge,end,0,247603,1670591252568
tick,0x7f07fc04d295,223196,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,248602,1670591252569
scavenge,end,0,248666,1670591252569
tick,0x7f07fc04f4d6,224260,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,249900,1670591252571
scavenge,end,0,249965,1670591252571
tick,0x165982f,225326,0,0x0,0,0x7f07fc04f81c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,251026,1670591252572
scavenge,end,0,251089,1670591252572
tick,0x1643c92,226390,0,0x0,0,0x7f07fc04daf4,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,252027,1670591252573
scavenge,end,0,252111,1670591252573
tick,0x1103271,227453,0,0x0,0,0x123d7f0,0x1657d8e,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,253031,1670591252574
scavenge,end,0,253096,1670591252574
tick,0x165972d,228536,0,0x0,0,0x7f07fc04f81c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,254147,1670591252575
scavenge,end,0,254210,1670591252575
tick,0x15bb840,229587,0,0x0,0,0x7f07fc04e2ad,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,255239,1670591252576
scavenge,end,0,255303,1670591252576
tick,0x123d92c,230651,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,256301,1670591252577
scavenge,end,0,256387,1670591252577
tick,0x7f07fc04df44,231715,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,257326,1670591252578
scavenge,end,0,257395,1670591252578
tick,0x10e6225,232779,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,258411,1670591252579
scavenge,end,0,258475,1670591252579
scavenge,begin,0,259385,1670591252580
scavenge,end,0,259451,1670591252580
tick,0x7f0810b93120,233874,0,0x0,1
scavenge,begin,0,260461,1670591252581
scavenge,end,0,260545,1670591252581
tick,0x1643941,234927,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,261531,1670591252582
scavenge,end,0,261595,1670591252582
tick,0x7f07fc04d730,235992,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,262644,1670591252583
scavenge,end,0,262708,1670591252583
tick,0x123d812,237056,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,263648,1670591252584
scavenge,end,0,263713,1670591252584
tick,0x1659141,238120,0,0x0,0,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,264700,1670591252585
scavenge,end,0,264782,1670591252585
tick,0x123d95e,239184,0,0x0,0,0x123d7f0,0x1657d40,0x7f07fc04d77c,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
scavenge,begin,0,265722,1670591252586
scavenge,end,0,265785,1670591252586
tick,0xe1e924,240249,0,0x0,0,0x122a1c0,0x3b5adb5b8ffa,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,240342,0x1bda378e2a6e,38,log node:internal/console/constructor:359:6,0x273b9799df10,~
code-source-info,0x1bda378e2a6e,37,11007,11091,C0O11007C3O11023C5O11028C7O11027C13O11045C18O11062C20O11061C24O11079C30O11044C37O11090,,
code-creation,LazyCompile,10,240410,0x1bda378e2ba6,50,value node:internal/console/constructor:321:20,0x273b9799ddb0,~
code-source-info,0x1bda378e2ba6,37,9574,9746,C0O9602C2O9607C4O9606C8O9632C13O9626C19O9648C24O9648C29O9689C36O9709C44O9696C49O9740,,
code-creation,LazyCompile,10,240481,0x1bda378e2cbe,27,get node:internal/console/constructor:203:14,0x109acf095cb8,~
code-source-info,0x1bda378e2cbe,37,5761,5853,C0O5778C6O5791C9O5807C16O5798C22O5827C26O5841,,
code-creation,LazyCompile,10,240581,0x1bda378e2ece,144,getStdout node:internal/bootstrap/switches/is_main_thread:136:19,0x2989f359bdc8,~
script-source,93,node:internal/bootstrap/switches/is_main_thread,'use strict';\n\nconst { ObjectDefineProperty } = primordials;\nconst rawMethods = internalBinding('process_methods');\n\n// TODO(joyeecheung): deprecate and remove these underscore methods\nprocess._debugProcess = rawMethods._debugProcess;\nprocess._debugEnd = rawMethods._debugEnd;\n\n// See the discussion in https://github.com/nodejs/node/issues/19009 and\n// https://github.com/nodejs/node/pull/34010 for why these are no-ops.\n// Five word summary: they were broken beyond repair.\nprocess._startProfilerIdleNotifier = () => {};\nprocess._stopProfilerIdleNotifier = () => {};\n\nfunction defineStream(name\x2C getter) {\n  ObjectDefineProperty(process\x2C name\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: getter\n  });\n}\n\ndefineStream('stdout'\x2C getStdout);\ndefineStream('stdin'\x2C getStdin);\ndefineStream('stderr'\x2C getStderr);\n\n// Worker threads don't receive signals.\nconst {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n} = require('internal/process/signal');\nprocess.on('newListener'\x2C startListeningIfSignal);\nprocess.on('removeListener'\x2C stopListeningIfSignal);\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst { guessHandleType } = internalBinding('util');\n\nfunction createWritableStdioStream(fd) {\n  let stream;\n  // Note stream._type is used for test-module-load-list.js\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n    }\n\n    case 'FILE': {\n      const SyncWriteStream = require('internal/fs/sync_write_stream');\n      stream = new SyncWriteStream(fd\x2C { autoClose: false });\n      stream._type = 'fs';\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // If fd is already being used for the IPC channel\x2C libuv will return\n      // an error when trying to use it again. In that case\x2C create the socket\n      // using the existing handle instead of the fd.\n      if (process.channel && process.channel.fd === fd) {\n        const { kChannelHandle } = require('internal/child_process');\n        stream = new net.Socket({\n          handle: process[kChannelHandle]\x2C\n          readable: false\x2C\n          writable: true\n        });\n      } else {\n        stream = new net.Socket({\n          fd\x2C\n          readable: false\x2C\n          writable: true\n        });\n      }\n\n      stream._type = 'pipe';\n      break;\n    }\n\n    default: {\n      // Provide a dummy black-hole output for e.g. non-console\n      // Windows applications.\n      const { Writable } = require('stream');\n      stream = new Writable({\n        write(buf\x2C enc\x2C cb) {\n          cb();\n        }\n      });\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\nfunction dummyDestroy(err\x2C cb) {\n  cb(err);\n  this._undestroy();\n\n  // We need to emit 'close' anyway so that the closing\n  // of the stream is observable. We just make sure we\n  // are not going to do it twice.\n  // The 'close' event is needed so that finished and\n  // pipeline work correctly.\n  if (!this._writableState.emitClose) {\n    process.nextTick(() => {\n      this.emit('close');\n    });\n  }\n}\n\nlet stdin;\nlet stdout;\nlet stderr;\n\nlet stdoutDestroy;\nlet stderrDestroy;\n\nfunction refreshStdoutOnSigWinch() {\n  stdout._refreshSize();\n}\n\nfunction refreshStderrOnSigWinch() {\n  stderr._refreshSize();\n}\n\nfunction getStdout() {\n  if (stdout) return stdout;\n  stdout = createWritableStdioStream(1);\n  stdout.destroySoon = stdout.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stdoutDestroy = stdout._destroy;\n  stdout._destroy = dummyDestroy;\n  if (stdout.isTTY) {\n    process.on('SIGWINCH'\x2C refreshStdoutOnSigWinch);\n  }\n\n  internalBinding('mksnapshot').cleanups.push(function cleanupStdout() {\n    stdout._destroy = stdoutDestroy;\n    stdout.destroy();\n    process.removeListener('SIGWINCH'\x2C refreshStdoutOnSigWinch);\n    stdout = undefined;\n  });\n  return stdout;\n}\n\nfunction getStderr() {\n  if (stderr) return stderr;\n  stderr = createWritableStdioStream(2);\n  stderr.destroySoon = stderr.destroy;\n  stderrDestroy = stderr._destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stderr._destroy = dummyDestroy;\n  if (stderr.isTTY) {\n    process.on('SIGWINCH'\x2C refreshStderrOnSigWinch);\n  }\n  internalBinding('mksnapshot').cleanups.push(function cleanupStderr() {\n    stderr._destroy = stderrDestroy;\n    stderr.destroy();\n    process.removeListener('SIGWINCH'\x2C refreshStderrOnSigWinch);\n    stderr = undefined;\n  });\n  return stderr;\n}\n\nfunction getStdin() {\n  if (stdin) return stdin;\n  const fd = 0;\n\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stdin = new tty.ReadStream(fd);\n      break;\n    }\n\n    case 'FILE': {\n      const fs = require('fs');\n      stdin = new fs.ReadStream(null\x2C { fd: fd\x2C autoClose: false });\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // It could be that process has been started with an IPC channel\n      // sitting on fd=0\x2C in such case the pipe for this fd is already\n      // present and creating a new one will lead to the assertion failure\n      // in libuv.\n      if (process.channel && process.channel.fd === fd) {\n        stdin = new net.Socket({\n          handle: process.channel\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\n        });\n      } else {\n        stdin = new net.Socket({\n          fd: fd\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\n        });\n      }\n      // Make sure the stdin can't be `.end()`-ed\n      stdin._writableState.ended = true;\n      break;\n    }\n\n    default: {\n      // Provide a dummy contentless input for e.g. non-console\n      // Windows applications.\n      const { Readable } = require('stream');\n      stdin = new Readable({ read() {} });\n      stdin.push(null);\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stdin.fd = fd;\n\n  // `stdin` starts out life in a paused state\x2C but node doesn't\n  // know yet. Explicitly to readStop() it to put it in the\n  // not-reading state.\n  if (stdin._handle && stdin._handle.readStop) {\n    stdin._handle.reading = false;\n    stdin._readableState.reading = false;\n    stdin._handle.readStop();\n  }\n\n  // If the user calls stdin.pause()\x2C then we need to stop reading\n  // once the stream implementation does so (one nextTick later)\x2C\n  // so that the process can close down.\n  stdin.on('pause'\x2C () => {\n    process.nextTick(onpause);\n  });\n\n  function onpause() {\n    if (!stdin._handle)\n      return;\n    if (stdin._handle.reading && !stdin.readableFlowing) {\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    }\n  }\n\n  internalBinding('mksnapshot').cleanups.push(function cleanupStdin() {\n    stdin.destroy();\n    stdin = undefined;\n  });\n  return stdin;\n}\n\n// Used by internal tests.\nrawMethods.resetStdioForTesting = function() {\n  stdin = undefined;\n  stdout = undefined;\n  stderr = undefined;\n};\n
code-source-info,0x1bda378e2ece,93,3508,4080,C0O3515C6O3527C10O3541C11O3544C17O3553C24O3551C30O3585C37O3606C40O3613C44O3604C48O3688C53O3711C60O3702C66O3723C73O3739C77O3757C82O3768C88O3781C91O3789C102O3789C108O3837C114O3837C119O3866C124O3875C134O3876C139O4064C143O4078,,
code-creation,LazyCompile,10,241005,0x1bda378e3c6e,280,createWritableStdioStream node:internal/bootstrap/switches/is_main_thread:41:35,0x2989f359bc88,~
code-source-info,0x1bda378e3c6e,93,1312,2877,C0O1325C2O1395C7O1403C42O1462C48O1462C53O1501C60O1493C66O1524C68O1537C72O1552C74O1615C80O1615C85O1692C95O1672C101O1725C103O1738C107O1752C109O1819C115O1819C120O2051C123O2063C132O2082C137O2090C144O2093C149O2138C155O2138C160O2119C165O2198C180O2232C189O2190C197O2354C209O2373C215O2346C221O2456C223O2469C227O2485C229O2636C235O2636C240O2623C245O2661C250O2693C260O2670C266O2815C268O2825C272O2834C273O2850C277O2861C279O2875,,
code-creation,Eval,10,241238,0x1bda378e439e,5, node:tty:1:1,0x1bda378e4198,~
script-source,134,node:tty,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  NumberIsInteger\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst net = require('net');\nconst { TTY\x2C isTTY } = internalBinding('tty_wrap');\nconst errors = require('internal/errors');\nconst { ERR_INVALID_FD\x2C ERR_TTY_INIT_FAILED } = errors.codes;\nconst {\n  getColorDepth\x2C\n  hasColors\n} = require('internal/tty');\n\n// Lazy loaded for startup performance.\nlet readline;\n\nfunction isatty(fd) {\n  return NumberIsInteger(fd) && fd >= 0 && fd <= 2147483647 &&\n         isTTY(fd);\n}\n\nfunction ReadStream(fd\x2C options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(fd\x2C options);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n\n  const ctx = {};\n  const tty = new TTY(fd\x2C ctx);\n  if (ctx.code !== undefined) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n\n  net.Socket.call(this\x2C {\n    readableHighWaterMark: 0\x2C\n    handle: tty\x2C\n    manualStart: true\x2C\n    ...options\n  });\n\n  this.isRaw = false;\n  this.isTTY = true;\n}\n\nObjectSetPrototypeOf(ReadStream.prototype\x2C net.Socket.prototype);\nObjectSetPrototypeOf(ReadStream\x2C net.Socket);\n\nReadStream.prototype.setRawMode = function(flag) {\n  flag = !!flag;\n  const err = this._handle.setRawMode(flag);\n  if (err) {\n    this.emit('error'\x2C errors.errnoException(err\x2C 'setRawMode'));\n    return this;\n  }\n  this.isRaw = flag;\n  return this;\n};\n\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(fd);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n\n  const ctx = {};\n  const tty = new TTY(fd\x2C ctx);\n  if (ctx.code !== undefined) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n\n  net.Socket.call(this\x2C {\n    readableHighWaterMark: 0\x2C\n    handle: tty\x2C\n    manualStart: true\n  });\n\n  // Prevents interleaved or dropped stdout/stderr output for terminals.\n  // As noted in the following reference\x2C local TTYs tend to be quite fast and\n  // this behavior has become expected due historical functionality on OS X\x2C\n  // even though it was originally intended to change in v1.0.2 (Libuv 1.2.1).\n  // Ref: https://github.com/nodejs/node/pull/1771#issuecomment-119351671\n  this._handle.setBlocking(true);\n\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (!err) {\n    this.columns = winSize[0];\n    this.rows = winSize[1];\n  }\n}\n\nObjectSetPrototypeOf(WriteStream.prototype\x2C net.Socket.prototype);\nObjectSetPrototypeOf(WriteStream\x2C net.Socket);\n\nWriteStream.prototype.isTTY = true;\n\nWriteStream.prototype.getColorDepth = getColorDepth;\n\nWriteStream.prototype.hasColors = hasColors;\n\nWriteStream.prototype._refreshSize = function() {\n  const oldCols = this.columns;\n  const oldRows = this.rows;\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (err) {\n    this.emit('error'\x2C errors.errnoException(err\x2C 'getWindowSize'));\n    return;\n  }\n  const { 0: newCols\x2C 1: newRows } = winSize;\n  if (oldCols !== newCols || oldRows !== newRows) {\n    this.columns = newCols;\n    this.rows = newRows;\n    this.emit('resize');\n  }\n};\n\n// Backwards-compat\nWriteStream.prototype.cursorTo = function(x\x2C y\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.cursorTo(this\x2C x\x2C y\x2C callback);\n};\nWriteStream.prototype.moveCursor = function(dx\x2C dy\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.moveCursor(this\x2C dx\x2C dy\x2C callback);\n};\nWriteStream.prototype.clearLine = function(dir\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.clearLine(this\x2C dir\x2C callback);\n};\nWriteStream.prototype.clearScreenDown = function(callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.clearScreenDown(this\x2C callback);\n};\nWriteStream.prototype.getWindowSize = function() {\n  return [this.columns\x2C this.rows];\n};\n\nmodule.exports = { isatty\x2C ReadStream\x2C WriteStream };\n
code-source-info,0x1bda378e439e,134,0,5054,C0O0C4O5054,,
code-creation,Function,10,241532,0x1bda378e4a76,426, node:tty:1:1,0x1bda378e4318,~
code-source-info,0x1bda378e4a76,134,0,5054,C0O0C53O1159C59O1168C65O1187C70O1239C76O1239C80O1239C82O1278C85O1278C90O1263C96O1268C102O1322C108O1322C112O1322C114O1398C117O1405C122O1358C128O1374C134O1453C140O1453C145O1422C150O1439C155O1523C156O1523C158O2112C161O2144C169O2159C174O2166C179O2112C184O2178C190O2215C195O2178C200O2225C203O2236C212O2257C216O3451C219O3484C227O3499C232O3506C237O3451C242O3518C248O3556C253O3518C258O3566C261O3578C267O3594C271O3603C274O3615C281O3639C285O3657C288O3669C295O3689C299O3703C302O3715C311O3738C315O4199C318O4211C327O4230C331O4374C334O4386C343O4407C347O4557C350O4569C359O4589C363O4732C366O4744C375O4770C379O4909C382O4921C391O4945C395O5000C402O5019C408O5027C414O5039C420O5015C425O5053,,
tick,0x7f0810fb3696,241576,1,0xb83830,3,0xd81050,0x7f07fc0432c7,0x7f07fc0439d1,0x1bda378e3c9e,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,Eval,10,241880,0x1bda378e5fd6,5, node:internal/tty:1:1,0x1bda378e5d80,~
script-source,135,node:internal/tty,// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\n// of this software and associated documentation files (the "Software")\x2C to deal\n// in the Software without restriction\x2C including without limitation the rights\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\n// copies of the Software\x2C and to permit persons to whom the Software is\n// furnished to do so\x2C subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors\x2C but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\n// distribution of this file\x2C with or without modification\x2C are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16\x2C\n  'cons25': COLORS_16\x2C\n  'console': COLORS_16\x2C\n  'cygwin': COLORS_16\x2C\n  'dtterm': COLORS_16\x2C\n  'gnome': COLORS_16\x2C\n  'hurd': COLORS_16\x2C\n  'jfbterm': COLORS_16\x2C\n  'konsole': COLORS_16\x2C\n  'kterm': COLORS_16\x2C\n  'mlterm': COLORS_16\x2C\n  'mosh': COLORS_16m\x2C\n  'putty': COLORS_16\x2C\n  'st': COLORS_16\x2C\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m\x2C\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/\x2C\n  /color/\x2C\n  /linux/\x2C\n  /^con[0-9]*x[0-9]/\x2C\n  /^rxvt/\x2C\n  /^screen/\x2C\n  /^xterm/\x2C\n  /^vt100/\x2C\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += "' and '";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\n      'Warning'\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color\x2C\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ([\n      'APPVEYOR'\x2C\n      'BUILDKITE'\x2C\n      'CIRCLECI'\x2C\n      'DRONE'\x2C\n      'GITHUB_ACTIONS'\x2C\n      'GITLAB_CI'\x2C\n      'TRAVIS'\x2C\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeTest(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeTest(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION)\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeTest(/^xterm-256/\x2C env.TERM)) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\n                           (term) => RegExpPrototypeTest(term\x2C termEnv))) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count\x2C env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count\x2C 'count'\x2C 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth\x2C\n  hasColors\n};\n
code-source-info,0x1bda378e5fd6,135,0,6446,C0O0C4O6446,,
code-creation,Function,10,242195,0x1bda378e6436,358, node:internal/tty:1:1,0x1bda378e5f50,~
code-source-info,0x1bda378e6436,135,0,6446,C0O0C69O1186C75O1208C81O1231C87O1255C93O1329C99O1329C104O1309C110O1366C111O1366C113O1395C115O1395C117O1416C119O1416C121O1438C123O1438C125O1460C127O1460C129O1877C136O1890C142O1913C148O1937C154O1960C160O1983C166O2005C172O2026C178O2050C184O2074C190O2096C196O2119C202O2140C208O2163C214O2182C220O2287C226O2379C232O1877C234O2420C328O2420C330O2541C331O2541C333O6395C340O6416C346O6433C352O6410C357O6445,,
tick,0x7f0810c85e70,242385,0,0x0,2,0x123ee50,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,242429,0x1bda378e71d6,192,WriteStream node:tty:84:21,0x1bda378e4470,~
code-source-info,0x1bda378e71d6,134,2498,3449,C0O2507C2O2518C7O2547C12O2554C17O2574C18O2577C20O2584C26O2589C32O2602C37O2611C44O2617C49O2611C50O2656C52O2674C65O2674C71O2702C77O2728C84O2734C89O2728C90O2771C95O2775C100O2782C112O2837C116O2782C122O3260C127O3268C134O3268C139O3306C149O3306C155O3339C160O3347C165O3347C171O3373C173O3389C174O3411C177O3402C181O3420C183O3439C186O3430C191O3448,,
code-creation,LazyCompile,10,242623,0x1bda378e7db6,914,Socket node:net:291:16,0x25349b144bc0,~
code-source-info,0x1bda378e7db6,113,7326,11784,C0O7340C2O7351C7O7371C12O7378C17O7398C18O7401C25O7412C34O7432C42O7507C52O7438C57O7432C58O7560C65O7571C81O7602C90O7630C98O7697C115O7786C121O7816C131O7636C136O7630C137O7874C144O7892C155O7939C167O7968C178O7939C183O8049C189O8071C194O8084C195O8114C199O8132C200O8148C204O8352C206O8357C211O8374C215O8382C216O8397C220O8408C222O8413C226O8422C230O8432C231O8445C235O8455C236O8466C240O8476C242O8481C246O8502C250O8509C252O8514C256O8524C260O8534C262O8539C266O8548C270O8558C272O8563C276O8574C280O8584C282O8589C286O8601C290O8612C296O8649C303O8665C314O8708C320O8787C322O8811C325O8827C330O8811C334O8809C338O8901C339O8919C343O8930C344O8950C348O8990C349O9012C353O9023C358O9030C363O9037C368O9037C374O9073C380O9110C384O9100C388O9133C390O9138C396O9176C401O9157C405O9155C411O9207C417O9239C422O9263C424O9381C429O9396C434O9394C438O9437C443O9445C448O9445C454O9702C456O9717C464O9723C469O9717C470O9757C472O9762C475O9786C480O9794C485O9794C489O9779C493O9813C495O9821C502O9833C507O9857C514O9876C516O9865C523O9885C527O9967C532O9975C539O9975C545O10000C547O10017C555O10023C560O10017C561O10066C562O10079C566O10093C568O10107C571O10107C575O10105C579O10298C584O10324C597O10298C602O10430C607O10440C617O10500C620O10520C625O10500C631O10545C639O10591C647O10640C655O10671C657O10676C661O10685C665O10699C667O10704C670O10725C674O10716C680O10752C682O10757C685O10775C689O10766C693O10793C695O10798C698O10818C702O10809C706O10835C708O10840C713O10855C716O10871C721O10855C725O10853C729O10883C731O10888C736O10905C739O10921C744O10905C748O10903C752O10935C754O10940C757O10980C761O11002C767O10970C769O10969C771O10967C775O11074C786O11074C792O11109C795O11109C799O11136C800O11154C804O11164C806O11186C810O11327C816O11346C822O11355C827O11384C833O11471C839O11487C843O11507C848O11515C853O11515C857O11533C858O11554C864O11587C870O11613C877O11613C882O11659C883O11671C887O11681C888O11694C892O11734C894O11739C898O11751C902O11758C904O11763C908O11778C913O11783,,
code-creation,LazyCompile,10,242725,0x1bda378e8526,169,Duplex node:internal/streams/duplex:54:16,0x39a167da8ba8,~
script-source,56,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  const keys = ObjectKeys(Writable.prototype);\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i];\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this\x2C options);\n  Writable.call(this\x2C options);\n\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  } else {\n    this.allowHalfOpen = true;\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable')\x2C\n  writableHighWaterMark:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark')\x2C\n  writableObjectMode:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode')\x2C\n  writableBuffer:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer')\x2C\n  writableLength:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength')\x2C\n  writableFinished:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished')\x2C\n  writableCorked:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked')\x2C\n  writableEnded:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded')\x2C\n  writableNeedDrain:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain')\x2C\n\n  destroyed: {\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\n  }\n});\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nDuplex.fromWeb = function(pair\x2C options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\n    pair\x2C\n    options);\n};\n\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0x1bda378e8526,56,2011,2663,C0O2025C2O2036C7O2060C12O2067C17O2087C18O2091C23O2100C28O2100C34O2123C39O2132C44O2132C50O2156C54O2204C60O2218C64O2194C68O2246C74O2255C79O2279C85O2303C89O2323C95O2344C99O2363C105O2389C109O2420C115O2429C120O2453C126O2477C130O2497C136O2519C140O2538C146O2559C150O2578C156O2602C162O2631C163O2650C168O2662,,
code-creation,LazyCompile,10,243088,0x1bda378e8cde,220,Readable node:internal/streams/readable:186:18,0x39a167db3e38,~
script-source,57,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  SymbolAsyncIterator\x2C\n  Symbol\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst BufferList = require('internal/streams/buffer_list');\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\n  }\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst kPaused = Symbol('kPaused');\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.readableObjectMode);\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Has it been destroyed.\n  this.destroyed = false;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n\n  // If true\x2C a maybeReadMore has been scheduled.\n  this.readingMore = false;\n\n  this.dataEmitted = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor\x2C at least with V8 6.5.\n  const isDuplex = this instanceof Stream.Duplex;\n\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal && !isDuplex)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this\x2C this._readableState);\n    }\n  });\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\n};\n\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\n  debug('readableAddChunk'\x2C chunk);\n  const state = stream._readableState;\n\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk\x2C encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  if (err) {\n    errorOrDestroy(stream\x2C err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream\x2C state);\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if (state.endEmitted)\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else if (state.destroyed || state.errored)\n        return false;\n      else\n        addChunk(stream\x2C state\x2C chunk\x2C true);\n    } else if (state.ended) {\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream\x2C state\x2C chunk\x2C false);\n        else\n          maybeReadMore(stream\x2C state);\n      } else {\n        addChunk(stream\x2C state\x2C chunk\x2C false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream\x2C state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return !state.ended &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync &&\n      stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state.dataEmitted = true;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '')\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       state.ended)) {\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = state.needReadable;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if (state.ended || state.reading || state.destroyed || state.errored ||\n      !state.constructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n\n    // Call internal read method\n    try {\n      const result = this._read(state.highWaterMark);\n      if (result != null) {\n        const then = result.then;\n        if (typeof then === 'function') {\n          then.call(\n            result\x2C\n            nop\x2C\n            function(err) {\n              errorOrDestroy(this\x2C err);\n            });\n        }\n      }\n    } catch (err) {\n      errorOrDestroy(this\x2C err);\n    }\n\n    state.sync = false;\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  if (state.sync) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable'\x2C state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state.needReadable =\n    !state.flowing &&\n    !state.ended &&\n    state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended &&\n         (state.length < state.highWaterMark ||\n          (state.flowing && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable'\x2C state.length\x2C state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this\x2C state);\n  }\n  state[kPaused] = false;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow'\x2C state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable'\x2C next);\n\n  let error;\n  const cleanup = eos(stream\x2C { writable: false }\x2C (err) => {\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error\x2C err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream\x2C null);\n    } else {\n      stream.off('readable'\x2C next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  }\x2C\n\n  readableDidRead: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\n  }\x2C\n\n  readableAborted: {\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    }\n  }\x2C\n\n  readableHighWaterMark: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\n  }\x2C\n\n  readableBuffer: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\n  }\x2C\n\n  readableFlowing: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  }\x2C\n\n  readableLength: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\n  }\x2C\n\n  readableObjectMode: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  }\x2C\n\n  readableEncoding: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  }\x2C\n\n  destroyed: {\n    enumerable: false\x2C\n    get() {\n      if (this._readableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  }\x2C\n\n  readableEnded: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    get() {\n      return this.pipes.length;\n    }\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    get() {\n      return this[kPaused] !== false;\n    }\x2C\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n\x2C state.decoder);\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable'\x2C state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted &&\n      !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream\x2C options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream\x2C\n    options);\n};\n\nReadable.toWeb = function(streamReadable) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\n  }).wrap(src);\n};\n
code-source-info,0x1bda378e8cde,57,6353,7224,C0O6353C9O6367C16O6378C21O6404C28O6411C33O6433C34O6588C41O6604C44O6611C48O6593C52O6622C71O6644C76O6642C80O6691C84O6729C92O6756C95O6777C99O6767C103O6807C111O6837C114O6861C118O6851C122O6894C130O6926C133O6952C137O6942C141O6980C149O6991C151O7007C158O7030C166O7007C171O7052C178O7059C186O7059C192O7083C199O7095C212O7095C219O7223,,
tick,0x7f0810b84300,245036,0,0x0,3,0x123ee50,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x7f0810b8437b,245048,0,0x0,3,0x123ee50,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,245064,0x1bda378ebb46,18,Stream node:internal/streams/legacy:10:16,0x39a167db6788,~
script-source,58,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0x1bda378ebb46,58,127,160,C0O138C5O141C10O141C17O159,,
code-creation,LazyCompile,10,245230,0x1bda378ebfe6,21,EventEmitter node:events:208:22,0x136fed7263a0,~
code-source-info,0x1bda378ebfe6,23,6267,6315,C0O6278C3O6291C8O6296C13O6296C20O6314,,
code-creation,LazyCompile,10,245461,0x1bda378ec4b6,354,ReadableState node:internal/streams/readable:83:23,0x39a167db3de8,~
code-source-info,0x1bda378ec4b6,57,2626,6333,C0O2964C6O3003C8O3032C11O3039C15O3021C20O3172C25O3193C27O3212C33O3188C37O3228C41O3269C52O3292C54O3311C60O3262C64O3477C69O3498C73O3512C88O3512C97O3585C102O3585C106O3496C110O3788C112O3806C115O3802C120O3800C124O3822C125O3834C129O3841C131O3852C135O3860C136O3873C140O3883C141O3894C145O3905C146O3921C150O3932C151O3945C155O4139C156O4156C160O4436C161O4446C165O4567C166O4585C170O4596C171O4617C175O4628C176O4651C180O4662C181O4683C185O4694C187O4699C191O4708C195O4794C196O4812C200O4883C202O4901C208O4920C214O4930C218O4898C222O5017C224O5037C230O5056C236O5068C240O5034C244O5110C245O5125C249O5378C250O5391C254O5461C255O5473C259O5577C260O5595C264O5802C269O5826C271O5845C279O5823C283O5978C284O6001C288O6011C289O6032C293O6094C294O6111C298O6123C299O6140C303O6152C304O6165C308O6175C309O6189C313O6199C317O6222C323O6238C325O6257C328O6279C335O6253C340O6251C344O6318C348O6308C353O6332,,
code-creation,LazyCompile,10,245545,0x1bda378ec8c6,98,getHighWaterMark node:internal/streams/state:19:26,0x39a167db91a0,~
script-source,61,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? 16 : 16 * 1024;\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n};\n
code-source-info,0x1bda378ec8c6,61,424,832,C0O478C12O478C18O529C21O552C26O557C33O585C38O611C47O633C56O678C69O684C74O678C75O732C80O739C84O754C85O781C88O818C93O788C97O830,,
tick,0x7f0810b905d0,245653,0,0x0,3,0x1229670,0x1bda378ec50e,0x1bda378e8d25,0x1bda378e8542,0x1bda378e7f26,0x1bda378e724a,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,245674,0x1bda378ecb5e,26,highWaterMarkFrom node:internal/streams/state:10:27,0x39a167db9040,~
code-source-info,0x1bda378ecb5e,61,168,309,C0O218C7O250C15O270C19O288C25O307,,
code-creation,LazyCompile,10,245720,0x1bda378ecc66,17,BufferList node:internal/streams/buffer_list:14:14,0x39a167db8520,~
script-source,60,node:internal/streams/buffer_list,'use strict';\n\nconst {\n  StringPrototypeSlice\x2C\n  SymbolIterator\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { inspect } = require('internal/util/inspect');\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v\x2C next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v\x2C next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while ((p = p.next) !== null)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n\x2C hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0\x2C n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n\n  first() {\n    return this.head.data;\n  }\n\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str\x2C n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\n                                 retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n};\n
code-source-info,0x1bda378ecc66,60,265,338,C0O274C1O284C5O296C6O306C10O318C11O330C16O337,,
code-creation,LazyCompile,10,245989,0x1bda378ed3b6,149,EventEmitter.init node:events:327:29,0x136fed726798,~
code-source-info,0x1bda378ed3b6,23,9680,10269,C0O9701C6O9737C13O9749C16O9749C21O9775C25O9745C30O9791C32O9806C37O9806C41O9804C45O9830C46O9848C50O9886C60O9879C64O9918C71O9926C80O9953C85O9974C93O9953C98O10027C100O10032C105O10044C108O10057C113O10044C117O10042C123O10213C125O10218C131O10243C138O10253C140O10252C143O10228C148O10268,,
code-creation,LazyCompile,10,246072,0x1bda378ed5ae,98,construct node:internal/streams/destroy:232:19,0x39a167da7520,~
script-source,55,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\nconst {\n  kDestroyed\x2C\n  isDestroyed\x2C\n  isFinished\x2C\n  isServerRequest\n} = require('internal/streams/utils');\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    const result = self._destroy(err || null\x2C onDestroy);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            process.nextTick(onDestroy\x2C null);\n          }\x2C\n          function(err) {\n            process.nextTick(onDestroy\x2C err);\n          });\n      }\n    }\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n\n  if ((w && w.emitClose) || (r && r.emitClose)) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {\n    return;\n  }\n\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    return this;\n  }\n\n  if ((r && r.autoDestroy) || (w && w.autoDestroy))\n    stream.destroy(err);\n  else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      process.nextTick(emitConstructNT\x2C stream);\n    }\n  }\n\n  try {\n    const result = stream._construct(onConstruct);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            if (!called) {\n              process.nextTick(onConstruct\x2C null);\n            }\n          }\x2C\n          function(err) {\n            if (!called) {\n              process.nextTick(onConstruct\x2C err);\n            }\n          });\n      }\n    }\n  } catch (err) {\n    onConstruct(err);\n  }\n}\n\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\n\nfunction isRequest(stream) {\n  return stream && stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction emitCloseLegacy(stream) {\n  stream.emit('close');\n}\n\nfunction emitErrorCloseLegacy(stream\x2C err) {\n  stream.emit('error'\x2C err);\n  process.nextTick(emitCloseLegacy\x2C stream);\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err);\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy\x2C stream);\n  } else {\n    process.nextTick(emitCloseLegacy\x2C stream);\n  }\n\n  if (!stream.destroyed) {\n    stream[kDestroyed] = true;\n  }\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\n};\n
code-source-info,0x1bda378ed5ae,55,4823,5211,C0O4858C8O4891C9O4898C10O4923C15O4958C20O4977C24O4990C25O5004C29O5019C33O5032C34O5046C38O5069C45O5074C48O5069C54O5105C61O5119C64O5105C72O5131C77O5156C78O5163C79O5171C82O5179C90O5179C97O5210,,
code-creation,LazyCompile,10,246537,0x1bda378ee3c6,266,Writable node:internal/streams/writable:219:18,0x2b4a88f87e90,~
script-source,64,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\n} = require('internal/errors').codes;\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinished = Symbol('kOnFinished');\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream\x2C\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.writableObjectMode);\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // if _final has been called.\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // At the start of calling end()\n  this.ending = false;\n  // When end() has been called\x2C and returned.\n  this.ended = false;\n  // When 'finish' is emitted.\n  this.finished = false;\n\n  // Has it been destroyed\n  this.destroyed = false;\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  this.writecb = null;\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  this[kOnFinished] = [];\n}\n\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\n});\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes\x2C too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false\x2C as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor\x2C at least with V8 6.5.\n  const isDuplex = (this instanceof Stream.Duplex);\n\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    const state = this._writableState;\n\n    if (!state.writing) {\n      clearBuffer(this\x2C state);\n    }\n\n    finishMaybe(this\x2C state);\n  });\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== 'function')\n      cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark;\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state.sync = false;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null &&\n          state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\n    state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n\n  finishMaybe(stream\x2C state);\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk\x2C callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n  }\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));\n  }\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if (state.corked ||\n      state.bufferProcessing ||\n      state.destroyed ||\n      !state.constructed) {\n    return;\n  }\n\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = state.allBuffers;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && !state.writing);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true;\n    finishMaybe(this\x2C state\x2C true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb\x2C err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.constructed &&\n          state.length === 0 &&\n          !state.errored &&\n          state.buffered.length === 0 &&\n          !state.finished &&\n          !state.writing &&\n          !state.errorEmitted &&\n          !state.closeEmitted);\n}\n\nfunction callFinal(stream\x2C state) {\n  let called = false;\n\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream\x2C err\x2C state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++;\n      process.nextTick(finish\x2C stream\x2C state);\n    }\n  }\n\n  state.sync = true;\n  state.pendingcb++;\n\n  try {\n    const result = stream._final(onFinish);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            if (!called) {\n              process.nextTick(onFinish\x2C null);\n            }\n          }\x2C\n          function(err) {\n            if (!called) {\n              process.nextTick(onFinish\x2C err);\n            }\n          });\n      }\n    }\n  } catch (err) {\n    onFinish(err);\n  }\n\n  state.sync = false;\n}\n\nfunction prefinish(stream\x2C state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream\x2C state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0 && needFinish(state)) {\n      state.pendingcb++;\n      if (sync) {\n        process.nextTick(finish\x2C stream\x2C state);\n      } else {\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state.finished = true;\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n\n  stream.emit('finish');\n\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n\n  destroyed: {\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\n  }\x2C\n\n  writable: {\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\n        !w.ending && !w.ended;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\n  }\x2C\n\n  writableFinished: {\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\n  }\x2C\n\n  writableObjectMode: {\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\n  }\x2C\n\n  writableBuffer: {\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  }\x2C\n\n  writableEnded: {\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\n  }\x2C\n\n  writableNeedDrain: {\n    get() {\n      const wState = this._writableState;\n      if (!wState) return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\n  }\x2C\n\n  writableHighWaterMark: {\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\n  }\x2C\n\n  writableCorked: {\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\n  }\x2C\n\n  writableLength: {\n    get() {\n      return this._writableState && this._writableState.length;\n    }\n  }\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if (!state.destroyed &&\n    (state.bufferedIndex < state.buffered.length ||\n      state[kOnFinished].length)) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream\x2C options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream\x2C\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n
code-source-info,0x1bda378ee3c6,64,7399,8910,C0O7399C9O7973C16O7990C19O7997C23O7979C27O8009C33O8027C44O8027C51O8083C58O8090C63O8112C64O8116C83O8138C88O8136C92O8185C96O8223C104O8251C107O8273C111O8263C115O8304C123O8333C126O8356C130O8346C134O8388C142O8418C145O8442C149O8432C153O8475C161O8503C164O8525C168O8515C172O8556C180O8588C183O8614C187O8604C191O8642C197O8656C204O8679C212O8656C217O8701C224O8708C232O8708C238O8732C245O8744C258O8744C265O8909,,
tick,0x129c370,247742,0,0x0,3,0x1229670,0x1bda378e8552,0x1bda378e7f26,0x1bda378e724a,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0xd4eaf4,247764,0,0x0,2,0x123ee50,0x1bda378ee419,0x1bda378e8552,0x1bda378e7f26,0x1bda378e724a,0x1bda378e3caa,0x1bda378e2edf,0x1bda378e2cc7,0x1bda378e2bae,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,247855,0x1bda378f04be,341,WritableState node:internal/streams/writable:77:23,0x2b4a88f87d30,~
code-source-info,0x1bda378f04be,64,2472,6973,C0O2806C6O2845C8O2874C11O2881C15O2863C20O2989C25O3010C27O3029C33O3005C37O3045C41O3086C52O3109C54O3128C60O3079C64O3337C69O3358C73O3372C88O3372C97O3445C102O3445C106O3356C110O3512C111O3529C115O3564C116O3579C120O3625C121O3637C125O3695C126O3706C130O3748C131O3762C135O3801C136O3816C140O4015C144O4037C150O4051C156O4065C158O4087C159O4084C163O4295C168O4319C170O4338C178O4316C182O4516C183O4528C187O4592C188O4605C192O4682C193O4694C197O4958C198O4968C202O5171C203O5193C207O5259C210O5282C217O5282C223O5272C227O5382C228O5395C232O5467C233O5481C237O5596C238O5620C242O5631C245O5631C249O5758C250O5773C254O5963C255O5980C259O6118C260O6135C264O6222C265O6240C269O6311C271O6329C277O6348C283O6358C287O6326C291O6445C293O6465C299O6484C305O6496C309O6462C313O6719C314O6732C318O6802C319O6814C323O6918C324O6936C328O6948C330O6953C335O6966C340O6972,,
code-creation,LazyCompile,10,247918,0x1bda378f082e,13,getDefaultHighWaterMark node:internal/streams/state:15:33,0x39a167db9150,~
code-source-info,0x1bda378f082e,61,343,397,C0O360C12O395,,
code-creation,LazyCompile,10,247969,0x1bda378f097e,23,resetBuffer node:internal/streams/writable:202:21,0x2b4a88f87d80,~
code-source-info,0x1bda378f097e,64,6995,7107,C0O7007C2O7022C6O7030C7O7050C11O7057C12O7074C16O7084C17O7098C22O7106,,
code-creation,LazyCompile,10,248021,0x1bda378f0a7e,14,set node:net:1762:6,0x25349b1469d0,~
code-source-info,0x1bda378f0a7e,113,47382,47415,C0O47388C2O47400C7O47409C13O47413,,
code-creation,LazyCompile,10,248046,0x1bda378f0b6e,8,get node:net:1761:6,0x25349b146980,~
code-source-info,0x1bda378f0b6e,113,47347,47375,C0O47352C2O47364C4O47363C7O47373,,
code-creation,LazyCompile,10,248073,0x1bda378f0c56,32,getNewAsyncId node:net:162:23,0x25349b1449e0,~
code-source-info,0x1bda378f0c56,113,4141,4257,C0O4154C4O4187C14O4220C17O4220C22O4242C27O4242C31O4255,,
code-creation,LazyCompile,10,248145,0x1bda378f0e26,196,Readable.on node:internal/streams/readable:897:33,0x39a167db4718,~
code-source-info,0x1bda378f0e26,57,28293,29192,C0O28318C5O28325C10O28335C15O28338C29O28338C35O28379C40O28398C42O28405C47O28587C55O28587C62O28613C65O28580C69O28706C75O28714C80O28736C85O28736C91O28755C93O28762C98O28795C104O28816C110O28843C112O28888C118O28867C122O28902C123O28916C127O28931C128O28953C132O28968C140O28995C145O29009C150O28968C155O29035C161O29053C164O29053C170O29097C176O29116C179O29124C187O29124C193O29179C195O29190,,
code-creation,LazyCompile,10,248214,0x1bda378f109e,135,initSocketHandle node:net:260:26,0x25349b144b70,~
code-source-info,0x1bda378f109e,113,6480,7058,C0O6496C5O6496C9O6512C10O6527C14O6613C20O6633C27O6641C32O6655C36O6672C43O6689C45O6687C49O6707C51O6712C57O6750C62O6731C66O6729C70O6779C72O6784C74O6783C78O6798C80O6834C82O6839C84O6838C88O6858C90O6899C94O6917C99O6922C105O6955C106O6962C107O6971C109O6976C114O6985C118O7015C123O7023C128O7023C134O7057,,
code-creation,LazyCompile,10,248271,0x1bda378f12de,160,undestroy node:internal/streams/destroy:167:19,0x39a167da7460,~
code-source-info,0x1bda378f12de,55,3186,3858,C0O3208C5O3241C10O3260C14O3273C15O3287C19O3299C20O3308C24O3321C25O3336C29O3349C30O3361C34O3374C35O3384C39O3396C40O3411C44O3424C45O3434C49O3459C55O3468C58O3455C62O3500C68O3509C71O3496C75O3527C79O3540C80O3554C84O3566C85O3578C89O3591C90O3600C94O3613C95O3628C99O3641C100O3651C104O3663C105O3678C109O3691C110O3705C114O3718C115O3732C119O3757C125O3766C128O3753C132O3794C138O3803C141O3790C145O3833C151O3842C154O3829C159O3857,,
code-creation,LazyCompile,10,248477,0x1bda378f1e06,96,value node:internal/console/constructor:300:20,0x273b9799dd28,~
code-source-info,0x1bda378f1e06,37,9013,9495,C0O9042C2O9047C4O9046C8O9066C10O9076C15O9113C21O9148C29O9198C34O9198C41O9214C48O9258C53O9269C58O9269C64O9286C66O9321C72O9355C74O9370C78O9397C80O9412C81O9428C87O9443C93O9466C95O9489,,
code-creation,LazyCompile,10,248652,0x1bda378f253e,762,getColorDepth node:internal/tty:106:23,0x1bda378e6058,~
code-source-info,0x1bda378f253e,135,3180,6118,C0O3180C17O3195C27O3327C30O3335C36O3368C39O3380C81O3453C89O3453C93O3491C99O3508C100O3533C108O3533C112O3571C118O3589C119O3614C127O3614C131O3652C137O3670C138O3694C144O3710C145O3724C148O3732C157O3814C166O4044C173O4049C178O4067C184O4083C185O4091C190O4103C197O4112C202O4173C210O4230C218O4230C223O4218C228O4251C235O4284C242O4263C252O4261C260O4483C268O4497C271O4487C276O4501C281O4530C290O4540C293O4530C296O4551C300O4561C305O4579C311O4597C312O4604C316O4614C321O4632C327O4650C328O4662C334O4679C335O4687C338O4695C344O4707C350O4725C351O4733C354O4741C360O4751C365O4892C375O4892C385O4927C392O4935C397O4959C403O4977C404O4988C410O5004C411O5012C416O5035C421O5049C436O5113C441O5056C452O5139C460O5151C462O5160C463O5168C466O5180C501O5224C504O5233C514O5265C525O5301C530O5265C537O5341C543O5359C544O5374C550O5392C551O5441C557O5459C558O5493C564O5511C565O5519C568O5527C575O5537C583O5560C590O5570C595O5589C601O5607C602O5615C605O5623C618O5635C635O5677C640O5639C647O5692C653O5710C654O5738C666O5769C671O5738C675O5738C677O5781C686O5794C691O5813C700O5829C703O5839C704O5850C715O5873C723O5854C730O5974C736O5991C739O6051C742O6059C748O6076C754O6093C755O6100C761O6116,,
tick,0x114d2a6,248886,0,0x0,3,0x1229670,0x1bda378e2bd2,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,248935,0x1bda378f324e,49,formatWithOptions node:internal/util/inspect:2024:27,0x136fed71b8e0,~
script-source,20,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  MathTrunc\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  kPending\x2C\n  kRejected\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\x2C\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\x2C e)\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\x2C\n  numericSeparator: false\x2C\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    numericSeparator: ctx.numericSeparator\x2C\n    ...ctx.userOptions\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\x2C\n    numericSeparator: inspectDefaultOptions.numericSeparator\x2C\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n});\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nfunction escapeFn(str) {\n  const charCode = StringPrototypeCharCodeAt(str);\n  return meta.length > charCode ? meta[charCode] : `\\\\u${charCode.toString(16)}`;\n}\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\x2C str))\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str\x2C escapeReplace\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  for (let i = 0; i < str.length; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = StringPrototypeCharCodeAt(str\x2C i + 1);\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n      result += `${StringPrototypeSlice(str\x2C last\x2C i)}${`\\\\u${point.toString(16)}`}`;\n      last = i + 1;\n    }\n  }\n\n  if (last !== str.length) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C\n        context\x2C\n        depth\x2C\n        getUserOptions(ctx\x2C isCrossContext)\x2C\n        inspect\n      );\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null\x2C value) :\n        formatSet.bind(null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null\x2C value) :\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength\x2C false)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\n    const slice = stringified.slice(5\x2C -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = b.indexOf(a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return { len\x2C offset: i };\n        }\n      }\n    }\n  }\n\n  return { len: 0\x2C offset: 0 };\n}\n\nfunction getStackString(error) {\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\n}\n\nfunction getStackFrames(ctx\x2C err\x2C stack) {\n  const frames = stack.split('\\n');\n\n  // Remove stack frames identical to frames in cause.\n  if (err.cause && isError(err.cause)) {\n    const causeStack = getStackString(err.cause);\n    const causeStackStart = causeStack.indexOf('\\n    at');\n    if (causeStackStart !== -1) {\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\n');\n      const { len\x2C offset } = identicalSequenceRange(frames\x2C causeFrames);\n      if (len > 0) {\n        const skipped = len - 2;\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\n        frames.splice(offset + 1\x2C skipped\x2C ctx.stylize(msg\x2C 'undefined'));\n      }\n    }\n  }\n  return frames;\n}\n\nfunction improveStack(stack\x2C constructor\x2C name\x2C tag) {\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  let len = name.length;\n\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  return stack;\n}\n\nfunction removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack) {\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index\x2C 1);\n      }\n    }\n  }\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let stack = getStackString(err);\n\n  removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack);\n\n  if ('cause' in err &&\n      (keys.length === 0 || !keys.includes('cause'))) {\n    keys.push('cause');\n  }\n\n  stack = improveStack(stack\x2C constructor\x2C name\x2C tag);\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else {\n    let newStack = stack.slice(0\x2C stackStart);\n    const lines = getStackFrames(ctx\x2C err\x2C stack.slice(stackStart + 1));\n    if (ctx.colors) {\n      // Highlight userland code and node modules.\n      for (const line of lines) {\n        const core = line.match(coreModuleRegExp);\n        if (core !== null && NativeModule.exists(core[1])) {\n          newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n        } else {\n          // This adds underscores to all node_modules to quickly identify them.\n          let nodeModule;\n          newStack += '\\n';\n          let pos = 0;\n          while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\n            // '/node_modules/'.length === 14\n            newStack += line.slice(pos\x2C nodeModule.index + 14);\n            newStack += ctx.stylize(nodeModule[1]\x2C 'module');\n            pos = nodeModule.index + nodeModule[0].length;\n          }\n          newStack += pos === 0 ? line : line.slice(pos);\n        }\n      }\n    } else {\n      newStack += `\\n${lines.join('\\n')}`;\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction addNumericSeparator(integerString) {\n  let result = '';\n  let i = integerString.length;\n  const start = integerString.startsWith('-') ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    result = `_${integerString.slice(i - 3\x2C i)}${result}`;\n  }\n  return i === integerString.length ?\n    integerString :\n    `${integerString.slice(0\x2C i)}${result}`;\n}\n\nfunction addNumericSeparatorEnd(integerString) {\n  let result = '';\n  let i = 0;\n  for (; i < integerString.length - 3; i += 3) {\n    result += `${integerString.slice(i\x2C i + 3)}_`;\n  }\n  return i === 0 ?\n    integerString :\n    `${result}${integerString.slice(i)}`;\n}\n\nfunction formatNumber(fn\x2C number\x2C numericSeparator) {\n  if (!numericSeparator) {\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\n    if (ObjectIs(number\x2C -0)) {\n      return fn('-0'\x2C 'number');\n    }\n    return fn(`${number}`\x2C 'number');\n  }\n  const integer = MathTrunc(number);\n  const string = String(integer);\n  if (integer === number) {\n    if (!NumberIsFinite(number) || string.includes('e')) {\n      return fn(string\x2C 'number');\n    }\n    return fn(`${addNumericSeparator(string)}`\x2C 'number');\n  }\n  if (NumberIsNaN(number)) {\n    return fn(string\x2C 'number');\n  }\n  return fn(`${\n    addNumericSeparator(string)\n  }.${\n    addNumericSeparatorEnd(String(number).slice(string.length + 1))\n  }`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C bigint\x2C numericSeparator) {\n  const string = String(bigint);\n  if (!numericSeparator) {\n    return fn(`${string}n`\x2C 'bigint');\n  }\n  return fn(`${addNumericSeparator(string)}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line)\x2C 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    /(.{2})/g\x2C '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]\x2C ctx.numericSeparator);\n  }\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    output.push(\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = StringPrototypeReplace(\n      SymbolPrototypeToString(key)\x2C\n      strEscapeSequencesReplacer\x2C escapeFn\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key\x2C\n                                       strEscapeSequencesReplacer\x2C escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp\x2C key)) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          const joinedOutput = join(output\x2C '\x2C ');\n          if (!joinedOutput.includes('\\n')) {\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\n              ` ${braces[1]}`;\n          }\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (circularError) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions'\x2C 'object'\x2C inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatNumberNoColor(number\x2C options) {\n  return formatNumber(\n    stylizeNoColor\x2C\n    number\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatBigIntNoColor(bigint\x2C options) {\n  return formatBigInt(\n    stylizeNoColor\x2C\n    bigint\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: { // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumberNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = formatBigIntNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\n                });\n              }\n              break;\n            }\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: { // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = formatBigIntNoColor(tempNum\x2C inspectOptions);\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(Number(tempNum)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\n              });\n              break;\n            case 105: { // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = formatBigIntNoColor(tempInteger\x2C inspectOptions);\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseInt(tempInteger)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 102: { // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseFloat(tempFloat)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return str.replace(ansi\x2C '');\n}\n\nmodule.exports = {\n  inspect\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  inspectDefaultOptions\x2C\n  stripVTControlCharacters\n};\n
code-source-info,0x1bda378f324e,20,67958,68207,C0O67958C8O67988C18O68061C34O68067C39O68061C40O68150C43O68157C48O68205,,
tick,0x7f0810fb2f35,252580,0,0x0,3,0x1229670,0x1bda378e2bd2,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x7f0810b84473,252591,0,0x0,3,0x1229670,0x1bda378e2bd2,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
tick,0x7f0810b84314,252598,0,0x0,3,0x1229670,0x1bda378e2bd2,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,252735,0x1bda378f7c8e,793,formatWithOptionsInternal node:internal/util/inspect:2048:35,0x136fed71b9f8,~
code-source-info,0x1bda378f7c8e,20,68609,72597,C0O68650C1O68654C5O68669C7O68684C10O68701C13O68708C19O68754C26O68761C31O68776C33O68789C34O68804C36O68831C38O68852C40O68865C44O68872C47O68857C52O68890C57O68894C65O68930C70O68972C77O68998C80O68972C86O69019C88O69025C92O69038C96O69029C101O69058C169O69139C174O69143C178O69164C182O69215C185O69225C193O69292C199O69343C202O69353C210O69420C223O69526C229O69573C234O69583C241O69639C244O69689C256O69732C266O69761C276O69793C281O69649C287O69845C289O69909C294O69932C297O69936C301O69919C306O69958C308O70026C313O70030C317O70051C321O70102C324O70112C332O70179C338O70230C343O70286C348O70316C351O70316C356O70296C362O70380C364O70443C369O70461C372O70465C376O70453C382O70503C384O70553C389O70571C392O70575C396O70603C407O70647C417O70680C428O70709C433O70563C439O70743C441O70815C446O70819C450O70840C454O70895C457O70905C465O70976C471O71031C476O71087C481O71136C484O71136C489O71097C495O71212C497O71296C502O71300C506O71321C510O71374C515O71430C520O71479C523O71479C528O71440C534O71555C536O71618C542O71640C545O71668C547O71717C549O71724C561O71724C573O71779C575O71791C579O71810C581O71907C583O71939C585O71957C588O71951C593O71976C595O71983C600O72022C611O71983C623O72050C625O72057C632O72076C634O72088C640O72108C642O72121C647O72141C649O72148C661O72148C673O72199C675O72211C679O68878C684O68839C690O72244C691O72256C696O72271C701O72282C704O72320C708O72312C713O72338C715O72345C718O72345C730O72420C734O72413C739O72448C741O72452C745O72461C747O72468C754O72478C766O72513C775O72546C779O72557C782O72573C787O72404C790O72584C792O72595,,
code-creation,LazyCompile,10,252872,0x1bda378f84de,395,inspect node:internal/util/inspect:292:17,0x136fed71a640,~
code-source-info,0x1bda378f84de,20,8503,10513,C0O8503C2O8554C9O8643C15O8675C18O8697C28O8720C31O8742C41O8761C44O8783C54O8810C57O8832C67O8862C70O8884C80O8915C83O8937C93O8974C96O8996C106O9030C109O9052C119O9078C122O9100C132O9121C135O9143C145O9164C148O9186C158O9217C161O9239C172O9278C179O9285C184O9327C191O9334C196O9347C198O9360C203O9389C205O9410C208O9399C212O9443C219O9450C226O9466C231O9495C233O9517C236O9506C240O9574C246O9613C248O9628C254O9647C258O9681C263O9681C268O9718C270O9733C274O9723C279O9768C281O9775C285O9969C292O10014C295O9984C304O10059C309O10086C311O10101C314O10095C320O10131C326O10239C328O10255C332O9743C337O9705C340O10301C346O10309C348O10321C352O10351C358O10397C361O10395C365O10417C371O10465C374O10463C378O10477C389O10484C394O10511,,
code-creation,LazyCompile,10,253035,0x1bda378f89d6,463,formatValue node:internal/util/inspect:745:21,0x136fed71ac60,~
code-source-info,0x1bda378f89d6,20,22499,25092,C0O22587C14O22664C17O22664C23O22699C26O22726C37O22706C42O22747C43O22754C47O22791C58O22791C64O22815C65O22899C68O23027C73O23056C80O23027C86O23070C88O23109C94O23128C106O23135C111O23173C112O23184C117O23339C123O23380C125O23386C127O23385C131O23412C137O23545C142O23651C148O23672C153O23684C160O23694C165O23840C174O23868C181O23874C185O23927C188O23933C193O23971C195O23960C200O23998C208O24082C226O23998C232O24251C234O24259C239O24282C245O24323C257O24330C262O24366C263O24396C279O24420C284O24431C289O24420C299O24396C305O24450C306O24636C311O24641C316O24641C323O24676C326O24691C332O24723C334O24742C337O24738C342O24736C346O24763C351O24772C356O24772C364O24822C369O24831C374O24831C380O24849C382O24896C387O24905C391O24910C395O24927C400O24936C405O24936C411O24984C421O25006C435O24984C441O25027C442O25035C457O25042C462O25090,,
code-creation,LazyCompile,10,253081,0x1bda378f8d4e,11,isUndetectableObject node:internal/util/inspect:158:30,0x136fed718428,~
code-source-info,0x1bda378f8d4e,20,3116,3166,C0O3148C9O3153C10O3166,,
code-creation,LazyCompile,10,253167,0x1bda378f8fde,380,formatPrimitive node:internal/util/inspect:1519:25,0x136fed71b200,~
code-source-info,0x1bda378f8fde,20,49936,51139,C0O49936C9O49957C15O50008C18O50026C23O50039C27O50033C32O50088C37O50101C41O50095C45O50138C52O50151C57O50138C65O50175C70O50192C83O50229C99O50265C105O50273C110O50400C119O50409C121O50407C126O50441C131O50454C136O50472C140O50466C143O50487C146O50448C151O50522C161O50522C167O50547C177O50548C183O50601C194O50618C199O50629C203O50644C207O50618C217O50602C225O50652C228O50662C229O50673C237O50683C245O50680C253O50711C256O50721C257O50728C263O50763C271O50798C279O50770C284O50816C285O50819C291O50854C299O50889C307O50861C312O50907C313O50910C319O50946C324O50959C329O50953C334O50979C335O50982C341O51020C350O51027C355O51056C356O51085C363O51095C366O51095C374O51092C379O51137,,
code-creation,LazyCompile,10,253239,0x1bda378f93a6,209,formatNumber node:internal/util/inspect:1485:22,0x136fed71b160,~
code-source-info,0x1bda378f93a6,20,48970,49692,C0O49005C4O49114C12O49118C19O49148C25O49155C30O49174C31O49185C33O49198C38O49192C43O49218C44O49241C49O49241C54O49277C59O49277C64O49296C66O49308C71O49326C76O49331C82O49364C90O49364C97O49387C100O49394C105O49415C106O49426C109O49439C118O49433C123O49480C124O49487C129O49491C135O49518C138O49525C143O49546C144O49553C147O49571C164O49633C167O49633C172O49647C177O49661C181O49668C185O49648C191O49610C203O49560C208O49690,,
tick,0xd62054,253319,0,0x0,2,0x1229670,0x1bda378f93cc,0x1bda378f90f5,0x1bda378f89fb,0x1bda378f8663,0x1bda378f7f8c,0x1bda378f3279,0x1bda378e2bd2,0x1bda378e2a86,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,253345,0x1bda378f963e,82,stylizeWithColor node:internal/util/inspect:540:26,0x136fed71a940,~
code-source-info,0x1bda378f963e,20,16346,16587,C0O16381C3O16389C10O16395C14O16410C16O16455C19O16463C26O16469C30O16482C32O16513C36O16535C52O16542C65O16560C78O16567C79O16574C81O16585,,
code-creation,LazyCompile,10,253422,0x1bda378f9916,269,value node:internal/console/constructor:258:20,0x273b9799dca0,~
code-source-info,0x1bda378f9916,37,7494,8932,C0O7551C5O7592C7O7597C9O7596C13O7637C15O7654C17O7650C21O7687C23O7704C29O7719C34O7755C38O7780C44O7807C49O7851C55O7858C60O7875C68O7879C75O7930C80O7962C90O7982C98O7939C105O8016C107O8037C112O8061C122O8084C123O8101C128O8126C133O8126C138O8140C145O8457C153O8457C160O8480C165O8504C176O8504C182O8541C187O8541C206O8737C216O8741C222O8776C224O8776C238O8881C239O8888C250O8888C268O8931,,
code-creation,LazyCompile,10,253477,0x1bda378f9ba6,31,listenerCount node:events:854:23,0x136fed727170,~
code-source-info,0x1bda378f9ba6,23,24662,24930,C0O24693C5O24705C7O24756C9O24762C13O24775C17O24821C19O24830C20O24842C24O24898C28O24905C29O24919C30O24928,,
code-creation,LazyCompile,10,253508,0x1bda378f9cb6,39,once node:events:660:44,0x136fed726e00,~
code-source-info,0x1bda378f9cb6,23,19413,19526,C0O19434C3O19434C7O19467C24O19476C30O19467C36O19512C38O19524,,
code-creation,LazyCompile,10,253544,0x1bda378f9e7e,60,_onceWrap node:events:646:19,0x136fed726db0,~
code-source-info,0x1bda378f9e7e,23,18986,19209,C0O19029C6O19053C12O19064C18O19072C24O19078C31O19108C34O19120C39O19120C45O19135C47O19152C51O19166C53O19179C57O19192C59O19207,,
code-creation,LazyCompile,10,253596,0x1bda378fa0c6,26,Writable.write node:internal/streams/writable:334:36,0x2b4a88f88040,~
code-source-info,0x1bda378fa0c6,64,10730,10808,C0O10756C15O10763C22O10797C25O10806,,
code-creation,LazyCompile,10,253677,0x1bda378fa2ae,338,_write node:internal/streams/writable:284:16,0x2b4a88f87ff0,~
code-source-info,0x1bda378fa2ae,64,9364,10693,C0O9419C5O9438C11O9480C14O9516C22O9548C26O9586C34O9612C36O9625C43O9642C46O9649C51O9649C58O9677C65O9683C70O9677C71O9723C77O9759C81O9776C85O9802C90O9808C95O9802C96O9858C102O9876C108O9925C114O9939C119O9960C124O9975C129O9975C137O10006C143O10046C145O10067C147O10056C152O10083C158O10115C163O10126C168O10126C175O10156C180O10171C185O10171C192O10205C198O10245C216O10251C221O10245C222O10355C224O10372C230O10386C235O10392C243O10445C249O10462C259O10468C265O10510C269O10525C272O10533C277O10533C283O10556C296O10556C301O10595C303O10606C304O10613C310O10628C314O10634C332O10641C337O10691,,
code-creation,LazyCompile,10,253759,0x1bda378fa676,217,writeOrBuffer node:internal/streams/writable:366:23,0x2b4a88f88250,~
code-source-info,0x1bda378fa676,64,11649,12640,C0O11714C10O11737C15O11748C22O11764C25O11761C29O11829C34O11844C38O11836C42O11933C44O11947C45O11963C49O11984C55O12001C61O12017C67O12035C73O12060C78O12069C90O12076C96O12083C102O12093C106O12069C111O12120C119O12143C124O12165C125O12182C129O12211C137O12231C142O12248C143O12262C149O12292C151O12307C155O12318C157O12332C161O12348C162O12362C166O12374C167O12385C171O12404C176O12434C190O12404C195O12448C196O12459C200O12589C204O12610C211O12628C216O12638,,
code-creation,LazyCompile,10,253805,0x1bda378fa8ae,26,Socket._write node:net:834:35,0x25349b1461f8,~
code-source-info,0x1bda378fa8ae,113,21507,21580,C0O21537C19O21537C25O21579,,
code-creation,LazyCompile,10,253859,0x1bda378faaae,186,Socket._writeGeneric node:net:797:42,0x25349b1460b8,~
code-source-info,0x1bda378faaae,113,20617,21370,C0O20617C21O20819C27O20837C29O20855C33O20867C35O20889C39O20910C52O20910C58O21013C59O21020C60O21027C61O21045C65O21055C67O21077C71O21096C77O21111C84O21118C87O21114C93O21111C97O21144C98O21157C99O21170C104O21170C108O21192C110O21199C114O21215C130O21221C138O21263C157O21269C163O21319C169O21330C173O21335C176O21362C180O21356C185O21369,,
code-creation,LazyCompile,10,253906,0x1bda378fad16,45,_unrefTimer node:net:437:52,0x25349b1453e0,~
code-source-info,0x1bda378fad16,113,11977,12087,C0O11997C5O12005C9O12036C11O12042C13O12041C18O12059C20O12061C22O12060C26O12071C31O12071C35O12021C40O11984C44O12086,,
code-creation,LazyCompile,10,253958,0x1bda378fae36,55,writeGeneric node:internal/stream_base_commons:147:22,0x2989f358bf90,~
script-source,88,node:internal/stream_base_commons,'use strict';\n\nconst {\n  Array\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { FastBuffer } = require('internal/buffer');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kBytesWritten\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { UV_EOF } = internalBinding('uv');\nconst {\n  errnoException\n} = require('internal/errors');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst {\n  kTimeout\x2C\n  setUnrefTimeout\x2C\n  getTimerDuration\n} = require('internal/timers');\nconst { isUint8Array } = require('internal/util/types');\nconst { clearTimeout } = require('timers');\nconst { validateCallback } = require('internal/validators');\n\nconst kMaybeDestroy = Symbol('kMaybeDestroy');\nconst kUpdateTimer = Symbol('kUpdateTimer');\nconst kAfterAsyncWrite = Symbol('kAfterAsyncWrite');\nconst kHandle = Symbol('kHandle');\nconst kSession = Symbol('kSession');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst kBuffer = Symbol('kBuffer');\nconst kBufferGen = Symbol('kBufferGen');\nconst kBufferCb = Symbol('kBufferCb');\n\nfunction handleWriteReq(req\x2C data\x2C encoding) {\n  const { handle } = req;\n\n  switch (encoding) {\n    case 'buffer':\n    {\n      const ret = handle.writeBuffer(req\x2C data);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = data;\n      return ret;\n    }\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req\x2C data);\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req\x2C data);\n    case 'ascii':\n      return handle.writeAsciiString(req\x2C data);\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req\x2C data);\n    default:\n    {\n      const buffer = Buffer.from(data\x2C encoding);\n      const ret = handle.writeBuffer(req\x2C buffer);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = buffer;\n      return ret;\n    }\n  }\n}\n\nfunction onWriteComplete(status) {\n  debug('onWriteComplete'\x2C status\x2C this.error);\n\n  const stream = this.handle[owner_symbol];\n\n  if (stream.destroyed) {\n    if (typeof this.callback === 'function')\n      this.callback(null);\n    return;\n  }\n\n  // TODO (ronag): This should be moved before if(stream.destroyed)\n  // in order to avoid swallowing error.\n  if (status < 0) {\n    const ex = errnoException(status\x2C 'write'\x2C this.error);\n    if (typeof this.callback === 'function')\n      this.callback(ex);\n    else\n      stream.destroy(ex);\n    return;\n  }\n\n  stream[kUpdateTimer]();\n  stream[kAfterAsyncWrite](this);\n\n  if (typeof this.callback === 'function')\n    this.callback(null);\n}\n\nfunction createWriteWrap(handle\x2C callback) {\n  const req = new WriteWrap();\n\n  req.handle = handle;\n  req.oncomplete = onWriteComplete;\n  req.async = false;\n  req.bytes = 0;\n  req.buffer = null;\n  req.callback = callback;\n\n  return req;\n}\n\nfunction writevGeneric(self\x2C data\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const allBuffers = data.allBuffers;\n  let chunks;\n  if (allBuffers) {\n    chunks = data;\n    for (let i = 0; i < data.length; i++)\n      data[i] = data[i].chunk;\n  } else {\n    chunks = new Array(data.length << 1);\n    for (let i = 0; i < data.length; i++) {\n      const entry = data[i];\n      chunks[i * 2] = entry.chunk;\n      chunks[i * 2 + 1] = entry.encoding;\n    }\n  }\n  const err = req.handle.writev(req\x2C chunks\x2C allBuffers);\n\n  // Retain chunks\n  if (err === 0) req._chunks = chunks;\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction writeGeneric(self\x2C data\x2C encoding\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const err = handleWriteReq(req\x2C data\x2C encoding);\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction afterWriteDispatched(req\x2C err\x2C cb) {\n  req.bytes = streamBaseState[kBytesWritten];\n  req.async = !!streamBaseState[kLastWriteWasAsync];\n\n  if (err !== 0)\n    return cb(errnoException(err\x2C 'write'\x2C req.error));\n\n  if (!req.async && typeof req.callback === 'function') {\n    req.callback();\n  }\n}\n\nfunction onStreamRead(arrayBuffer) {\n  const nread = streamBaseState[kReadBytesOrError];\n\n  const handle = this;\n  const stream = this[owner_symbol];\n\n  stream[kUpdateTimer]();\n\n  if (nread > 0 && !stream.destroyed) {\n    let ret;\n    let result;\n    const userBuf = stream[kBuffer];\n    if (userBuf) {\n      result = (stream[kBufferCb](nread\x2C userBuf) !== false);\n      const bufGen = stream[kBufferGen];\n      if (bufGen !== null) {\n        const nextBuf = bufGen();\n        if (isUint8Array(nextBuf))\n          stream[kBuffer] = ret = nextBuf;\n      }\n    } else {\n      const offset = streamBaseState[kArrayBufferOffset];\n      const buf = new FastBuffer(arrayBuffer\x2C offset\x2C nread);\n      result = stream.push(buf);\n    }\n    if (!result) {\n      handle.reading = false;\n      if (!stream.destroyed) {\n        const err = handle.readStop();\n        if (err)\n          stream.destroy(errnoException(err\x2C 'read'));\n      }\n    }\n\n    return ret;\n  }\n\n  if (nread === 0) {\n    return;\n  }\n\n  // After seeing EOF\x2C most streams will be closed permanently\x2C\n  // and will not deliver any more read events after this point.\n  // (equivalently\x2C it should have called readStop on itself already).\n  // Some streams may be reset and explicitly started again with a call\n  // to readStart\x2C such as TTY.\n\n  if (nread !== UV_EOF) {\n    // CallJSOnreadMethod expects the return value to be a buffer.\n    // Ref: https://github.com/nodejs/node/pull/34375\n    stream.destroy(errnoException(nread\x2C 'read'));\n    return;\n  }\n\n  // Defer this until we actually emit end\n  if (stream._readableState.endEmitted) {\n    if (stream[kMaybeDestroy])\n      stream[kMaybeDestroy]();\n  } else {\n    if (stream[kMaybeDestroy])\n      stream.on('end'\x2C stream[kMaybeDestroy]);\n\n    // Push a null to signal the end of data.\n    // Do it before `maybeDestroy` for correct order of events:\n    // `end` -> `close`\n    stream.push(null);\n    stream.read(0);\n  }\n}\n\nfunction setStreamTimeout(msecs\x2C callback) {\n  if (this.destroyed)\n    return this;\n\n  this.timeout = msecs;\n\n  // Type checking identical to timers.enroll()\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n\n  // Attempt to clear an existing timer in both cases -\n  //  even if it will be rescheduled we don't want to leak an existing timer.\n  clearTimeout(this[kTimeout]);\n\n  if (msecs === 0) {\n    if (callback !== undefined) {\n      validateCallback(callback);\n      this.removeListener('timeout'\x2C callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this)\x2C msecs);\n    if (this[kSession]) this[kSession][kUpdateTimer]();\n\n    if (callback !== undefined) {\n      validateCallback(callback);\n      this.once('timeout'\x2C callback);\n    }\n  }\n  return this;\n}\n\nmodule.exports = {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kMaybeDestroy\x2C\n  kUpdateTimer\x2C\n  kHandle\x2C\n  kSession\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n};\n
code-source-info,0x1bda378fae36,88,3597,3781,C0O3640C5O3661C7O3660C11O3640C17O3690C29O3690C35O3730C47O3730C52O3768C54O3779,,
code-creation,LazyCompile,10,254306,0x1bda378fb85e,47,createWriteWrap node:internal/stream_base_commons:109:25,0x2989f358bed0,~
code-source-info,0x1bda378fb85e,88,2719,2933,C0O2754C5O2754C11O2774C13O2785C17O2797C19O2812C23O2833C24O2843C28O2854C29O2864C33O2871C34O2882C38O2892C40O2905C44O2920C46O2931,,
tick,0xfcad2d,254423,0,0x0,3,0x1229670,0x1bda378fae53,0x1bda378fab4b,0x1bda378fa8c1,0x1bda378fa734,0x1bda378fa3fa,0x1bda378fa0d5,0x1bda378f99d1,0x1bda378e2a8c,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,254445,0x1bda378fba66,215,handleWriteReq node:internal/stream_base_commons:45:24,0x2989f358be30,~
code-source-info,0x1bda378fba66,88,1174,2006,C0O1208C5O1227C80O1297C85O1297C92O1327C99O1347C101O1346C106O1376C108O1387C112O1401C114O1412C115O1477C120O1477C126O1506C127O1562C132O1562C138O1589C139O1628C144O1628C150O1656C151O1753C156O1753C162O1780C163O1821C168O1828C173O1828C180O1875C185O1875C192O1907C199O1927C201O1926C206O1956C208O1967C212O1983C214O1994,,
code-creation,LazyCompile,10,254538,0x1bda378fbcae,92,afterWriteDispatched node:internal/stream_base_commons:155:30,0x2989f358c000,~
code-source-info,0x1bda378fbcae,88,3812,4086,C0O3831C2O3843C7O3859C9O3858C12O3841C16O3877C18O3891C23O3907C25O3906C30O3887C34O3931C35O3939C40O3950C42O3960C48O3993C56O3960C62O3957C66O4001C67O4014C73O4034C81O4069C86O4069C91O4085,,
code-creation,LazyCompile,10,254674,0x1bda378fbf06,323,onwrite node:internal/streams/writable:426:17,0x2b4a88f88340,~
code-source-info,0x1bda378fbf06,64,13425,15048,C0O13463C5O13500C10O13525C15O13537C19O13573C26O13600C29O13596C35O13573C40O13630C41O13637C42O13645C43O13659C47O13670C48O13684C52O13694C57O13716C64O13707C68O13728C69O13743C73O13751C77O13855C81O13923C87O13940C89O13954C93O14072C99O14098C104O14113C110O14137C117O14160C121O14177C125O14195C128O14203C148O14203C155O14269C170O14269C177O14337C182O14346C187O14361C191O14353C196O14384C199O14384C204O14423C208O14704C214O14751C219O14770C226O14773C231O14797C242O14821C248O14848C255O14887C261O14891C267O14899C273O14873C277O14916C280O14924C288O14955C293O14924C301O15003C316O15003C322O15047,,
code-creation,LazyCompile,10,254788,0x1bda378fc7a6,368,nextTick node:internal/process/task_queues:104:18,0x273b9798f670,~
script-source,32,node:internal/process/task_queues,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land\x2C\n  // and to avoid unnecessary calls into JS land.\n  tickInfo\x2C\n  // Used to run V8's micro task queue.\n  runMicrotasks\x2C\n  setTickCallback\x2C\n  enqueueMicrotask\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn\x2C\n  hasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n  symbols: { async_id_symbol\x2C trigger_async_id_symbol }\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateCallback\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId\x2C tock[trigger_async_id_symbol]\x2C tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0]\x2C args[1]); break;\n            case 3: callback(args[0]\x2C args[1]\x2C args[2]); break;\n            case 4: callback(args[0]\x2C args[1]\x2C args[2]\x2C args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateCallback(callback);\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1]\x2C arguments[2]]; break;\n    case 4: args = [arguments[1]\x2C arguments[2]\x2C arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId\x2C\n    [trigger_async_id_symbol]: triggerAsyncId\x2C\n    callback\x2C\n    args\n  };\n  if (initHooksExist())\n    emitInit(asyncId\x2C 'TickObject'\x2C triggerAsyncId\x2C tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask'\x2C\n    defaultMicrotaskResourceOpts\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask\x2C asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick\x2C\n      runNextTicks\n    };\n  }\x2C\n  queueMicrotask\n};\n
code-source-info,0x1bda378fc7a6,32,2602,3446,C0O2602C2O2617C7O2617C11O2648C14O2660C20O2674C21O2681C22O2689C24O2715C59O2737C61O2756C70O2773C82O2779C84O2798C93O2815C105O2829C117O2835C119O2854C128O2871C140O2885C152O2899C164O2905C166O2931C171O2958C175O2965C181O2938C187O2990C190O3007C194O2995C199O3028C201O3035C207O3051C210O3040C214O3016C219O2977C222O3063C227O3073C232O3073C238O3088C243O3088C247O3133C252O3133C256O3172C261O3172C265O3221C272O3228C278O3246C285O3260C291O3286C301O3306C311O3320C319O3332C324O3336C329O3358C346O3358C351O3421C356O3427C361O3427C367O3445,,
code-creation,LazyCompile,10,255032,0x1bda378fd016,21, node:internal/validators:222:42,0x2842ea0bc460,~
code-source-info,0x1bda378fd016,15,6803,6904,C0O6821C6O6861C13O6867C18O6861C20O6903,,
code-creation,LazyCompile,10,255066,0x1bda378fd116,15,isEmpty node:internal/fixed_queue:95:10,0x273b979946d0,~
script-source,34,node:internal/fixed_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// Currently optimal queue size\x2C tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or\x2C if there is only one circular buffer\x2C it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one\x2C removing means\n// moving `bottom` forward by one. After reaching the end\x2C the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue\x2C sets the old queue's `.next` to it\x2C\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue\x2C it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n
code-source-info,0x1bda378fd116,34,3637,3677,C0O3658C5O3663C10O3663C14O3673,,
code-creation,LazyCompile,10,255270,0x1bda378fd5ce,13,isEmpty node:internal/fixed_queue:67:10,0x273b97994460,~
code-source-info,0x1bda378fd5ce,34,3084,3129,C0O3105C5O3118C9O3109C12O3125,,
code-creation,LazyCompile,10,255294,0x1bda378fd6be,25,setHasTickScheduled node:internal/process/task_queues:52:29,0x273b9798f580,~
code-source-info,0x1bda378fd6be,32,1104,1162,C0O1116C7O1125C12O1146C19O1144C24O1161,,
code-creation,LazyCompile,10,255354,0x1bda378fd7b6,23,newAsyncId node:internal/async_hooks:415:20,0x2842ea0b7bc0,~
script-source,13,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst promiseHooks = require('internal/promise_hooks');\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  registerDestroyHook(promise\x2C asyncId);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook\x2C\n    before: promiseBeforeHook\x2C\n    after: promiseAfterHook\x2C\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n *\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\n  }\x2C\n  asyncWrap: {\n    Providers: async_wrap.Providers\x2C\n  }\n};\n
code-source-info,0x1bda378fd7b6,13,14452,14503,C0O14459C7O14484C16O14499C22O14501,,
tick,0x7f0810b84473,256302,0,0x0,3,0x1229670,0x1bda378fc8a2,0x1bda378fc02b,0x1bda378fbd04,0x1bda378fae65,0x1bda378fab4b,0x1bda378fa8c1,0x1bda378fa734,0x1bda378fa3fa,0x1bda378fa0d5,0x1bda378f99d1,0x1bda378e2a8c,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,256328,0x1bda378fec86,35,getDefaultTriggerAsyncId node:internal/async_hooks:431:34,0x2842ea0b7c60,~
code-source-info,0x1bda378fec86,13,14911,15168,C0O14948C7O14964C9O14963C13O15057C14O15083C19O15092C26O15115C28O15114C31O15134C32O15137C34O15166,,
code-creation,LazyCompile,10,256379,0x1bda378fed96,13,initHooksExist node:internal/async_hooks:477:24,0x2842ea0b7e50,~
code-source-info,0x1bda378fed96,13,16132,16164,C0O16139C5O16155C8O16146C12O16162,,
code-creation,LazyCompile,10,256416,0x1bda378fee7e,16,hasHooks node:internal/async_hooks:469:18,0x2842ea0b7db0,~
code-source-info,0x1bda378fee7e,13,16000,16046,C0O16010C7O16034C12O16040C15O16044,,
code-creation,LazyCompile,10,256486,0x1bda378fef8e,59,push node:internal/fixed_queue:99:7,0x273b97994720,~
code-source-info,0x1bda378fef8e,34,3685,3945,C0O3707C5O3712C10O3712C16O3871C23O3887C26O3883C32O3881C38O3864C42O3925C47O3930C52O3930C58O3944,,
code-creation,LazyCompile,10,256514,0x1bda378ff0d6,24,isFull node:internal/fixed_queue:71:9,0x273b979944b0,~
code-source-info,0x1bda378ff0d6,34,3139,3200,C0O3162C4O3166C10O3173C12O3171C16O3189C20O3180C23O3196,,
code-creation,LazyCompile,10,256541,0x1bda378ff1e6,37,push node:internal/fixed_queue:75:7,0x273b97994518,~
code-source-info,0x1bda378ff1e6,34,3208,3291,C0O3226C5O3236C12O3241C16O3270C20O3274C26O3281C28O3279C31O3262C36O3290,,
tick,0x7f0810c0f0af,256572,0,0x0,3,0x1229670,0x1bda378fefc2,0x1bda378fc90f,0x1bda378fc02b,0x1bda378fbd04,0x1bda378fae65,0x1bda378fab4b,0x1bda378fa8c1,0x1bda378fa734,0x1bda378fa3fa,0x1bda378fa0d5,0x1bda378f99d1,0x1bda378e2a8c,0xc4d220,0x7f07fc04747f,0x3b5adb5b31e1,0x3b5adb5af563,0x3b5adb5ae766,0x3b5adb5ab817,0x3b5adb59c93f,0x109acf085b21
code-creation,LazyCompile,10,256620,0x1bda378ff31e,62,Readable.removeListener node:internal/streams/readable:927:45,0x39a167db4788,~
code-source-info,0x1bda378ff31e,57,29295,29852,C0O29320C5O29327C10O29337C15O29352C29O29352C35O29426C37O29433C42O29783C45O29791C53O29791C59O29839C61O29850,,
code-creation,LazyCompile,10,256707,0x1bda378ff49e,307,removeListener node:events:689:28,0x136fed726ec8,~
code-source-info,0x1bda378ff49e,23,20159,21430,C0O20184C3O20184C7O20236C12O20251C14O20285C16O20297C17O20318C19O20324C23O20338C25O20370C27O20382C28O20390C30O20399C35O20420C42O20429C47O20453C54O20464C59O20477C64O20494C66O20509C71O20509C75O20507C81O20554C83O20568C85O20596C91O20629C99O20663C114O20629C121O20709C127O20766C130O20797C134O20804C138O20811C139O20811C144O20834C146O20842C152O20846C159O20866C163O20870C170O20879C175O20907C180O20933C182O20818C187O20779C190O20971C191O20984C196O20999C198O21011C199O21021C200O21034C205O21056C210O21056C216O21090C222O21131C228O21143C233O21167C240O21141C246O21189C251O21189C256O21244C263O21251C268O21268C269O21287C272O21281C276O21312C282O21357C299O21357C304O21412C306O21424,,
code-creation,LazyCompile,10,256809,0x1bda378ff806,318,processTicksAndRejections node:internal/process/task_queues:68:35,0x273b9798f620,~
code-source-info,0x1bda378ff806,32,1496,2441,C0O1507C2O1554C7O1545C12O1545C19O1588C21O1593C23O1592C27O1617C34O1642C36O1641C46O1617C54O1718C59O1745C65O1777C70O1834C75O1863C110O1893C111O1906C115O1893C119O1912C121O1939C122O1952C128O1961C132O1939C137O1967C139O1994C140O2007C146O2016C152O2025C156O1994C161O2031C163O2058C164O2071C170O2080C176O2089C182O2098C186O2058C191O2104C193O2132C198O2132C215O2199C220O2203C225O2234C230O2234C245O2271C250O2271C256O2301C261O2301C264O2346C269O2336C274O2336C282O2349C285O2349C290O1515C296O2380C301O2380C305O2410C312O2410C317O2440,,
code-creation,LazyCompile,10,256861,0x1bda378ffade,43,shift node:internal/fixed_queue:108:8,0x273b97994770,~
code-source-info,0x1bda378ffade,34,3954,4180,C0O3981C5O4009C10O4009C15O4031C20O4031C26O4049C32O4148C36O4141C40O4164C42O4176,,
code-creation,LazyCompile,10,256894,0x1bda378ffc26,54,shift node:internal/fixed_queue:80:8,0x273b97994580,~
code-source-info,0x1bda378ffc26,34,3300,3510,C0O3331C5O3341C9O3335C13O3354C15O3388C16O3400C17O3410C22O3420C28O3428C32O3465C36O3472C42O3479C44O3477C47O3457C51O3490C53O3506,,
code-creation,LazyCompile,10,256929,0x1bda378ffd5e,42,emitBeforeScript node:internal/async_hooks:508:26,0x2842ea0b8000,~
code-source-info,0x1bda378ffd5e,13,16802,16953,C0O16842C12O16842C17O16898C22O16911C25O16902C31O16925C36O16925C41O16952,,
code-creation,LazyCompile,10,256971,0x1bda378ffeae,180,pushAsyncContext node:internal/async_hooks:538:26,0x2842ea0b81a8,~
code-source-info,0x1bda378ffeae,13,17446,17991,C0O17501C7O17519C9O17518C13O17536C20O17570C24O17584C26O17595C32O17602C35O17613C40O17629C44O17599C49O17641C54O17648C59O17691C60O17694C65O17705C72O17728C78O17735C83O17751C85O17750C88O17733C92O17773C97O17784C104O17807C107O17811C113O17818C118O17834C120O17833C123O17816C127O17854C134O17872C142O17885C146O17891C153O17907C158O17926C162O17939C169O17955C174O17972C179O17990,,
code-creation,LazyCompile,10,257030,0x3b5adb5bf096,46,afterWriteTick node:internal/streams/writable:483:24,0x2b4a88f88390,~
code-source-info,0x3b5adb5bf096,64,15073,15189,C0O15076C5O15084C10O15091C15O15098C20O15108C21O15133C25O15143C40O15150C45O15187,,
code-creation,LazyCompile,10,257077,0x3b5adb5bf1ee,104,afterWrite node:internal/streams/writable:488:20,0x2b4a88f883e0,~
code-source-info,0x3b5adb5bf1ee,64,15210,15566,C0O15266C7O15284C14O15303C20O15310C25O15329C30O15342C32O15363C33O15379C37O15399C45O15399C50O15436C60O15436C65O15447C71O15462C75O15470C78O15421C81O15493C87O15510C90O15510C94O15537C97O15537C103O15565,,
code-creation,LazyCompile,10,257110,0x3b5adb5bf37e,35,get node:internal/streams/duplex:102:8,0x39a167da8d30,~
code-source-info,0x3b5adb5bf37e,56,3577,3786,C0O3597C6O3642C12O3682C13O3695C14O3722C19O3737C25O3755C30O3770C34O3780,,
code-creation,LazyCompile,10,257151,0x3b5adb5bf4be,87, node:internal/console/constructor:339:10,0x109acf096948,~
code-source-info,0x3b5adb5bf4be,37,10154,10972,C0O10371C7O10388C9O10384C17O10416C26O10435C31O10448C35O10476C40O10491C46O10887C54O10887C61O10910C66O10934C79O10934C86O10971,,
code-creation,LazyCompile,10,257204,0x3b5adb5bf616,85,finishMaybe node:internal/streams/writable:732:21,0x2b4a88f886b8,~
code-source-info,0x3b5adb5bf616,64,21361,21653,C0O21387C3O21391C9O21416C12O21416C17O21456C23O21466C31O21475C37O21502C43O21517C47O21527C51O21547C54O21555C68O21555C75O21611C78O21611C84O21652,,
code-creation,LazyCompile,10,257239,0x3b5adb5bf7a6,73,needFinish node:internal/streams/writable:651:20,0x2b4a88f885c8,~
code-source-info,0x3b5adb5bf7a6,64,19376,19667,C0O19402C6O19428C12O19459C18O19466C23O19492C30O19519C35O19528C41O19535C46O19561C53O19590C60O19618C67O19651C72O19665,,
code-creation,LazyCompile,10,257263,0x3b5adb5bf8de,13,destroyHooksExist node:internal/async_hooks:485:27,0x2842ea0b7f10,~
code-source-info,0x3b5adb5bf8de,13,16251,16286,C0O16258C5O16274C8O16265C12O16284,,
code-creation,LazyCompile,10,257287,0x3b5adb5bf9ce,32,emitAfterScript node:internal/async_hooks:516:25,0x2842ea0b8050,~
code-source-info,0x3b5adb5bf9ce,13,16980,17076,C0O16994C5O17007C8O16998C14O17020C19O17020C23O17049C26O17049C31O17075,,
code-creation,LazyCompile,10,257330,0x3b5adb5bfb36,167,popAsyncContext node:internal/async_hooks:552:25,0x2842ea0b81f8,~
code-source-info,0x3b5adb5bfb36,13,18080,18667,C0O18114C7O18132C9O18131C13O18149C14O18165C19O18172C20O18185C21O18189C24O18193C31O18216C36O18232C38O18231C44O18251C49O18333C54O18340C58O18366C59O18389C61O18401C65O18408C72O18424C77O18445C80O18456C87O18474C90O18471C93O18443C97O18487C104O18503C109O18522C112O18533C119O18551C122O18560C125O18548C128O18520C132O18568C137O18594C142O18594C146O18603C153O18621C158O18635C162O18647C163O18661C166O18665,,
code-creation,LazyCompile,10,257360,0x3b5adb5bfd16,13,enabledHooksExist node:internal/async_hooks:473:27,0x2842ea0b7e00,~
code-source-info,0x3b5adb5bfd16,13,16074,16107,C0O16081C5O16097C8O16088C12O16105,,
code-creation,LazyCompile,10,257514,0x1926463627ce,627,processPromiseRejections node:internal/process/promises:211:34,0x273b97992f00,~
script-source,33,node:internal/process/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeWeakMap\x2C\n} = primordials;\n\nconst {\n  tickInfo\x2C\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler\x2C\n    kPromiseHandlerAddedAfterReject\x2C\n    kPromiseResolveAfterResolved\x2C\n    kPromiseRejectAfterResolved\n  }\x2C\n  setPromiseRejectCallback\n} = internalBinding('task_queue');\n\nconst {\n  noSideEffectsToString\x2C\n  triggerUncaughtException\n} = internalBinding('errors');\n\nconst {\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  symbols: {\n    async_id_symbol: kAsyncIdSymbol\x2C\n    trigger_async_id_symbol: kTriggerAsyncIdSymbol\n  }\n} = require('internal/async_hooks');\nconst { isErrorStackTraceLimitWritable } = require('internal/errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection'\x2C but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection'\x2C then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\n// Otherwise\x2C emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled\x2C emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'UnhandledPromiseRejectionWarning'\x2C then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction isErrorLike(o) {\n  return typeof o === 'object' &&\n         o !== null &&\n         ObjectPrototypeHasOwnProperty(o\x2C 'stack');\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type\x2C promise\x2C reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise\x2C reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve'\x2C promise\x2C reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject'\x2C promise\x2C reason);\n      break;\n  }\n}\n\nfunction resolveError(type\x2C promise\x2C reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    process.emit('multipleResolves'\x2C type\x2C promise\x2C reason);\n  });\n}\n\nfunction unhandledRejection(promise\x2C reason) {\n  const emit = (reason\x2C promise\x2C promiseInfo) => {\n    if (promiseInfo.domain) {\n      return promiseInfo.domain.emit('error'\x2C reason);\n    }\n    return process.emit('unhandledRejection'\x2C reason\x2C promise);\n  };\n\n  maybeUnhandledPromises.set(promise\x2C {\n    reason\x2C\n    uid: ++lastPromiseId\x2C\n    warned: false\x2C\n    domain: process.domain\x2C\n    emit\n  });\n  // This causes the promise to be referenced at least for one tick.\n  ArrayPrototypePush(pendingUnhandledRejections\x2C promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections\x2C { promise\x2C warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid\x2C reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName\x2C\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block\x2C ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection\x2C use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\n  );\n  try {\n    if (isErrorLike(reason)) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack\x2C unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    }\n  } catch {\n    try {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    } catch {\n      // Ignore.\n    }\n  }\n\n  process.emitWarning(warning);\n}\n\n// If this method returns true\x2C we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise\x2C warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit('rejectionHandled'\x2C promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason\x2C uid\x2C emit } = promiseInfo;\n\n    let needPop = true;\n    const {\n      [kAsyncIdSymbol]: promiseAsyncId\x2C\n      [kTriggerAsyncIdSymbol]: promiseTriggerAsyncId\x2C\n    } = promise;\n    // We need to check if async_hooks are enabled\n    // don't use enabledHooksExist as a Promise could\n    // come from a vm.* context and not have an async id\n    if (typeof promiseAsyncId !== 'undefined') {\n      pushAsyncContext(\n        promiseAsyncId\x2C\n        promiseTriggerAsyncId\x2C\n        promise\n      );\n    }\n    try {\n      switch (unhandledRejectionsMode) {\n        case kStrictUnhandledRejections: {\n          const err = isErrorLike(reason) ?\n            reason : generateUnhandledRejectionError(reason);\n          // This destroys the async stack\x2C don't clear it after\n          triggerUncaughtException(err\x2C true /* fromPromise */);\n          if (typeof promiseAsyncId !== 'undefined') {\n            pushAsyncContext(\n              promise[kAsyncIdSymbol]\x2C\n              promise[kTriggerAsyncIdSymbol]\x2C\n              promise\n            );\n          }\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kIgnoreUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          break;\n        }\n        case kAlwaysWarnUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kThrowUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            const err = isErrorLike(reason) ?\n              reason : generateUnhandledRejectionError(reason);\n              // This destroys the async stack\x2C don't clear it after\n            triggerUncaughtException(err\x2C true /* fromPromise */);\n            needPop = false;\n          }\n          break;\n        }\n        case kWarnWithErrorCodeUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            emitUnhandledRejectionWarning(uid\x2C reason);\n            process.exitCode = 1;\n          }\n          break;\n        }\n      }\n    } finally {\n      if (needPop) {\n        if (typeof promiseAsyncId !== 'undefined') {\n          popAsyncContext(promiseAsyncId);\n        }\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name\x2C message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err\x2C 'name'\x2C {\n    value: name\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\x2C\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block\x2C ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `"${noSideEffectsToString(reason)}".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection'\x2C message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn\x2C\n  setHasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n};\n
code-source-info,0x1926463627ce,33,6440,9566,C0O6485C6O6508C13O6515C17O6560C23O6553C30O6560C35O6600C43O6620C47O6600C53O6579C58O6588C64O6649C68O6662C78O6662C86O6705C90O6713C96O6713C101O6523C104O6758C110O6785C115O6805C126O6805C128O6831C136O6851C140O6831C145O6904C151O6927C157O6927C163O6945C165O6984C167O7004C168O7023C172O7043C177O7051C182O7056C187O7097C189O7217C198O7113C203O7139C215O7186C227O7392C233O7443C248O7443C256O7563C264O7611C273O8266C282O8382C291O8556C300O9000C309O7663C313O7663C327O7706C332O7822C341O7822C346O7887C352O7944C360O7984C362O7983C369O8023C371O8022C379O7944C384O8122C393O8122C399O8168C401O8182C405O8182C410O8236C412O8306C421O8306C426O8352C428O8426C437O8426C442O8472C446O8472C451O8526C453O8611C462O8611C468O8657C470O8697C474O8697C488O8742C493O8864C502O8864C507O8931C509O8970C511O9067C520O9067C526O9113C528O9141C532O9141C537O9197C543O9214C547O9241C564O9288C570O9311C576O9366C582O9366C597O9427C599O6795C605O9473C611O9524C615O9551C622O9558C626O9564,,
tick,0xfeec4b,258109,0,0x0,3,0x1229670,0x1bda378ff923
code-creation,LazyCompile,10,258129,0x192646363726,25,setHasRejectionToWarn node:internal/process/promises:75:31,0x273b97992470,~
code-source-info,0x192646363726,33,2095,2155,C0O2107C7O2116C12O2139C19O2137C24O2154,,
profiler,end
delete,MemoryChunk,0x2842ea080000
delete,MemoryChunk,0x136fed700000
delete,MemoryChunk,0x273b97980000
delete,MemoryChunk,0x39a167d80000
delete,MemoryChunk,0x2b4a88f80000
delete,MemoryChunk,0x2989f3580000
delete,MemoryChunk,0x961eb000000
delete,MemoryChunk,0x36e7b7880000
delete,MemoryChunk,0x3966212c0000
delete,MemoryChunk,0xdd574200000
delete,MemoryChunk,0x109acf080000
delete,MemoryChunk,0x25349b140000
delete,MemoryChunk,0x192646340000
delete,MemoryChunk,0x1bda378c0000
delete,MemoryChunk,0x3b5adb580000
delete,MemoryChunk,0x7f07fc000000
delete,MemoryChunk,0x7f07fc040000
delete,MemoryChunk,0xdbdde640000
delete,MemoryChunk,0x512dc00000
delete,MemoryChunk,0x203833f00000
delete,MemoryChunk,0x288f16f80000
delete,MemoryChunk,0x190d87e40000
delete,MemoryChunk,0x2590d1ec0000
delete,MemoryChunk,0x27cefa740000
delete,MemoryChunk,0x1a66eb300000
delete,MemoryChunk,0x20812a600000
delete,MemoryChunk,0x2a49abc80000
delete,MemoryChunk,0x29ae5e440000
